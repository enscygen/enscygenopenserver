<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STV Election Calculator</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Papa Parse for robust CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Custom styles to enhance Tailwind */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }
        .card {
            background-color: white;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease-in-out;
        }
        .card:hover {
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -2px rgb(0 0 0 / 0.1);
        }
        .btn {
            transition: all 0.2s ease-in-out;
        }
        .btn:hover {
            transform: translateY(-2px);
        }
        /* Style for file input */
        input[type="file"]::file-selector-button {
            @apply font-semibold bg-indigo-50 text-indigo-700 border-0 px-4 py-2 rounded-lg cursor-pointer hover:bg-indigo-100 transition-colors;
        }
        /* Animation for result cards appearing */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
    </style>
</head>
<body class="antialiased text-slate-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        
        <!-- Header Section -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-slate-900">Single Transferable Vote (STV)</h1>
            <p class="text-lg text-slate-600 mt-2">Election Results Calculator</p>
        </header>

        <!-- Main Content Area -->
        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <!-- Left Column: Instructions and Inputs -->
            <div class="lg:col-span-1 space-y-6">
                <div class="card p-6">
                    <h2 class="text-2xl font-bold text-slate-900 mb-4 border-b pb-2">How to Use</h2>
                    <ol class="list-decimal list-inside space-y-3 text-slate-700">
                        <li>
                            <strong>Prepare your CSV:</strong> Each row is a ballot. Each column is a preference. A header row (e.g., 'Preference 1', 'Preference 2') is optional and will be ignored.
                            <a href="#" id="download-sample" class="text-indigo-600 hover:text-indigo-800 text-sm block mt-1">Download sample.csv</a>
                        </li>
                        <li><strong>Upload CSV:</strong> Use the file generated by the Voting Interface or your own.</li>
                        <li><strong>Set Seats:</strong> Enter the number of candidates to be elected.</li>
                        <li><strong>Calculate:</strong> Click the "Run Calculation" button.</li>
                    </ol>
                </div>

                <div class="card p-6">
                    <h2 class="text-2xl font-bold text-slate-900 mb-4">Election Setup</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="csv-file" class="block text-sm font-medium text-slate-700 mb-1">1. Upload Ballots (CSV)</label>
                            <input type="file" id="csv-file" accept=".csv" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 cursor-pointer">
                        </div>
                        <div>
                            <label for="seats-to-fill" class="block text-sm font-medium text-slate-700 mb-1">2. Number of Seats to Fill</label>
                            <input type="number" id="seats-to-fill" value="3" min="1" class="mt-1 block w-full px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500">
                        </div>
                        <button id="calculate-btn" class="w-full btn bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 shadow-lg">
                            Run Calculation
                        </button>
                    </div>
                </div>
                 <div id="error-container" class="hidden card bg-red-100 border border-red-300 text-red-800 p-4"></div>
            </div>

            <!-- Right Column: Results -->
            <div class="lg:col-span-2 space-y-6">
                <div id="summary-container" class="hidden"></div>
                <div id="results-container">
                    <div class="card p-6 text-center text-slate-500">
                        <p>Results will be displayed here after calculation.</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- DOM ELEMENT REFERENCES ---
        const calculateBtn = document.getElementById('calculate-btn');
        const fileInput = document.getElementById('csv-file');
        const seatsInput = document.getElementById('seats-to-fill');
        const resultsContainer = document.getElementById('results-container');
        const summaryContainer = document.getElementById('summary-container');
        const errorContainer = document.getElementById('error-container');
        const downloadSampleBtn = document.getElementById('download-sample');

        // --- EVENT LISTENERS ---
        calculateBtn.addEventListener('click', handleCalculation);
        downloadSampleBtn.addEventListener('click', downloadSampleCSV);

        /**
         * Downloads a sample CSV file to guide the user.
         */
        function downloadSampleCSV(e) {
            e.preventDefault();
            const csvContent = [
                "Preference 1,Preference 2,Preference 3",
                "Candidate A,Candidate B,Candidate C",
                "Candidate B,Candidate C,Candidate D",
                "Candidate C,Candidate A",
                "Candidate D,Candidate B",
                "Candidate A,Candidate D",
                "Candidate B,Candidate A,Candidate C",
                "Candidate C",
                "Candidate D,Candidate A,Candidate B",
                "Candidate A,Candidate C",
                "Candidate B",
                "Candidate C,Candidate B",
                "Candidate D",
                "Candidate A,Candidate B",
                "Candidate B,Candidate D",
                "Candidate C,Candidate A,Candidate D"
            ].join("\n");
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "sample_ballots.csv");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        /**
         * Handles the main calculation process when the button is clicked.
         */
        function handleCalculation() {
            const file = fileInput.files[0];
            const seatsToFill = parseInt(seatsInput.value, 10);

            clearMessages();
            if (!file) {
                showError("Please upload a CSV file with ballot data.");
                return;
            }
            if (isNaN(seatsToFill) || seatsToFill < 1) {
                showError("Please enter a valid number of seats to fill.");
                return;
            }

            calculateBtn.disabled = true;
            calculateBtn.textContent = "Calculating...";
            
            Papa.parse(file, {
                header: false,
                skipEmptyLines: true,
                complete: (results) => {
                    let allRows = results.data;
                    if (allRows.length === 0) {
                        showError("The CSV file is empty or invalid.");
                        resetButton();
                        return;
                    }
                    const firstRow = allRows[0];
                    const isHeader = firstRow.every(cell => typeof cell === 'string' && cell.trim().toLowerCase().startsWith('preference'));
                    const ballotData = isHeader ? allRows.slice(1) : allRows;
                    const rawBallots = ballotData.filter(row => row.some(cell => cell && cell.trim() !== ''));

                    if (rawBallots.length === 0) {
                        showError("No valid ballot data found in the CSV file.");
                        resetButton();
                        return;
                    }
                    runSTV(rawBallots, seatsToFill);
                },
                error: (err) => {
                    showError(`CSV parsing error: ${err.message}`);
                    resetButton();
                }
            });
        }

        /**
         * The core STV calculation logic.
         */
        function runSTV(rawBallots, seatsToFill) {
            const ballots = rawBallots.map((preferences, index) => ({
                id: index,
                preferences: preferences.map(p => p.trim()).filter(Boolean),
                weight: 1.0,
            }));

            const candidateNames = [...new Set(ballots.flatMap(b => b.preferences))];
            
            if (candidateNames.length < seatsToFill) {
                showError("There are fewer candidates than seats to fill. All candidates are elected by default.");
                displayFinalResults(candidateNames, 0, []);
                resetButton();
                return;
            }

            let candidates = {};
            candidateNames.forEach(name => {
                candidates[name] = { status: 'hopeful', votes: 0 };
            });

            const quota = Math.floor(ballots.length / (seatsToFill + 1)) + 1;
            let elected = [];
            let roundLogs = [];
            let round = 1;

            while (elected.length < seatsToFill && Object.values(candidates).some(c => c.status === 'hopeful')) {
                let roundLog = { round, counts: {}, events: [] };

                Object.values(candidates).forEach(c => c.votes = 0);
                let exhaustedVotes = 0;
                ballots.forEach(ballot => {
                    let voted = false;
                    for (const pref of ballot.preferences) {
                        const candidate = candidates[pref];
                        if (candidate && candidate.status !== 'eliminated') {
                            candidate.votes += ballot.weight;
                            voted = true;
                            break;
                        }
                    }
                    if (!voted) exhaustedVotes += ballot.weight;
                });
                
                candidateNames.forEach(name => {
                    roundLog.counts[name] = {
                        votes: candidates[name].votes,
                        status: candidates[name].status
                    };
                });
                roundLog.exhaustedVotes = exhaustedVotes;

                if (round === 1) {
                    const zeroVoteCandidates = candidateNames.filter(name => candidates[name].status === 'hopeful' && candidates[name].votes === 0);
                    if (zeroVoteCandidates.length > 0) {
                        roundLog.events.push({ type: 'elimination_zero', candidates: zeroVoteCandidates });
                        zeroVoteCandidates.forEach(name => {
                            candidates[name].status = 'eliminated';
                            roundLog.counts[name].status = 'eliminated';
                        });
                    }
                }

                let newWinners = [];
                candidateNames.forEach(name => {
                    const cand = candidates[name];
                    if (cand.status === 'hopeful' && cand.votes >= quota) {
                        cand.status = 'elected';
                        elected.push(name);
                        newWinners.push(name);
                        roundLog.events.push({ type: 'election', candidate: name, votes: cand.votes });
                    }
                });
                
                if (newWinners.length > 0) {
                    newWinners.forEach(winnerName => {
                        const winner = candidates[winnerName];
                        const surplus = winner.votes - quota;
                        if (surplus > 0) {
                            const transferValue = surplus / winner.votes;
                            const transfers = {};
                            ballots.forEach(ballot => {
                                for (const pref of ballot.preferences) {
                                    const cand = candidates[pref];
                                    if (cand && cand.status !== 'eliminated') {
                                        if (pref === winnerName) {
                                            const valueToTransfer = ballot.weight * transferValue;
                                            let nextPrefFound = false;
                                            for (let i = ballot.preferences.indexOf(pref) + 1; i < ballot.preferences.length; i++) {
                                                const nextCandName = ballot.preferences[i];
                                                const nextCand = candidates[nextCandName];
                                                if (nextCand && nextCand.status === 'hopeful') {
                                                    transfers[nextCandName] = (transfers[nextCandName] || 0) + valueToTransfer;
                                                    nextPrefFound = true;
                                                    break;
                                                }
                                            }
                                            if (!nextPrefFound) transfers['Exhausted'] = (transfers['Exhausted'] || 0) + valueToTransfer;
                                        }
                                        break;
                                    }
                                }
                            });
                            roundLog.events.push({ type: 'surplus', candidate: winnerName, surplus, transferValue, transfers });
                            ballots.forEach(ballot => {
                                for (const pref of ballot.preferences) {
                                     if (candidates[pref] && candidates[pref].status !== 'eliminated') {
                                        if (pref === winnerName) ballot.weight *= transferValue;
                                        break;
                                     }
                                }
                            });
                        }
                    });
                } else {
                    const hopefuls = Object.entries(candidates).filter(([, c]) => c.status === 'hopeful');
                    if (hopefuls.length <= (seatsToFill - elected.length)) {
                        hopefuls.forEach(([name, cand]) => {
                            cand.status = 'elected';
                            elected.push(name);
                            roundLog.events.push({ type: 'election_remaining', candidate: name });
                        });
                        roundLogs.push(roundLog);
                        break;
                    }

                    if (hopefuls.length > 0) {
                        hopefuls.sort(([, a], [, b]) => a.votes - b.votes);
                        const toEliminateName = hopefuls[0][0];
                        const transfers = {};
                        ballots.forEach(ballot => {
                            for (const pref of ballot.preferences) {
                                const cand = candidates[pref];
                                if (cand && cand.status !== 'eliminated') {
                                    if (pref === toEliminateName) {
                                        const valueToTransfer = ballot.weight;
                                        let nextPrefFound = false;
                                        for (let i = ballot.preferences.indexOf(pref) + 1; i < ballot.preferences.length; i++) {
                                            const nextCandName = ballot.preferences[i];
                                            const nextCand = candidates[nextCandName];
                                            if (nextCand && nextCand.status !== 'eliminated') {
                                                transfers[nextCandName] = (transfers[nextCandName] || 0) + valueToTransfer;
                                                nextPrefFound = true;
                                                break;
                                            }
                                        }
                                        if (!nextPrefFound) transfers['Exhausted'] = (transfers['Exhausted'] || 0) + valueToTransfer;
                                    }
                                    break;
                                }
                            }
                        });
                        roundLog.events.push({ type: 'elimination', candidate: toEliminateName, votes: candidates[toEliminateName].votes, transfers });
                        candidates[toEliminateName].status = 'eliminated';
                    }
                }
                
                roundLogs.push(roundLog);
                round++;
                if (round > 50) {
                    showError("Calculation exceeded 50 rounds and was stopped. There might be a complex tie.");
                    break;
                }
            }

            displayFinalResults(elected, quota, roundLogs);
            resetButton();
        }

        function displayFinalResults(elected, quota, roundLogs) {
            summaryContainer.innerHTML = `
                <div class="card p-6 fade-in">
                    <h2 class="text-2xl font-bold text-slate-900 mb-4">Election Summary</h2>
                    <div class="space-y-3">
                        <div>
                            <span class="font-semibold text-slate-600">Winning Quota:</span>
                            <span class="font-bold text-lg text-indigo-700 ml-2">${quota.toFixed(2)} votes</span>
                        </div>
                        <div>
                            <p class="font-semibold text-slate-600 mb-2">Elected Candidates:</p>
                            <ul class="flex flex-wrap gap-3">
                                ${elected.length > 0 ? elected.map(name => `<li class="bg-green-100 text-green-800 font-bold py-2 px-4 rounded-full text-lg">${name}</li>`).join('') : `<li class="text-slate-500">No candidates were elected.</li>`}
                            </ul>
                        </div>
                    </div>
                </div>`;
            summaryContainer.classList.remove('hidden');
            resultsContainer.innerHTML = roundLogs.map(log => renderRound(log, quota)).join('');
        }

        function renderRound(log, quota) {
            const sortedCandidates = Object.entries(log.counts).sort(([, a], [, b]) => b.votes - a.votes);
            const renderTransfers = (transfers) => {
                if (!transfers || Object.keys(transfers).length === 0) return '';
                return `
                    <div class="ml-4 mt-1 text-xs text-slate-600 border-l-2 border-slate-200 pl-2">
                        <strong>Transfer Details:</strong>
                        <ul class="list-disc list-inside">
                            ${Object.entries(transfers).sort(([,a],[,b]) => b-a).map(([name, votes]) => `<li>To ${name}: +${votes.toFixed(2)} votes</li>`).join('')}
                        </ul>
                    </div>`;
            };

            return `
            <div class="card p-6 mb-6 fade-in" style="animation-delay: ${log.round * 100}ms">
                <h3 class="text-xl font-bold text-slate-900 mb-4">Round ${log.round}</h3>
                <div class="mb-4 space-y-2">
                    ${log.events.map(event => {
                        let html = '';
                        if (event.type === 'election') html = `<p class="font-semibold text-green-700">✅ ${event.candidate} was ELECTED with ${event.votes.toFixed(2)} votes.</p>`;
                        if (event.type === 'election_remaining') html = `<p class="font-semibold text-green-700">✅ ${event.candidate} was ELECTED as a remaining candidate.</p>`;
                        if (event.type === 'surplus') {
                            html = `<p class="text-blue-700">↪️ Transferring surplus of ${event.surplus.toFixed(2)} from ${event.candidate}.</p>${renderTransfers(event.transfers)}`;
                        }
                        if (event.type === 'elimination_zero') html = `<p class="font-semibold text-red-700">❌ Mass Elimination: The following candidates were eliminated with 0 votes: ${event.candidates.join(', ')}.</p>`;
                        if (event.type === 'elimination') {
                            html = `<p class="font-semibold text-red-700">❌ ${event.candidate} was ELIMINATED with ${event.votes.toFixed(2)} votes.</p>${renderTransfers(event.transfers)}`;
                        }
                        return html;
                    }).join('')}
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full text-left text-sm">
                        <thead class="bg-slate-50 text-slate-600 uppercase">
                            <tr>
                                <th class="p-2">Candidate</th><th class="p-2">Status</th><th class="p-2 text-right">Votes</th><th class="p-2 w-1/2">Vote Bar</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-slate-200">
                            ${sortedCandidates.map(([name, data]) => `
                                <tr>
                                    <td class="p-2 font-medium">${name}</td>
                                    <td class="p-2">${renderStatus(data.status)}</td>
                                    <td class="p-2 text-right font-mono">${data.votes.toFixed(2)}</td>
                                    <td class="p-2">
                                        <div class="w-full bg-slate-200 rounded-full h-4">
                                            <div class="bg-indigo-500 h-4 rounded-full" style="width: ${Math.min(100, (data.votes / quota) * 100)}%"></div>
                                        </div>
                                    </td>
                                </tr>`).join('')}
                             <tr>
                                <td class="p-2 font-medium text-slate-500">Exhausted</td>
                                <td class="p-2"></td>
                                <td class="p-2 text-right font-mono text-slate-500">${log.exhaustedVotes.toFixed(2)}</td>
                                <td class="p-2"></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>`;
        }
        
        function renderStatus(status) {
            if (status === 'elected') return `<span class="font-bold text-green-600">Elected</span>`;
            if (status === 'eliminated') return `<span class="text-red-600">Eliminated</span>`;
            return `<span class="text-slate-500">Hopeful</span>`;
        }

        function showError(message) {
            errorContainer.textContent = message;
            errorContainer.classList.remove('hidden');
        }

        function clearMessages() {
            errorContainer.textContent = '';
            errorContainer.classList.add('hidden');
            resultsContainer.innerHTML = `<div class="card p-6 text-center text-slate-500"><p>Results will be displayed here after calculation.</p></div>`;
            summaryContainer.classList.add('hidden');
        }
        
        function resetButton() {
            calculateBtn.disabled = false;
            calculateBtn.textContent = "Run Calculation";
        }

    </script>
</body>
</html>

