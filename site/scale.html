<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScaleLab by Enscygen</title>
    <link rel="icon" type="image/x-icon" href="/Favicon.png">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Universal box-sizing for consistent layout */
        * {
            box-sizing: border-box;
        }

        /* Custom CSS for the entire application */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f4f8; /* Light blue-gray background */
            margin: 0;
            padding: 20px; /* Add some padding around the app */
            box-sizing: border-box;
        }

        #app-container {
            display: flex;
            flex-direction: column;
            background-color: #ffffff;
            border-radius: 16px; /* More rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Softer shadow */
            overflow: hidden;
            max-width: 1200px; /* Max width for larger screens */
            width: 100%;
            padding: 24px; /* Internal padding */
            gap: 24px; /* Equivalent to gap-6 */
        }

        @media (min-width: 1024px) { /* Equivalent to lg breakpoint */
            #app-container {
                flex-direction: row;
            }
        }

        .control-panel {
            width: 100%;
            background-color: #f8fafc; /* Equivalent to bg-gray-50 */
            padding: 24px;
            border-radius: 8px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06); /* Equivalent to shadow-inner */
            display: flex;
            flex-direction: column;
            gap: 16px; /* Equivalent to gap-4 */
        }

        @media (min-width: 1024px) {
            .control-panel {
                width: 25%; /* Equivalent to lg:w-1/4 */
            }
        }

        .control-panel h2 {
            font-size: 1.5rem; /* Equivalent to text-2xl */
            font-weight: 700; /* Equivalent to font-bold */
            color: #1f2937; /* Equivalent to text-gray-800 */
            margin-bottom: 16px; /* Equivalent to mb-4 */
        }

        .control-panel .mb-4 {
            margin-bottom: 16px; /* Equivalent to mb-4 */
        }

        .control-panel label {
            display: block;
            font-size: 0.875rem; /* Equivalent to text-sm */
            font-weight: 500; /* Equivalent to font-medium */
            color: #374151; /* Equivalent to text-gray-700 */
            margin-bottom: 8px; /* Equivalent to mb-2 */
        }

        .control-panel .flex-col-gap-3 {
            display: flex;
            flex-direction: column;
            gap: 12px; /* Equivalent to gap-3 */
        }

        .control-panel .mt-4 {
            margin-top: 16px; /* Equivalent to mt-4 */
        }

        .control-panel .mt-6 {
            margin-top: 24px; /* Equivalent to mt-6 */
        }

        .control-panel .flex-grow {
            flex-grow: 1;
        }

        .control-panel .overflow-y-auto {
            overflow-y: auto;
        }

        .control-panel .max-h-64 {
            max-height: 16rem; /* Equivalent to max-h-64 (256px) */
        }

        .control-panel h3 {
            font-size: 1.125rem; /* Equivalent to text-lg */
            font-weight: 600; /* Equivalent to font-semibold */
            color: #374151; /* Equivalent to text-gray-700 */
            margin-bottom: 12px; /* Equivalent to mb-3 */
        }

        .control-panel .flex-col-gap-2 {
            display: flex;
            flex-direction: column;
            gap: 8px; /* Equivalent to gap-2 */
        }

        .control-panel .text-gray-500 {
            color: #6b7280; /* Equivalent to text-gray-500 */
        }

        .control-panel .text-sm {
            font-size: 0.875rem; /* Equivalent to text-sm */
        }

        .control-panel .italic {
            font-style: italic;
        }

        #canvas-area {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        @media (min-width: 1024px) {
            #canvas-area {
                width: 75%; /* Equivalent to lg:w-3/4 */
            }
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #e2e8f0; /* Lighter blue-gray for canvas background */
            border-radius: 8px;
            overflow: hidden; /* Reverted to hidden */
        }

        canvas {
            display: block;
            border-radius: 8px;
            border: 2px dashed #d1d5db; /* Equivalent to border-2 border-dashed border-gray-300 */
            max-width: 100%; /* Ensure canvas scales down if image is smaller than container */
            height: auto; /* Maintain aspect ratio */
        }

        #canvasPlaceholder {
            position: absolute;
            color: #9ca3af; /* Equivalent to text-gray-400 */
            font-size: 1.125rem; /* Equivalent to text-lg */
        }

        #canvasPlaceholder.hidden {
            display: none;
        }

        /* Modal styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: #000;
            text-decoration: none;
            cursor: pointer;
        }

        /* Button styling */
        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: none;
            width: 100%; /* Equivalent to w-full */
        }

        .btn-primary {
            background-color: #4f46e5; /* Indigo 600 */
            color: white;
        }

        .btn-primary:hover {
            background-color: #4338ca; /* Indigo 700 */
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: #e2e8f0; /* Slate 200 */
            color: #334155; /* Slate 700 */
        }

        .btn-secondary:hover {
            background-color: #cbd5e1; /* Slate 300 */
            transform: translateY(-2px);
        }

        .btn-danger {
            background-color: #ef4444; /* Red 500 */
            color: white;
        }

        .btn-danger:hover {
            background-color: #dc2626; /* Red 600 */
            transform: translateY(-2px);
        }

        /* Input and select styling */
        input[type="file"],
        input[type="number"],
        select {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #cbd5e1; /* Slate 300 */
            margin-bottom: 15px;
            width: 100%;
            box-sizing: border-box;
        }

        input[type="file"] {
            background-color: #f8fafc; /* Slate 50 */
            cursor: pointer;
        }

        input[type="file"]::-webkit-file-upload-button {
            background-color: #4f46e5;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            margin-right: 10px;
            transition: background-color 0.2s;
        }

        input[type="file"]::-webkit-file-upload-button:hover {
            background-color: #4338ca;
        }

        .measurement-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px dashed #e2e8f0;
        }

        .measurement-item:last-child {
            border-bottom: none;
        }

        .measurement-item span {
            font-size: 0.9rem;
            color: #475569; /* Slate 600 */
        }

        .measurement-item-actions {
            display: flex;
            gap: 8px;
        }

        .measurement-item-actions button {
            background: none;
            border: none;
            cursor: pointer;
            color: #64748b; /* Slate 500 */
            font-size: 1rem;
            transition: color 0.2s;
        }

        .measurement-item-actions button:hover {
            color: #1e293b; /* Slate 900 */
        }

        /* Line Settings Modal */
        #lineSettingsModal .modal-content,
        #areaSettingsModal .modal-content,
        #addLineModal .modal-content,
        #scaleLineSettingsModal .modal-content { /* Apply to all modals */
            max-width: 350px;
        }

        #lineSettingsModal label,
        #areaSettingsModal label,
        #addLineModal label,
        #scaleLineSettingsModal label { /* Apply to all modals */
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #374151;
            text-align: left;
        }

        #lineSettingsModal input[type="color"],
        #lineSettingsModal input[type="number"],
        #lineSettingsModal select,
        #areaSettingsModal input[type="color"],
        #areaSettingsModal input[type="number"],
        #areaSettingsModal select,
        #addLineModal input[type="number"],
        #addLineModal select,
        #scaleLineSettingsModal input[type="color"],
        #scaleLineSettingsModal input[type="number"],
        #scaleLineSettingsModal select { /* Apply to all modals */
            padding: 10px; /* Consistent padding */
            border-radius: 8px;
            border: 1px solid #cbd5e1;
            margin-bottom: 15px;
            width: 100%;
            box-sizing: border-box;
        }
        /* Specific height for color inputs */
        #lineSettingsModal input[type="color"],
        #areaSettingsModal input[type="color"],
        #scaleLineSettingsModal input[type="color"] {
            height: 40px;
        }

        /* Message Modal */
        #messageModal .modal-content {
            max-width: 300px;
            padding: 20px;
        }
        #messageModal p {
            margin-bottom: 20px;
        }
        #messageModal button {
            width: auto;
            padding: 8px 15px;
        }

        #scaleInfo {
            padding: 15px;
            background-color: #e0f2f7;
            /* Light cyan for info box */
            border-radius: 8px;
            border: 1px solid #b2ebf2;
            /* Cyan border */
            font-size: 0.8rem;
            color: #006064;
            /* Dark cyan text */
        }

        #scaleInfo p {
            margin-bottom: 5px;
            margin-top: 0px;
        }
        #scaleInfo p:last-child {
            margin-bottom: 0;
        }
        #scaleInfo .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            background: #fff;
            border-radius: 4px;
            padding: 5px;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            background: #fff;
            border-radius: 4px;
            padding: 5px;
        }
        input#toggleRefLine {
            margin: 0px !important;
        }
        #scaleInfo .checkbox-group input[type="checkbox"] {
            width: auto; /* Override full width for checkbox */
            margin-bottom: 0;
        }
        /* Style for the reset settings button in modals */
        .modal-content .btn-reset {
            background-color: #64748b; /* Slate 500 */
            color: white;
        }
        .modal-content .btn-reset:hover {
            background-color: #475569; /* Slate 600 */
        }
        .modal-content .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .scaling-options {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        span.sub-text-splitter {
            font-size: 0.8rem;
            color: #707070;
        }

        span.set-scaling-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: #5c5c5c;
            text-align: center;
        }

        .scaling-div {
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-bottom: 1px solid #cbd5e1;
            padding: 12px 0px;
        }

        .scalelab-image-img {
            max-width: 220px;
            width: 100%;
        }

        .scalelab-image {
            padding: 10px 0px;
        }
        #measurement-display-area {
            width: 100%;
            background-color: #f8fafc;
            /* Equivalent to bg-gray-50 */
            padding: 24px;
            border-radius: 8px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
        }
        #scaleInfo .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            background: #fff;
            border-radius: 4px;
            padding: 5px;
        }
        .modal-contents-customize {
            font-size: 0.8rem;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 20px 0px;
        }


        .customize-line-group {
            flex: 1;
            min-width: 120px;
        }

        span.sl-no {
            font-weight: bold;
            font-family: monospace;
            background: #efefef;
            padding: 5px;
        }

        span.mes-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #measurementsList{
margin-bottom:20px;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Control Panel -->
        <div class="control-panel">
            <div class="scalelab-image">
                <a href="/projects/imagetools/scalelablauncher" class="scale-lab-link"><img
                        src="/projects/icons/scalelab-logo.svg" alt="ScaleLab by Enscygen"
                        class="scalelab-image-img"></a>
            </div>

            <!-- Image Upload -->
            <div class="mb-4">
                <label for="imageInput">Upload Image:</label>
                <input type="file" id="imageInput" accept="image/*">
            </div>

            <!-- Action Buttons -->
            <div class="flex-col-gap-3">
                <div class="scaling-div">
                    <span class="set-scaling-title">Set Scale Reference (Calibration)</span>
                    <div class="scaling-options">
                        <button id="setScaleBtn" class="btn btn-primary" disabled>Draw Line</button>
                        <span class="sub-text-splitter">or</span>
                        <button id="setPixelScaleBtn" class="btn btn-primary" disabled>Pixel Size</button>
                    </div>
                </div>
                <button id="drawLineBtn" class="btn btn-primary" disabled>Draw Line</button>
                <button id="drawAreaBtn" class="btn btn-primary" disabled>Draw Area</button>
                <button id="clearAllBtn" class="btn btn-danger" disabled>Clear All</button>
                <button id="saveImageBtn" class="btn btn-primary" disabled>Save Image</button>
            </div>

            <!-- Display Unit Selection -->
            <div class="mt-4">
                <label for="displayUnitSelect">Display Units:</label>
                <select id="displayUnitSelect" disabled>
                    <option value="px">Pixels (px)</option>
                    <option value="mm">Millimeters (mm)</option>
                    <option value="cm">Centimeters (cm)</option>
                    <option value="m">Meters (m)</option>
                    <option value="um">Micrometers (µm)</option>
                </select>
            </div>

            
        </div>

        <!-- Canvas Area -->
        <div id="canvas-area">
            <div id="canvas-container">
                <canvas id="imageCanvas"></canvas>
                <p id="canvasPlaceholder">Upload an image to begin</p>
            </div>
        </div>

        <div id="measurement-display-area">
            <!-- Scale Information -->
            <div id="scaleInfo" style="display: none;">
                <h3>Calibration Details</h3>
                <p id="imageWidthDisplay">Image Width: Not set</p>
                <p id="imageHeightDisplay">Image Height: Not set</p>
                <p id="calibrationRefDisplay">Reference: Not set</p>
                <p id="pixelsPerCalibratedUnitDisplay">Pixels per Unit: Not set</p>
                <p id="unitPerPixelDisplay">1 Image Pixel = Not set</p>
                <div class="checkbox-group">
                    <input type="checkbox" id="toggleRefLine" checked>
                    <label for="toggleRefLine">Show Reference Line</label>
                </div>
            </div>

            <!-- Measurement List -->
            <div class="mt-6 flex-grow overflow-y-auto max-h-64">
                <h3>Measurements</h3>
                <div id="measurementsList" class="flex-col-gap-2">
                    <p class="text-gray-500 text-sm italic">No measurements yet.</p>
                </div>
                <!-- NEW: Add Line by Value Button -->
                <button id="addLineByValueBtn" class="btn btn-primary mt-4" disabled>
                    <i class="fas fa-plus"></i> Add Line by Value
                </button>
            </div>
        </div>
        
    </div>

    <!-- Scale Input Modal (for drawing reference line) -->
    <div id="scaleModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2 class="text-xl font-bold mb-4">Set Reference Line Scale</h2>
            <p class="mb-4 text-gray-700">Enter the real-world length of the line you just drew:</p>
            <input type="number" id="scaleLengthInput" placeholder="Enter length" class="mb-3" step="any">
            <select id="scaleUnitSelect" class="mb-5">
                <option value="mm">Millimeters (mm)</option>
                <option value="cm">Centimeters (cm)</option>
                <option value="m">Meters (m)</option>
                <option value="um">Micrometers (µm)</option>
            </select>
            <button id="saveScaleBtn" class="btn btn-primary">Save Scale</button>
        </div>
    </div>

    <!-- New: Pixel Scale Input Modal -->
    <div id="pixelScaleModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closePixelScaleModal">&times;</span>
            <h2 class="text-xl font-bold mb-4">Set 1 Pixel Scale</h2>
            <p class="mb-4 text-gray-700">Enter the real-world length that 1 image pixel represents:</p>
            <input type="number" id="pixelLengthInput" placeholder="Enter length for 1 pixel" class="mb-3" step="any">
            <select id="pixelUnitSelect" class="mb-5">
                <option value="mm">Millimeters (mm)</option>
                <option value="cm">Centimeters (cm)</option>
                <option value="m">Meters (m)</option>
                <option value="um">Micrometers (µm)</option>
            </select>
            <button id="savePixelScaleBtn" class="btn btn-primary">Save Pixel Scale</button>
        </div>
    </div>

    <!-- Line Settings Modal -->
    <div id="lineSettingsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeLineSettingsModal">&times;</span>
            <h2 class="text-xl font-bold mb-4">Line Settings</h2>
            <p class="mb-4 text-gray-700">Customize the selected line</p>
            <div class="modal-contents-customize">
                <div class="customize-line-group">
            <label for="lineColorPicker">Line Color:</label>
            <input type="color" id="lineColorPicker" value="#ff0000" class="mb-3">
                </div>
                <div class="customize-line-group">
            <label for="labelFontSizeInput">Label Font Size (px):</label>
            <input type="number" id="labelFontSizeInput" value="16" min="8" max="48" step="1" class="mb-3">
                </div> <div class="customize-line-group">
            <label for="lineThicknessInput">Line Thickness (px):</label>
            <input type="number" id="lineThicknessInput" value="2" min="1" max="10" step="1" class="mb-3">
                    </div> <div class="customize-line-group">
            <label for="labelFontColorPicker">Label Font Color:</label>
            <input type="color" id="labelFontColorPicker" value="#000000" class="mb-3">
                        </div> <div class="customize-line-group">
            <label for="labelFontWeightSelect">Label Font Weight:</label>
            <select id="labelFontWeightSelect" class="mb-3">
                <option value="normal">Normal</option>
                <option value="bold">Bold</option>
                <option value="bolder">Bolder</option>
                <option value="lighter">Lighter</option>
            </select>
                            </div> <div class="customize-line-group">
            <label for="sideBarLengthInput">Side Bar Length (px):</label>
            <input type="number" id="sideBarLengthInput" value="10" min="0" max="30" step="1" class="mb-3">
                                </div> <div class="customize-line-group">
            <label for="labelVerticalOffsetInput">Label Vertical Offset (px):</label>
            <input type="number" id="labelVerticalOffsetInput" value="0" step="1" class="mb-3">
                                    </div> <div class="customize-line-group">
            <div class="checkbox-group mb-5">
                <input type="checkbox" id="rotateLabelCheckbox">
                <label for="rotateLabelCheckbox">Rotate Label with Line</label>
            </div>
                                    </div>
            </div>
            <div class="btn-group">
                <button id="saveLineSettingsBtn" class="btn btn-primary">Save Settings</button>
                <button id="resetLineSettingsBtn" class="btn btn-secondary btn-reset">Reset Settings</button>
            </div>
        </div>
    </div>

    <!-- NEW: Scale Line Settings Modal -->
    <div id="scaleLineSettingsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeScaleLineSettingsModal">&times;</span>
            <h2 class="text-xl font-bold mb-4">Scale Line Settings</h2>
            <p class="mb-4 text-gray-700">Customize the reference scale line</p>
<div class="modal-contents-customize">
                <div class="customize-line-group">
            <label for="scaleLineLengthInput">Real-World Length:</label>
            <input type="number" id="scaleLineLengthInput" placeholder="Length" class="mb-3" step="any">
                </div><div class="customize-line-group">
            <label for="scaleLineUnitSelect">Unit:</label>
            <select id="scaleLineUnitSelect" class="mb-3">
                <option value="mm">Millimeters (mm)</option>
                <option value="cm">Centimeters (cm)</option>
                <option value="m">Meters (m)</option>
                <option value="um">Micrometers (µm)</option>
            </select>
</div><div class="customize-line-group">
            <label for="scaleLineColorPicker">Line Color:</label>
            <input type="color" id="scaleLineColorPicker" value="#ff0000" class="mb-3">
    </div><div class="customize-line-group">
            <label for="scaleLabelFontSizeInput">Label Font Size (px):</label>
            <input type="number" id="scaleLabelFontSizeInput" value="16" min="8" max="48" step="1" class="mb-3">
        </div><div class="customize-line-group">
            <label for="scaleLineThicknessInput">Line Thickness (px):</label>
            <input type="number" id="scaleLineThicknessInput" value="2" min="1" max="10" step="1" class="mb-3">
            </div><div class="customize-line-group">
            <label for="scaleLabelFontColorPicker">Label Font Color:</label>
            <input type="color" id="scaleLabelFontColorPicker" value="#000000" class="mb-3">
                </div><div class="customize-line-group">
            <label for="scaleLabelFontWeightSelect">Label Font Weight:</label>
            <select id="scaleLabelFontWeightSelect" class="mb-3">
                <option value="normal">Normal</option>
                <option value="bold">Bold</option>
                <option value="bolder">Bolder</option>
                <option value="lighter">Lighter</option>
            </select>
                    </div><div class="customize-line-group">
            <label for="scaleSideBarLengthInput">Side Bar Length (px):</label>
            <input type="number" id="scaleSideBarLengthInput" value="10" min="0" max="30" step="1" class="mb-3">
                        </div><div class="customize-line-group">
            <label for="scaleLabelVerticalOffsetInput">Label Vertical Offset (px):</label>
            <input type="number" id="scaleLabelVerticalOffsetInput" value="0" step="1" class="mb-3">
                            </div><div class="customize-line-group">
            <div class="checkbox-group mb-5">
                <input type="checkbox" id="lockScaleLineCheckbox">
                <label for="lockScaleLineCheckbox">Lock Scale Line</label>
            </div>
                            </div>
                </div>
            <div class="btn-group">
                <button id="saveScaleLineSettingsBtn" class="btn btn-primary">Save Settings</button>
                <button id="resetScaleLineSettingsBtn" class="btn btn-secondary btn-reset">Reset Settings</button>
            </div>
        </div>
    </div>

    <!-- Area Settings Modal -->
    <div id="areaSettingsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeAreaSettingsModal">&times;</span>
            <h2 class="text-xl font-bold mb-4">Area Settings</h2>
            <p class="mb-4 text-gray-700">Customize the selected area</p>
            <div class="modal-contents-customize">
                <div class="customize-line-group">
            <label for="areaStrokeColorPicker">Border Color:</label>
            <input type="color" id="areaStrokeColorPicker" value="#0000ff" class="mb-3">
                    </div><div class="customize-line-group">
            <label for="areaFillColorPicker">Fill Color:</label>
            <input type="color" id="areaFillColorPicker" value="#0000ff80" class="mb-3"> <!-- Default semi-transparent blue -->
                        </div><div class="customize-line-group">
            <label for="areaStrokeThicknessInput">Border Thickness (px):</label>
            <input type="number" id="areaStrokeThicknessInput" value="2" min="1" max="10" step="1" class="mb-3">
                            </div><div class="customize-line-group">
            <label for="areaLabelFontSizeInput">Label Font Size (px):</label>
            <input type="number" id="areaLabelFontSizeInput" value="16" min="8" max="48" step="1" class="mb-3">
                                </div><div class="customize-line-group">
            <label for="areaLabelFontColorPicker">Label Font Color:</label>
            <input type="color" id="areaLabelFontColorPicker" value="#ffffff" class="mb-3">
                                    </div><div class="customize-line-group">
            <label for="areaLabelFontWeightSelect">Label Font Weight:</label>
            <select id="areaLabelFontWeightSelect" class="mb-5">
                <option value="normal">Normal</option>
                <option value="bold">Bold</option>
                <option value="bolder">Bolder</option>
                <option value="lighter">Lighter</option>
            </select>
                                    </div>
            <button id="saveAreaSettingsBtn" class="btn btn-primary">Save Settings</button>
        </div>
    </div>

    <!-- NEW: Add Line by Value Modal -->
    <div id="addLineModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeAddLineModal">&times;</span>
            <h2 class="text-xl font-bold mb-4">Add Line by Value</h2>
            <p class="mb-4 text-gray-700">Enter the desired length and orientation for the new line:</p>
            <label for="newLineLengthInput">Line Length:</label>
            <input type="number" id="newLineLengthInput" placeholder="Enter length" class="mb-3" step="any">
            <label for="newLineUnitSelect">Unit:</label>
            <select id="newLineUnitSelect" class="mb-3">
                <option value="mm">Millimeters (mm)</option>
                <option value="cm">Centimeters (cm)</option>
                <option value="m">Meters (m)</option>
                <option value="um">Micrometers (µm)</option>
            </select>
            <label for="newLineOrientationSelect">Orientation:</label>
            <select id="newLineOrientationSelect" class="mb-5">
                <option value="horizontal">Horizontal</m>
                <option value="vertical">Vertical</option>
            </select>
            <button id="drawNewLineBtn" class="btn btn-primary">Draw Line</button>
        </div>
    </div>

    <!-- Generic Message Modal -->
    <div id="messageModal" class="modal">
        <div class="modal-content">
            <p id="messageText"></p>
            <button id="messageModalCloseBtn" class="btn btn-primary">OK</button>
        </div>
    </div>

    <script>
        // --- Global Variables ---
        const imageInput = document.getElementById('imageInput');
        const imageCanvas = document.getElementById('imageCanvas');
        const ctx = imageCanvas.getContext('2d');
        const setScaleBtn = document.getElementById('setScaleBtn');
        const setPixelScaleBtn = document.getElementById('setPixelScaleBtn');
        const drawLineBtn = document.getElementById('drawLineBtn');
        const drawAreaBtn = document.getElementById('drawAreaBtn');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const saveImageBtn = document.getElementById('saveImageBtn');
        const displayUnitSelect = document.getElementById('displayUnitSelect');
        const measurementsList = document.getElementById('measurementsList');
        const canvasPlaceholder = document.getElementById('canvasPlaceholder');
        const canvasContainer = document.getElementById('canvas-container');

        const scaleModal = document.getElementById('scaleModal');
        const scaleModalCloseButton = scaleModal.querySelector('.close-button');
        const scaleLengthInput = document.getElementById('scaleLengthInput');
        const scaleUnitSelect = document.getElementById('scaleUnitSelect');
        const saveScaleBtn = document.getElementById('saveScaleBtn');

        const pixelScaleModal = document.getElementById('pixelScaleModal');
        const closePixelScaleModalBtn = document.getElementById('closePixelScaleModal');
        const pixelLengthInput = document.getElementById('pixelLengthInput');
        const pixelUnitSelect = document.getElementById('pixelUnitSelect');
        const savePixelScaleBtn = document.getElementById('savePixelScaleBtn');

        const lineSettingsModal = document.getElementById('lineSettingsModal');
        const closeLineSettingsModalBtn = document.getElementById('closeLineSettingsModal');
        const lineColorPicker = document.getElementById('lineColorPicker');
        const labelFontSizeInput = document.getElementById('labelFontSizeInput');
        const lineThicknessInput = document.getElementById('lineThicknessInput');
        const labelFontColorPicker = document.getElementById('labelFontColorPicker');
        const labelFontWeightSelect = document.getElementById('labelFontWeightSelect');
        const sideBarLengthInput = document.getElementById('sideBarLengthInput');
        const labelVerticalOffsetInput = document.getElementById('labelVerticalOffsetInput');
        const rotateLabelCheckbox = document.getElementById('rotateLabelCheckbox');
        const saveLineSettingsBtn = document.getElementById('saveLineSettingsBtn');
        const resetLineSettingsBtn = document.getElementById('resetLineSettingsBtn');

        // NEW: Scale Line Settings Modal Elements
        const scaleLineSettingsModal = document.getElementById('scaleLineSettingsModal');
        const closeScaleLineSettingsModalBtn = document.getElementById('closeScaleLineSettingsModal');
        const scaleLineLengthInput = document.getElementById('scaleLineLengthInput');
        const scaleLineUnitSelect = document.getElementById('scaleLineUnitSelect');
        const scaleLineColorPicker = document.getElementById('scaleLineColorPicker');
        const scaleLabelFontSizeInput = document.getElementById('scaleLabelFontSizeInput');
        const scaleLineThicknessInput = document.getElementById('scaleLineThicknessInput');
        const scaleLabelFontColorPicker = document.getElementById('scaleLabelFontColorPicker');
        const scaleLabelFontWeightSelect = document.getElementById('scaleLabelFontWeightSelect');
        const scaleSideBarLengthInput = document.getElementById('scaleSideBarLengthInput');
        const scaleLabelVerticalOffsetInput = document.getElementById('scaleLabelVerticalOffsetInput');
        const lockScaleLineCheckbox = document.getElementById('lockScaleLineCheckbox');
        const saveScaleLineSettingsBtn = document.getElementById('saveScaleLineSettingsBtn');
        const resetScaleLineSettingsBtn = document.getElementById('resetScaleLineSettingsBtn');


        const areaSettingsModal = document.getElementById('areaSettingsModal');
        const closeAreaSettingsModalBtn = document.getElementById('closeAreaSettingsModal');
        const areaStrokeColorPicker = document.getElementById('areaStrokeColorPicker');
        const areaFillColorPicker = document.getElementById('areaFillColorPicker');
        const areaStrokeThicknessInput = document.getElementById('areaStrokeThicknessInput');
        const areaLabelFontSizeInput = document.getElementById('areaLabelFontSizeInput');
        const areaLabelFontColorPicker = document.getElementById('areaLabelFontColorPicker');
        const areaLabelFontWeightSelect = document.getElementById('areaLabelFontWeightSelect');
        const saveAreaSettingsBtn = document.getElementById('saveAreaSettingsBtn');

        const addLineByValueBtn = document.getElementById('addLineByValueBtn');
        const addLineModal = document.getElementById('addLineModal');
        const closeAddLineModalBtn = document.getElementById('closeAddLineModal');
        const newLineLengthInput = document.getElementById('newLineLengthInput');
        const newLineUnitSelect = document.getElementById('newLineUnitSelect');
        const newLineOrientationSelect = document.getElementById('newLineOrientationSelect');
        const drawNewLineBtn = document.getElementById('drawNewLineBtn');

        const messageModal = document.getElementById('messageModal');
        const messageText = document.getElementById('messageText');
        const messageModalCloseBtn = document.getElementById('messageModalCloseBtn');

        const scaleInfoDiv = document.getElementById('scaleInfo');
        const imageWidthDisplay = document.getElementById('imageWidthDisplay');
        const imageHeightDisplay = document.getElementById('imageHeightDisplay');
        const calibrationRefDisplay = document.getElementById('calibrationRefDisplay');
        const pixelsPerCalibratedUnitDisplay = document.getElementById('pixelsPerCalibratedUnitDisplay');
        const unitPerPixelDisplay = document.getElementById('unitPerPixelDisplay');
        const toggleRefLineCheckbox = document.getElementById('toggleRefLine');

        let originalImage = new Image();
        let currentImage = null;
        let imageAspectRatio = 1;

        let currentMode = 'idle'; // 'idle', 'scaling', 'measuring', 'drawingArea'
        let isDrawing = false; // For line drawing
        let isDrawingPolygon = false; // For area drawing
        let isDragging = false; // Flag for endpoint dragging (lines or polygon vertices)
        let draggedLineIndex = -2; // -2 for no line, -1 for reference line, >=0 for measurement lines
        let draggedPolygonIndex = -1; // -1 for no polygon, index for polygon
        let draggedPointType = ''; // 'start', 'end', 'vertex'
        let draggedPolygonPointIndex = -1; // Index of the vertex being dragged

        let isDraggingWholeShape = false; // Flag to indicate if an entire line/polygon is being dragged
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        let hoveredLineIndex = -2; // -2 for no hover, -1 for referenceLine, >=0 for measurementLines
        let hoveredPolygonIndex = -1;
        let originalHoveredLineColor = '';
        let originalHoveredLineFontColor = '';
        let originalHoveredPolygonStrokeColor = '';
        let originalHoveredPolygonFillColor = '';
        let originalHoveredPolygonFontColor = '';


        let pendingDeleteIndex = -1;
        let pendingDeleteType = ''; // 'line' or 'area'

        // Modified referenceLine structure to include real-world length and unit, and lock state
        let referenceLine = null; // { start: {x,y}, end: {x,y}, lengthPx, realWorldLength, realWorldUnit, locked, type: 'line', ...lineSettings }
        let measurementLines = [];
        let measurementAreas = []; // array for polygons
        let currentDrawingLine = null;
        let currentPolygonPoints = []; // array for points of polygon being drawn

        let pixelsPerMM = 0;
        let scaleBaseUnit = 'mm';
        let calibrationMethod = 'none';
        let editingLineIndex = -1;
        let editingAreaIndex = -1;
        let showReferenceLine = true;

        // Default settings for regular measurement lines
        const defaultLineSettings = {
            color: '#ff0000',
            fontSize: 16,
            thickness: 2,
            fontColor: '#000000',
            fontWeight: 'normal',
            barLength: 10,
            labelOffsetY: 0,
            rotateLabel: false // Default to horizontal label
        };

        // Default settings for the scale line (can be different from regular lines)
        const defaultScaleLineSettings = {
            color: 'blue',
            fontSize: 16,
            thickness: 2,
            fontColor: 'blue',
            fontWeight: 'normal',
            barLength: 10,
            labelOffsetY: -20, // Offset for better visibility
            rotateLabel: false, // Default to horizontal label for scale
            locked: true // Default to locked
        };

        let currentLineSettings = { ...defaultLineSettings }; // Settings for newly drawn measurement lines

        const unitConversionFactors = {
            'um': 1000,
            'mm': 1,
            'cm': 0.1,
            'm': 0.001,
            'px': 1
        };

        // --- Utility Functions ---

        /**
         * Converts screen coordinates (from mouse/touch) to original image coordinates.
         * This accounts for the image being scaled to fit the canvas.
         * @param {Event} event - Mouse or Touch event.
         * @returns {{x: number, y: number}} Original image coordinates.
         */
        function getCanvasCoordinates(event) {
            const rect = imageCanvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            const xOnScreenCanvas = clientX - rect.left;
            const yOnScreenCanvas = clientY - rect.top;

            // Calculate the scale factor from the canvas's *display size* to its *internal drawing resolution*
            // This is crucial for accurate coordinate mapping when the canvas is scaled by CSS.
            const scaleXInternal = imageCanvas.width / rect.width;
            const scaleYInternal = imageCanvas.height / rect.height;

            const internalCanvasX = xOnScreenCanvas * scaleXInternal;
            const internalCanvasY = yOnScreenCanvas * scaleYInternal;

            if (!originalImage || originalImage.width === 0 || originalImage.height === 0) return { x: 0, y: 0 };

            const imgWidth = originalImage.width;
            const imgHeight = originalImage.height;

            let drawWidth = imageCanvas.width;
            let drawHeight = imageCanvas.height;
            let offsetX = 0;
            let offsetY = 0;

            const canvasAspectRatio = imageCanvas.width / imageCanvas.height;
            const imageAspectRatio = imgWidth / imgHeight;

            if (imageAspectRatio > canvasAspectRatio) {
                drawHeight = imageCanvas.width / imageAspectRatio;
                offsetY = (imageCanvas.height - drawHeight) / 2;
            } else {
                drawWidth = imageCanvas.height * imageAspectRatio;
                offsetX = (imageCanvas.width - drawWidth) / 2;
            }

            const scaleFactor = drawWidth / imgWidth;

            const originalImageX = (internalCanvasX - offsetX) / scaleFactor;
            const originalImageY = (internalCanvasY - offsetY) / scaleFactor;

            return {
                x: originalImageX,
                y: originalImageY
            };
        }

        /**
         * Checks if a point (in original image pixel coordinates) is within the bounds of the drawn image.
         * @param {number} x - X coordinate in original image pixels.
         * @param {number} y - Y coordinate in original image pixels.
         * @returns {boolean} True if the point is within the image bounds, false otherwise.
         */
        function isPointWithinImage(x, y) {
            if (!originalImage || originalImage.width === 0 || originalImage.height === 0) {
                return false;
            }
            return x >= 0 && x <= originalImage.width && y >= 0 && y <= originalImage.height;
        }

        /**
         * Calculates the Euclidean distance between two points.
         * @param {{x: number, y: number}} p1
         * @param {{x: number, y: number}} p2
         * @returns {number} Distance in pixels.
         */
        function calculatePixelLength(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        /**
         * Calculates the area of a polygon using the Shoelace formula.
         * Points are expected in order (clockwise or counter-clockwise).
         * @param {Array<Object>} points - An array of {x, y} objects representing polygon vertices.
         * @returns {number} Area in square pixels.
         */
        function calculatePolygonArea(points) {
            if (points.length < 3) return 0;
            let area = 0;
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length]; // Wrap around to first point
                area += (p1.x * p2.y - p1.y * p2.x);
            }
            return Math.abs(area / 2); // Area is always positive
        }

        /**
         * Converts a pixel length to a specified real-world unit.
         * @param {number} pixels - Length in pixels.
         * @param {string} targetUnit - The unit to convert to ('mm', 'cm', 'm', 'um', 'px').
         * @returns {number} Converted length.
         */
        function convertPixelsToUnit(pixels, targetUnit) {
            if (targetUnit === 'px') {
                return pixels;
            }
            if (pixelsPerMM === 0) {
                return 0;
            }

            // Convert pixels to millimeters first
            const lengthInMM = pixels / pixelsPerMM;

            // Convert millimeters to the target unit
            if (unitConversionFactors[targetUnit]) {
                return lengthInMM * unitConversionFactors[targetUnit];
            }
            console.error('Unknown target unit:', targetUnit);
            return 0;
        }

        /**
         * Converts an area from square pixels to a specified real-world square unit.
         * @param {number} areaInPx2 - Area in square pixels.
         * @param {string} targetUnit - The base unit to convert to ('mm', 'cm', 'm', 'um', 'px').
         * @returns {number} Converted area.
         */
        function convertAreaToUnit(areaInPx2, targetUnit) {
            if (targetUnit === 'px') {
                return areaInPx2;
            }
            if (pixelsPerMM === 0) {
                return 0; // Cannot convert if scale not set
            }
            // Convert pixels^2 to mm^2 first
            const areaInMM2 = areaInPx2 / (pixelsPerMM * pixelsPerMM);

            // Convert mm^2 to target unit^2
            const factor = unitConversionFactors[targetUnit];
            if (factor) {
                return areaInMM2 * (factor * factor);
            }
            console.error('Unknown target unit for area:', targetUnit);
            return 0;
        }

        /**
         * Draws a line with end bars on the canvas.
         * Note: Line coordinates (line.start, line.end) and properties (width, barLength)
         * are assumed to be in original image space. The canvas context is already scaled.
         * @param {object} line - The line object {start: {x,y}, end: {x,y}}.
         * @param {string} color - Line color.
         * @param {number} width - Line width (in original image pixels).
         * @param {number} barLength - Length of the end bars (in original image pixels).
         */
        function drawLine(line, color, width, barLength) {
            if (!line || !line.start || !line.end) return;

            ctx.beginPath();
            ctx.moveTo(line.start.x, line.start.y);
            ctx.lineTo(line.end.x, line.end.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();

            // Draw end bars
            const angle = Math.atan2(line.end.y - line.start.y, line.end.x - line.start.x);
            const currentBarLength = barLength;

            // Start bar
            ctx.beginPath();
            ctx.moveTo(line.start.x - currentBarLength * Math.sin(angle), line.start.y + currentBarLength * Math.cos(angle));
            ctx.lineTo(line.start.x + currentBarLength * Math.sin(angle), line.start.y - currentBarLength * Math.cos(angle));
            ctx.stroke();

            // End bar
            ctx.beginPath();
            ctx.moveTo(line.end.x - currentBarLength * Math.sin(angle), line.end.y + currentBarLength * Math.cos(angle));
            ctx.lineTo(line.end.x + currentBarLength * Math.sin(angle), line.end.y - currentBarLength * Math.cos(angle));
            ctx.stroke();
        }

        /**
         * Draws text (length) near the center of a line, with optional vertical offset and rotation.
         * Note: Text position is in original image space. Font size is given in original image pixels.
         * @param {object} line - The line object.
         * @param {string} text - The text to display.
         * @param {string} fontColor - Text color.
         * @param {number} fontSize - Font size in pixels (in original image pixels).
         * @param {string} fontWeight - Font weight (e.g., 'normal', 'bold').
         * @param {number} labelOffsetY - Vertical offset in pixels (positive for down, negative for up).
         * @param {boolean} rotateLabel - If true, label rotates with the line.
         */
        function drawLineText(line, text, fontColor, fontSize, fontWeight, labelOffsetY = 0, rotateLabel = false) {
            if (!line || !line.start || !line.end) return;

            const midX = (line.start.x + line.end.x) / 2;
            const midY = (line.start.y + line.end.y) / 2;

            ctx.save(); // Save the current context state

            ctx.translate(midX, midY); // Move origin to the center of the line

            if (rotateLabel) {
                const angle = Math.atan2(line.end.y - line.start.y, line.end.x - line.start.x);
                ctx.rotate(angle); // Rotate to align with the line
            }

            ctx.fillStyle = fontColor;
            ctx.font = `${fontWeight} ${fontSize}px Inter`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle'; // Center vertically relative to the new origin

            // Draw text with the vertical offset (now relative to the rotated/translated origin)
            ctx.fillText(text, 0, labelOffsetY);

            ctx.restore(); // Restore context to its previous state
        }

        /**
         * Draws a polygon on the canvas.
         * @param {object} polygon - The polygon object {points: Array<{x,y}>, strokeColor, fillColor, strokeThickness}.
         */
        function drawPolygon(polygon) {
            if (!polygon || polygon.points.length < 2) return;

            ctx.beginPath();
            ctx.moveTo(polygon.points[0].x, polygon.points[0].y);
            for (let i = 1; i < polygon.points.length; i++) {
                ctx.lineTo(polygon.points[i].x, polygon.points[i].y);
            }
            if (polygon.points.length > 2) {
                ctx.closePath(); // Close the path for a complete polygon
            }

            ctx.strokeStyle = polygon.strokeColor;
            ctx.lineWidth = polygon.strokeThickness;
            ctx.fillStyle = polygon.fillColor;

            ctx.fill();
            ctx.stroke();

            // Draw small circles at each vertex for better visibility/interactivity
            polygon.points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2); // Radius in original image pixels
                ctx.fillStyle = polygon.strokeColor;
                ctx.fill();
                ctx.stroke();
            });
        }

        /**
         * Draws text (area) at the centroid of a polygon.
         * @param {object} polygon - The polygon object.
         * @param {string} text - The text to display (e.g., area value).
         * @param {string} fontColor - Text color.
         * @param {number} fontSize - Font size in pixels (in original image pixels).
         * @param {string} fontWeight - Font weight.
         */
        function drawPolygonText(polygon, text, fontColor, fontSize, fontWeight) {
            if (!polygon || polygon.points.length < 3) return;

            // Calculate centroid for text placement
            let centerX = 0;
            let centerY = 0;
            polygon.points.forEach(p => {
                centerX += p.x;
                centerY += p.y;
            });
            centerX /= polygon.points.length;
            centerY /= polygon.points.length;

            ctx.fillStyle = fontColor;
            ctx.font = `${fontWeight} ${fontSize}px Inter`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle'; // Center vertically
            ctx.fillText(text, centerX, centerY);
        }

        /**
         * Checks if a mouse click is near a line's endpoint or a polygon vertex for dragging.
         * @param {object} shape - The line or polygon object.
         * @param {number} mouseX - Mouse X coordinate (in original image pixels).
         * @param {number} mouseY - Mouse Y coordinate (in original image pixels).
         * @param {number} tolerance - Pixel tolerance for proximity (in original image pixels).
         * @returns {string|null} 'start', 'end', 'vertex_N' (where N is index), or null.
         */
        function isNearEndpoint(shape, mouseX, mouseY, tolerance = 10) {
            const effectiveTolerance = tolerance; // Tolerance is already in original image pixels

            if (shape.type === 'line') {
                const distToStart = calculatePixelLength({x: mouseX, y: mouseY}, shape.start);
                const distToEnd = calculatePixelLength({x: mouseX, y: mouseY}, shape.end);

                if (distToStart < effectiveTolerance) {
                    return 'start';
                } else if (distToEnd < effectiveTolerance) {
                    return 'end';
                }
            } else if (shape.type === 'polygon') {
                for (let i = 0; i < shape.points.length; i++) {
                    const point = shape.points[i];
                    const distToVertex = calculatePixelLength({x: mouseX, y: mouseY}, point);
                    if (distToVertex < effectiveTolerance) {
                        return `vertex_${i}`;
                    }
                }
            }
            return null;
        }

        /**
         * Checks if a point (mouseX, mouseY) is near a line segment or inside a polygon.
         * @param {object} shape - The line or polygon object.
         * @param {number} mouseX - Mouse X coordinate (in original image pixels).
         * @param {number} mouseY - Mouse Y coordinate (in original image pixels).
         * @param {number} tolerance - Pixel tolerance for proximity to the line (in original image pixels).
         * @returns {boolean} True if the point is near the line segment or inside the polygon, false otherwise.
         */
        function isNearLineSegmentOrInsidePolygon(shape, mouseX, mouseY, tolerance = 5) {
            const effectiveTolerance = tolerance; // Tolerance is already in original image pixels

            if (shape.type === 'line') {
                const x1 = shape.start.x;
                const y1 = shape.start.y;
                const x2 = shape.end.x;
                const y2 = shape.end.y;

                const L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                if (L2 === 0) {
                    return calculatePixelLength({x: mouseX, y: mouseY}, shape.start) < effectiveTolerance;
                }

                const t = ((mouseX - x1) * (x2 - x1) + (mouseY - y1) * (y2 - y1)) / L2;
                let closestX, closestY;
                if (t < 0) {
                    closestX = x1;
                    closestY = y1;
                } else if (t > 1) {
                    closestX = x2;
                    closestY = y2;
                } else {
                    closestX = x1 + t * (x2 - x1);
                    closestY = y1 + t * (y2 - y1);
                }
                const distance = calculatePixelLength({x: mouseX, y: mouseY}, {x: closestX, y: closestY});
                return distance < effectiveTolerance;
            } else if (shape.type === 'polygon') {
                // Point-in-polygon test for whole polygon drag
                // Using ray-casting algorithm
                let inside = false;
                for (let i = 0, j = shape.points.length - 1; i < shape.points.length; j = i++) {
                    let xi = shape.points[i].x, yi = shape.points[i].y;
                    let xj = shape.points[j].x, yj = shape.points[j].y;

                    let intersect = ((yi > mouseY) != (yj > mouseY)) &&
                                    (mouseX < (xj - xi) * (mouseY - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                // Also check if near any edge for easier grabbing
                for (let i = 0; i < shape.points.length; i++) {
                    const p1 = shape.points[i];
                    const p2 = shape.points[(i + 1) % shape.points.length];
                    // Use a slightly larger tolerance for edge detection for easier grabbing
                    if (isNearLineSegmentOrInsidePolygon({start: p1, end: p2, type: 'line'}, mouseX, mouseY, tolerance * 2)) {
                        return true; // Near an edge
                    }
                }
                return inside; // Inside the polygon
            }
            return false;
        }


        /**
         * Redraws the entire canvas content: image, reference line, and measurement lines/areas.
         */
        function drawCanvas() {
            ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);

            if (currentImage) {
                const imgWidth = originalImage.width;
                const imgHeight = originalImage.height;

                let drawWidth = imageCanvas.width;
                let drawHeight = imageCanvas.height;
                let offsetX = 0;
                let offsetY = 0;

                const canvasAspectRatio = imageCanvas.width / imageCanvas.height;
                const imageAspectRatio = imgWidth / imgHeight;

                if (imageAspectRatio > canvasAspectRatio) {
                    // Image is wider relative to canvas, fit by width
                    drawHeight = imageCanvas.width / imageAspectRatio;
                    offsetY = (imageCanvas.height - drawHeight) / 2;
                } else {
                    // Image is taller relative to canvas, fit by height
                    drawWidth = imageCanvas.height * imageAspectRatio;
                    offsetX = (imageCanvas.width - drawWidth) / 2;
                }

                // Draw the image scaled to fit the canvas
                ctx.drawImage(currentImage, offsetX, offsetY, drawWidth, drawHeight);

                // Now, draw lines and polygons. Their coordinates are in original image space.
                // We need to scale and translate the canvas context to match the drawn image.
                ctx.save(); // Save the context state before applying transformations for drawings

                const scaleFactor = drawWidth / imgWidth;
                ctx.translate(offsetX, offsetY);
                ctx.scale(scaleFactor, scaleFactor);

                // Draw reference line
                if (referenceLine && showReferenceLine) {
                    // For the reference line, display its real-world length if available, otherwise pixel length
                    let refDisplayText;
                    if (referenceLine.realWorldLength && referenceLine.realWorldUnit) {
                        refDisplayText = `Scale: ${referenceLine.realWorldLength.toFixed(2)} ${referenceLine.realWorldUnit}`;
                    } else {
                        refDisplayText = `Scale: ${referenceLine.lengthPx.toFixed(2)} px`;
                    }
                    drawLine(referenceLine, referenceLine.color, referenceLine.thickness, referenceLine.barLength);
                    drawLineText(referenceLine, refDisplayText, referenceLine.fontColor, referenceLine.fontSize, referenceLine.fontWeight, referenceLine.labelOffsetY, referenceLine.rotateLabel);
                }

                // Draw measurement lines
                measurementLines.forEach((line) => {
                    drawLine(line, line.color, line.thickness, line.barLength);
                    drawLineText(line, line.displayLength, line.fontColor, line.fontSize, line.fontWeight, line.labelOffsetY, line.rotateLabel);
                });

                // Draw measurement areas (polygons)
                measurementAreas.forEach((area) => {
                    drawPolygon({
                        points: area.points,
                        strokeColor: area.strokeColor,
                        fillColor: area.fillColor,
                        strokeThickness: area.strokeThickness
                    });
                    drawPolygonText(area, area.displayArea, area.fontColor, area.fontSize, area.fontWeight);
                });

                // Draw the line currently being drawn
                if (isDrawing && currentDrawingLine) {
                    drawLine(currentDrawingLine, 'green', 2, 10);
                }

                // Draw the polygon currently being drawn
                if (isDrawingPolygon && currentPolygonPoints.length > 0) {
                    drawPolygon({
                        points: currentPolygonPoints,
                        strokeColor: 'orange',
                        fillColor: 'rgba(255,165,0,0.3)',
                        strokeThickness: 2
                    });
                    // Draw temporary line from last point to mouse cursor (rubber band effect)
                    if (currentPolygonPoints.length > 0 && currentDrawingLine) {
                        ctx.beginPath();
                        ctx.moveTo(currentPolygonPoints[currentPolygonPoints.length - 1].x, currentPolygonPoints[currentPolygonPoints.length - 1].y);
                        ctx.lineTo(currentDrawingLine.end.x, currentDrawingLine.end.y);
                        ctx.strokeStyle = 'orange';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }

                ctx.restore(); // Restore context to original state (before drawing lines/polygons)
            }
        }

        /**
         * Updates the list of measurements (lines and areas) displayed in the UI.
         */
        function updateMeasurementsList() {
            measurementsList.innerHTML = '';
            const selectedUnit = displayUnitSelect.value;
            let hasMeasurements = false;

            // Add Scale Line to the list if it exists
            if (referenceLine) {
                hasMeasurements = true;
                const listItem = document.createElement('div');
                listItem.className = 'measurement-item';
                // Display real-world length if available, otherwise pixel length
                let displayLength = referenceLine.realWorldLength && referenceLine.realWorldUnit
                    ? `${referenceLine.realWorldLength.toFixed(2)} ${referenceLine.realWorldUnit}`
                    : `${referenceLine.lengthPx.toFixed(2)} px`;

                referenceLine.displayLength = displayLength; // Store for consistent display

                listItem.innerHTML = `
                    <span>Scale Line: ${displayLength}</span>
                    <div class="measurement-item-actions">
                        <button class="settings-btn" data-type="scaleLine" data-index="0" title="Scale Line Settings">
                            <i class="fas fa-cog"></i>
                        </button>
                        <!-- Delete button intentionally omitted for scale line -->
                    </div>
                `;
                measurementsList.appendChild(listItem);
            }

            // Add Measurement Lines to the list
            measurementLines.forEach((line, index) => {
                hasMeasurements = true;
                const lengthPx = calculatePixelLength(line.start, line.end);
                const convertedLength = convertPixelsToUnit(lengthPx, selectedUnit);
                const formattedLength = convertedLength.toFixed(2);

                line.lengthPx = lengthPx;
                line.displayLength = `${formattedLength} ${selectedUnit}`;
                line.unit = selectedUnit;

                const listItem = document.createElement('div');
                listItem.className = 'measurement-item';
                listItem.innerHTML = `
                    <span class="mes-item"><span class="sl-no">L${index + 1}</span> ${line.displayLength}</span>
                    <div class="measurement-item-actions">
                        <button class="settings-btn" data-type="line" data-index="${index}" title="Line Settings">
                            <i class="fas fa-cog"></i>
                        </button>
                        <button class="delete-btn" data-type="line" data-index="${index}" title="Delete Line">
                            <i class="fas fa-trash-alt"></i>
                        </button>
                    </div>
                `;
                measurementsList.appendChild(listItem);
            });

            // Add Areas to the list
            measurementAreas.forEach((area, index) => {
                hasMeasurements = true;
                const areaPx2 = calculatePolygonArea(area.points);
                const convertedArea = convertAreaToUnit(areaPx2, selectedUnit);
                const formattedArea = convertedArea.toFixed(2);
                const unitSymbol = selectedUnit === 'px' ? 'px²' : `${selectedUnit}²`;

                area.areaPx2 = areaPx2;
                area.displayArea = `${formattedArea} ${unitSymbol}`;
                area.unit = selectedUnit;

                const listItem = document.createElement('div');
                listItem.className = 'measurement-item';
                listItem.innerHTML = `
                    <span class="mes-item"><span class="sl-no">A${index + 1}</span> ${area.displayArea}</span>
                    <div class="measurement-item-actions">
                        <button class="settings-btn" data-type="area" data-index="${index}" title="Area Settings">
                            <i class="fas fa-cog"></i>
                        </button>
                        <button class="delete-btn" data-type="area" data-index="${index}" title="Delete Area">
                            <i class="fas fa-trash-alt"></i>
                        </button>
                    </div>
                `;
                measurementsList.appendChild(listItem);
            });

            if (!hasMeasurements) {
                measurementsList.innerHTML = '<p class="text-gray-500 text-sm italic">No measurements yet.</p>';
            }

            addMeasurementListEventListeners();
            drawCanvas(); // Always redraw the canvas after updating the list
        }

        /**
         * Updates the scale information displayed in the control panel.
         */
        function updateScaleInfoDisplay() {
            if (pixelsPerMM > 0) {
                if (calibrationMethod === 'line' && referenceLine) {
                    calibrationRefDisplay.textContent = `Reference: ${referenceLine.realWorldLength.toFixed(2)} ${referenceLine.realWorldUnit} (drawn line)`;
                } else if (calibrationMethod === 'pixel') {
                    calibrationRefDisplay.textContent = `Reference: 1 Image Pixel = ${parseFloat(pixelLengthInput.value).toFixed(4)} ${pixelUnitSelect.value}`;
                }

                pixelsPerCalibratedUnitDisplay.textContent = `Pixels per ${scaleBaseUnit}: ${pixelsPerMM.toFixed(4)}`;

                let unitPerPixel = (1 / pixelsPerMM);
                let unitForDisplay = scaleBaseUnit;

                unitPerPixelDisplay.textContent = `1 Image Pixel = ${unitPerPixel.toFixed(4)} ${unitForDisplay}`;

                scaleInfoDiv.style.display = 'block';
                toggleRefLineCheckbox.disabled = false;
            } else {
                calibrationRefDisplay.textContent = 'Reference: Not set';
                pixelsPerCalibratedUnitDisplay.textContent = 'Pixels per Unit: Not set';
                unitPerPixelDisplay.textContent = '1 Image Pixel = Not set';
                scaleInfoDiv.style.display = 'none';
                toggleRefLineCheckbox.disabled = true;
            }
        }

        /**
         * Adds event listeners to the settings and delete buttons in the measurement list.
         */
        function addMeasurementListEventListeners() {
            document.querySelectorAll('.settings-btn').forEach(button => {
                button.onclick = (e) => {
                    const index = parseInt(e.currentTarget.dataset.index);
                    const type = e.currentTarget.dataset.type;
                    if (type === 'line') {
                        openLineSettingsModal(index);
                    } else if (type === 'area') {
                        openAreaSettingsModal(index);
                    } else if (type === 'scaleLine') {
                        openScaleLineSettingsModal();
                    }
                };
            });
            document.querySelectorAll('.delete-btn').forEach(button => {
                button.onclick = (e) => {
                    const index = parseInt(e.currentTarget.dataset.index);
                    const type = e.currentTarget.dataset.type;
                    deleteShape(index, type);
                };
            });
        }

        /**
         * Shows a generic message modal.
         * @param {string} message - The message to display.
         */
        function showMessageModal(message) {
            messageText.textContent = message;
            messageModal.style.display = 'flex';
        }

        /**
         * Hides the generic message modal.
         */
        function hideMessageModal() {
            messageModal.style.display = 'none';
        }

        // --- Event Handlers ---

        /**
         * Handles image file selection.
         */
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    originalImage.onload = () => {
                        currentImage = originalImage;
                        imageAspectRatio = originalImage.width / originalImage.height;

                        // Set canvas dimensions to ORIGINAL IMAGE DIMENSIONS
                        imageCanvas.width = originalImage.width;
                        imageCanvas.height = originalImage.height;

                        canvasPlaceholder.classList.add('hidden');
                        setScaleBtn.disabled = false;
                        setPixelScaleBtn.disabled = false;
                        drawLineBtn.disabled = true;
                        drawAreaBtn.disabled = true;
                        clearAllBtn.disabled = false;
                        saveImageBtn.disabled = false;
                        displayUnitSelect.disabled = false;
                        toggleRefLineCheckbox.disabled = true;
                        addLineByValueBtn.disabled = true;

                        imageWidthDisplay.textContent = `Image Width: ${originalImage.width} px`;
                        imageHeightDisplay.textContent = `Image Height: ${originalImage.height} px`;

                        currentMode = 'idle';
                        isDrawing = false;
                        isDrawingPolygon = false;
                        isDragging = false;
                        isDraggingWholeShape = false;
                        hoveredLineIndex = -2;
                        hoveredPolygonIndex = -1;
                        referenceLine = null;
                        measurementLines = [];
                        measurementAreas = [];
                        currentPolygonPoints = [];
                        pixelsPerMM = 0;
                        calibrationMethod = 'none';
                        updateMeasurementsList();
                        updateScaleInfoDisplay();

                        resizeCanvasContainer(); // Call to adjust CSS display size
                    };
                    originalImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                currentImage = null;
                imageCanvas.width = 0;
                imageCanvas.height = 0;
                canvasPlaceholder.classList.remove('hidden');
                setScaleBtn.disabled = true;
                setPixelScaleBtn.disabled = true;
                drawLineBtn.disabled = true;
                drawAreaBtn.disabled = true;
                clearAllBtn.disabled = true;
                saveImageBtn.disabled = true;
                displayUnitSelect.disabled = true;
                toggleRefLineCheckbox.disabled = true;
                addLineByValueBtn.disabled = true;

                imageWidthDisplay.textContent = 'Image Width: Not set';
                imageHeightDisplay.textContent = 'Image Height: Not set';

                measurementsList.innerHTML = '<p class="text-gray-500 text-sm italic">No measurements yet.</p>';
                updateScaleInfoDisplay();

                drawCanvas();
            }
        });

        /**
         * Activates scaling mode (draw line).
         */
        setScaleBtn.addEventListener('click', () => {
            if (!currentImage) return;
            currentMode = 'scaling';
            referenceLine = null;
            measurementLines = [];
            measurementAreas = [];
            pixelsPerMM = 0;
            calibrationMethod = 'line';
            updateMeasurementsList();
            updateScaleInfoDisplay();
            drawCanvas();
            setScaleBtn.classList.remove('btn-primary');
            setScaleBtn.classList.add('btn-secondary');
            setPixelScaleBtn.classList.add('btn-primary');
            setPixelScaleBtn.classList.remove('btn-secondary');
            drawLineBtn.classList.add('btn-primary');
            drawLineBtn.classList.remove('btn-secondary');
            drawAreaBtn.classList.add('btn-primary');
            drawAreaBtn.classList.remove('btn-secondary');
            addLineByValueBtn.classList.add('btn-primary');
            addLineByValueBtn.classList.remove('btn-secondary');
            console.log('Mode: Scaling (Draw Line) - Draw your reference line.');
        });

        /**
         * Activates pixel scale input mode.
         */
        setPixelScaleBtn.addEventListener('click', () => {
            if (!currentImage) return;
            currentMode = 'idle';
            referenceLine = null;
            measurementLines = [];
            measurementAreas = [];
            pixelsPerMM = 0;
            calibrationMethod = 'pixel';
            updateMeasurementsList();
            updateScaleInfoDisplay();
            drawCanvas();
            showPixelScaleModal();
            setPixelScaleBtn.classList.remove('btn-primary');
            setPixelScaleBtn.classList.add('btn-secondary');
            setScaleBtn.classList.add('btn-primary');
            setScaleBtn.classList.remove('btn-secondary');
            drawLineBtn.classList.add('btn-primary');
            drawLineBtn.classList.remove('btn-secondary');
            drawAreaBtn.classList.add('btn-primary');
            drawAreaBtn.classList.remove('btn-secondary');
            addLineByValueBtn.classList.add('btn-primary');
            addLineByValueBtn.classList.remove('btn-secondary');
            console.log('Mode: Setting Pixel Scale.');
        });

        /**
         * Activates measuring mode (draw line).
         */
        drawLineBtn.addEventListener('click', () => {
            if (!currentImage || pixelsPerMM === 0) {
                showMessageModal('Please set the scale first using either "Set Scale (Draw Line)" or "Set Scale (1 Pixel)".');
                return;
            }
            currentMode = 'measuring';
            isDrawingPolygon = false;
            currentPolygonPoints = [];
            setScaleBtn.classList.add('btn-primary');
            setScaleBtn.classList.remove('btn-secondary');
            setPixelScaleBtn.classList.add('btn-primary');
            setPixelScaleBtn.classList.remove('btn-secondary');
            drawLineBtn.classList.remove('btn-primary');
            drawLineBtn.classList.add('btn-secondary');
            drawAreaBtn.classList.add('btn-primary');
            drawAreaBtn.classList.remove('btn-secondary');
            addLineByValueBtn.classList.add('btn-primary');
            addLineByValueBtn.classList.remove('btn-secondary');
            drawCanvas();
            console.log('Mode: Measuring - Draw your measurement lines.');
        });

        /**
         * Activates drawing area mode (polygon).
         */
        drawAreaBtn.addEventListener('click', () => {
            if (!currentImage || pixelsPerMM === 0) {
                showMessageModal('Please set the scale first using either "Set Scale (Draw Line)" or "Set Scale (1 Pixel)".');
                return;
            }
            currentMode = 'drawingArea';
            isDrawing = false;
            currentDrawingLine = null;
            isDrawingPolygon = true;
            currentPolygonPoints = [];
            setScaleBtn.classList.add('btn-primary');
            setScaleBtn.classList.remove('btn-secondary');
            setPixelScaleBtn.classList.add('btn-primary');
            setPixelScaleBtn.classList.remove('btn-secondary');
            drawLineBtn.classList.add('btn-primary');
            drawLineBtn.classList.remove('btn-secondary');
            drawAreaBtn.classList.remove('btn-primary');
            drawAreaBtn.classList.add('btn-secondary');
            addLineByValueBtn.classList.add('btn-primary');
            addLineByValueBtn.classList.remove('btn-secondary');
            drawCanvas();
            console.log('Mode: Drawing Area - Click to add points, click near first point to complete.');
        });

        /**
         * Clears all lines and resets the scale.
         */
        clearAllBtn.addEventListener('click', () => {
            referenceLine = null;
            measurementLines = [];
            measurementAreas = [];
            currentPolygonPoints = [];
            isDrawingPolygon = false;
            pixelsPerMM = 0;
            calibrationMethod = 'none';
            currentMode = 'idle';
            isDrawing = false;
            isDragging = false;
            isDraggingWholeShape = false;
            hoveredLineIndex = -2;
            hoveredPolygonIndex = -1;
            updateMeasurementsList();
            updateScaleInfoDisplay();
            drawCanvas();
            setScaleBtn.classList.add('btn-primary');
            setScaleBtn.classList.remove('btn-secondary');
            setPixelScaleBtn.classList.add('btn-primary');
            setPixelScaleBtn.classList.remove('btn-secondary');
            drawLineBtn.classList.add('btn-primary');
            drawLineBtn.classList.remove('btn-secondary');
            drawAreaBtn.classList.add('btn-primary');
            drawAreaBtn.classList.remove('btn-secondary');
            addLineByValueBtn.classList.add('btn-primary');
            addLineByValueBtn.classList.remove('btn-secondary');

            drawLineBtn.disabled = true;
            drawAreaBtn.disabled = true;
            addLineByValueBtn.disabled = true;
            toggleRefLineCheckbox.disabled = true;
            toggleRefLineCheckbox.checked = true;
            showReferenceLine = true;

            imageWidthDisplay.textContent = 'Image Width: Not set';
            imageHeightDisplay.textContent = 'Image Height: Not set';

            currentLineSettings = { ...defaultLineSettings }; // Reset currentLineSettings to default

            console.log('All lines, areas, and scale cleared.');
        });

        /**
         * Saves the current canvas content as a PNG image.
         */
        saveImageBtn.addEventListener('click', () => {
            if (!currentImage) {
                showMessageModal('No image to save. Please upload an image first.');
                return;
            }
            // The canvas width/height are already set to originalImage.width/height
            // so toDataURL will capture the full resolution.
            const dataURL = imageCanvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'measured_image.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        /**
         * Updates displayed lengths and areas when display unit changes.
         */
        displayUnitSelect.addEventListener('change', () => {
            updateMeasurementsList();
            if (pixelsPerMM > 0) {
                updateScaleInfoDisplay();
            }
        });

        toggleRefLineCheckbox.addEventListener('change', () => {
            showReferenceLine = toggleRefLineCheckbox.checked;
            drawCanvas();
        });

        // --- Mouse/Touch Event Handlers ---

        function handleMouseDown(e) {
            if (!currentImage) return;

            const { x, y } = getCanvasCoordinates(e);

            // Check if the click is within the image bounds before proceeding
            if (!isPointWithinImage(x, y)) {
                console.log('Click outside image bounds. Ignoring.');
                return;
            }

            if (currentMode === 'scaling') {
                isDrawing = true;
                // Apply defaultScaleLineSettings for the reference line
                currentDrawingLine = {
                    start: { x, y },
                    end: { x, y },
                    type: 'line',
                    ...defaultScaleLineSettings // Apply default appearance for scale line
                };
            } else if (currentMode === 'measuring') {
                // Check for dragging existing line endpoints
                // Check reference line first
                if (referenceLine) {
                    const pointType = isNearEndpoint(referenceLine, x, y, 10);
                    if (pointType) {
                        if (referenceLine.locked) {
                            showMessageModal('The scale line is locked and cannot be dragged. Uncheck "Lock Scale Line" in its settings to adjust.');
                            return;
                        }
                        isDragging = true;
                        draggedLineIndex = -1; // Indicate reference line
                        draggedPointType = pointType;
                        isDrawing = false;
                        currentDrawingLine = null;
                        return;
                    }
                }
                // Then check other measurement lines
                for (let i = 0; i < measurementLines.length; i++) {
                    const line = measurementLines[i];
                    const pointType = isNearEndpoint(line, x, y, 10);
                    if (pointType) {
                        isDragging = true;
                        draggedLineIndex = i;
                        draggedPointType = pointType;
                        isDrawing = false;
                        currentDrawingLine = null;
                        return;
                    }
                }
                // Check for dragging entire lines
                // Check reference line first
                if (referenceLine) {
                    if (isNearLineSegmentOrInsidePolygon(referenceLine, x, y, 5)) {
                        if (referenceLine.locked) {
                            showMessageModal('The scale line is locked and cannot be dragged. Uncheck "Lock Scale Line" in its settings to adjust.');
                            return;
                        }
                        isDraggingWholeShape = true;
                        draggedLineIndex = -1; // Indicate reference line
                        dragOffsetX = x - referenceLine.start.x;
                        dragOffsetY = y - referenceLine.start.y;
                        isDrawing = false;
                        currentDrawingLine = null;
                        return;
                    }
                }
                // Then check other measurement lines
                for (let i = 0; i < measurementLines.length; i++) {
                    const line = measurementLines[i];
                    if (isNearLineSegmentOrInsidePolygon(line, x, y, 5)) {
                        isDraggingWholeShape = true;
                        draggedLineIndex = i;
                        dragOffsetX = x - line.start.x;
                        dragOffsetY = y - line.start.y;
                        isDrawing = false;
                        currentDrawingLine = null;
                        return;
                    }
                }
                // If not dragging existing, start drawing a new line
                isDrawing = true;
                currentDrawingLine = { start: { x, y }, end: { x, y }, type: 'line' };
            } else if (currentMode === 'drawingArea') {
                // Check for dragging existing polygon vertices
                for (let i = 0; i < measurementAreas.length; i++) {
                    const polygon = measurementAreas[i];
                    const pointType = isNearEndpoint(polygon, x, y, 10);
                    if (pointType && pointType.startsWith('vertex_')) {
                        isDragging = true;
                        draggedPolygonIndex = i;
                        draggedPolygonPointIndex = parseInt(pointType.split('_')[1]);
                        draggedPointType = 'vertex';
                        isDrawingPolygon = false;
                        currentPolygonPoints = [];
                        return;
                    }
                }
                // Check for dragging entire polygons
                for (let i = 0; i < measurementAreas.length; i++) {
                    const polygon = measurementAreas[i];
                    if (isNearLineSegmentOrInsidePolygon(polygon, x, y, 5)) {
                        isDraggingWholeShape = true;
                        draggedPolygonIndex = i;
                        dragOffsetX = x - polygon.points[0].x;
                        dragOffsetY = y - polygon.points[0].y;
                        isDrawingPolygon = false;
                        currentPolygonPoints = [];
                        return;
                    }
                }

                // If not dragging existing, start/continue drawing a new polygon
                if (!isDrawingPolygon) {
                    isDrawingPolygon = true;
                    currentPolygonPoints = [{ x, y }];
                } else {
                    if (currentPolygonPoints.length > 0 && calculatePixelLength({ x, y }, currentPolygonPoints[0]) < 15) {
                        completePolygon();
                    } else {
                        currentPolygonPoints.push({ x, y });
                    }
                }
                drawCanvas();
            }
        }

        function handleMouseMove(e) {
            if (!currentImage) return;

            const { x, y } = getCanvasCoordinates(e);

            if (isDrawing && currentDrawingLine) {
                currentDrawingLine.end = { x, y };
                drawCanvas();
            } else if (isDrawingPolygon && currentPolygonPoints.length > 0) {
                currentDrawingLine = { start: currentPolygonPoints[currentPolygonPoints.length - 1], end: { x, y } };
                drawCanvas();
            } else if (isDragging && draggedLineIndex === -1 && referenceLine) { // Dragging reference line endpoint
                if (referenceLine.locked) return;
                if (draggedPointType === 'start') {
                    referenceLine.start = { x, y };
                } else {
                    referenceLine.end = { x, y };
                }
                referenceLine.lengthPx = calculatePixelLength(referenceLine.start, referenceLine.end);
                let realWorldLengthInMM = 0; // Declare and initialize
                if (referenceLine.realWorldLength && referenceLine.realWorldUnit) {
                    realWorldLengthInMM = convertUnitToMM(referenceLine.realWorldLength, referenceLine.realWorldUnit);
                    if (realWorldLengthInMM > 0) {
                        pixelsPerMM = referenceLine.lengthPx / realWorldLengthInMM;
                        scaleBaseUnit = referenceLine.realWorldUnit;
                    }
                }
                updateMeasurementsList();
                updateScaleInfoDisplay();
                drawCanvas();
            } else if (isDragging && draggedLineIndex !== -2 && draggedLineIndex !== -1) { // Dragging other line endpoint
                const line = measurementLines[draggedLineIndex];
                if (draggedPointType === 'start') {
                    line.start = { x, y };
                } else {
                    line.end = { x, y };
                }
                updateMeasurementsList();
                drawCanvas();
            } else if (isDragging && draggedPolygonIndex !== -1 && draggedPointType === 'vertex') {
                const polygon = measurementAreas[draggedPolygonIndex];
                polygon.points[draggedPolygonPointIndex] = { x, y };
                updateMeasurementsList();
                drawCanvas();
            } else if (isDraggingWholeShape && draggedLineIndex === -1 && referenceLine) { // Dragging whole reference line
                if (referenceLine.locked) return;
                const newStartX = x - dragOffsetX;
                const newStartY = y - dragOffsetY;
                const deltaX = newStartX - referenceLine.start.x;
                const deltaY = newStartY - referenceLine.start.y;

                referenceLine.start.x += deltaX;
                referenceLine.start.y += deltaY;
                referenceLine.end.x += deltaX;
                referenceLine.end.y += deltaY;

                referenceLine.lengthPx = calculatePixelLength(referenceLine.start, referenceLine.end);
                let realWorldLengthInMM = 0; // Declare and initialize
                if (referenceLine.realWorldLength && referenceLine.realWorldUnit) {
                    realWorldLengthInMM = convertUnitToMM(referenceLine.realWorldLength, referenceLine.realWorldUnit);
                    if (realWorldLengthInMM > 0) {
                        pixelsPerMM = referenceLine.lengthPx / realWorldLengthInMM;
                        scaleBaseUnit = referenceLine.realWorldUnit;
                    }
                }
                updateMeasurementsList();
                updateScaleInfoDisplay();
                drawCanvas();
            } else if (isDraggingWholeShape && draggedLineIndex !== -2 && draggedLineIndex !== -1) { // Dragging whole other line
                const line = measurementLines[draggedLineIndex];
                const newStartX = x - dragOffsetX;
                const newStartY = y - dragOffsetY;
                const deltaX = newStartX - line.start.x;
                const deltaY = newStartY - line.start.y;

                line.start.x += deltaX;
                line.start.y += deltaY;
                line.end.x += deltaX;
                line.end.y += deltaY;

                updateMeasurementsList();
                drawCanvas();
            } else if (isDraggingWholeShape && draggedPolygonIndex !== -1) {
                const polygon = measurementAreas[draggedPolygonIndex];
                const newFirstPointX = x - dragOffsetX;
                const newFirstPointY = y - dragOffsetY;

                const deltaX = newFirstPointX - polygon.points[0].x;
                const deltaY = newFirstPointY - polygon.points[0].y;

                polygon.points.forEach(p => {
                    p.x += deltaX;
                    p.y += deltaY;
                });

                updateMeasurementsList();
                drawCanvas();
            } else {
                updateHoverState(x, y);
            }
        }

        function handleMouseUp(e) {
            if (!currentImage) return;

            if (isDrawing) {
                isDrawing = false;
                if (currentDrawingLine) {
                    currentDrawingLine.lengthPx = calculatePixelLength(currentDrawingLine.start, currentDrawingLine.end);
                    if (currentMode === 'scaling') {
                        // When scale line is drawn, apply defaultScaleLineSettings and prepare for modal input
                        referenceLine = {
                            ...currentDrawingLine,
                            ...defaultScaleLineSettings, // Apply default appearance for scale line
                            realWorldLength: 0, // Will be set by modal
                            realWorldUnit: 'mm' // Will be set by modal
                        };
                        showScaleModal();
                    } else if (currentMode === 'measuring') {
                        measurementLines.push({
                            ...currentDrawingLine,
                            ...currentLineSettings, // Apply current settings for new line
                            type: 'line'
                        });
                        updateMeasurementsList();
                    }
                }
                currentDrawingLine = null;
            } else if (isDragging || isDraggingWholeShape) {
                // Revert color of the dragged line/polygon to its original state
                if (draggedLineIndex === -1 && referenceLine) { // Reference line
                    referenceLine.color = originalHoveredLineColor;
                    referenceLine.fontColor = originalHoveredLineFontColor;
                } else if (draggedLineIndex !== -2 && draggedLineIndex !== -1) { // Other line
                    measurementLines[draggedLineIndex].color = originalHoveredLineColor;
                    measurementLines[draggedLineIndex].fontColor = originalHoveredLineFontColor;
                }
                if (draggedPolygonIndex !== -1) {
                    measurementAreas[draggedPolygonIndex].strokeColor = originalHoveredPolygonStrokeColor;
                    measurementAreas[draggedPolygonIndex].fillColor = originalHoveredPolygonFillColor;
                    measurementAreas[draggedPolygonIndex].fontColor = originalHoveredPolygonFontColor;
                }
                isDragging = false;
                isDraggingWholeShape = false;
                draggedLineIndex = -2;
                draggedPolygonIndex = -1;
                draggedPointType = '';
                draggedPolygonPointIndex = -1;
                dragOffsetX = 0;
                dragOffsetY = 0;

                const { x, y } = getCanvasCoordinates(e);
                updateHoverState(x, y);
                drawCanvas();
            }
        }

        function handleMouseOut() {
            if (isDrawing) {
                isDrawing = false;
                currentDrawingLine = null;
                drawCanvas();
            }
            if (isDrawingPolygon && currentPolygonPoints.length > 0) {
                currentDrawingLine = null;
                drawCanvas();
            }
            if (isDragging || isDraggingWholeShape) {
                if (draggedLineIndex === -1 && referenceLine) { // Reference line
                    referenceLine.color = originalHoveredLineColor;
                    referenceLine.fontColor = originalHoveredLineFontColor;
                } else if (draggedLineIndex !== -2 && draggedLineIndex !== -1) { // Other line
                    measurementLines[draggedLineIndex].color = originalHoveredLineColor;
                    measurementLines[draggedLineIndex].fontColor = originalHoveredLineFontColor;
                }
                if (draggedPolygonIndex !== -1) {
                    measurementAreas[draggedPolygonIndex].strokeColor = originalHoveredPolygonStrokeColor;
                    measurementAreas[draggedPolygonIndex].fillColor = originalHoveredPolygonFillColor;
                    measurementAreas[draggedPolygonIndex].fontColor = originalHoveredPolygonFontColor;
                }
                isDragging = false;
                isDraggingWholeShape = false;
                draggedLineIndex = -2;
                draggedPolygonIndex = -1;
                draggedPointType = '';
                draggedPolygonPointIndex = -1;
                dragOffsetX = 0;
                dragOffsetY = 0;
            }

            if (hoveredLineIndex === -1 && referenceLine) { // If reference line was hovered
                referenceLine.color = originalHoveredLineColor;
                referenceLine.fontColor = originalHoveredLineFontColor;
                drawCanvas();
            } else if (hoveredLineIndex !== -2 && hoveredLineIndex !== -1) { // If another line was hovered
                measurementLines[hoveredLineIndex].color = originalHoveredLineColor;
                measurementLines[hoveredLineIndex].fontColor = originalHoveredLineFontColor;
                drawCanvas();
            }
            if (hoveredPolygonIndex !== -1) {
                measurementAreas[hoveredPolygonIndex].strokeColor = originalHoveredPolygonStrokeColor;
                measurementAreas[hoveredPolygonIndex].fillColor = originalHoveredPolygonFillColor;
                measurementAreas[hoveredPolygonIndex].fontColor = originalHoveredPolygonFontColor;
                drawCanvas();
            }
            hoveredLineIndex = -2;
            hoveredPolygonIndex = -1;
            originalHoveredLineColor = '';
            originalHoveredLineFontColor = '';
            originalHoveredPolygonStrokeColor = '';
            originalHoveredPolygonFillColor = '';
            originalHoveredPolygonFontColor = '';
            imageCanvas.style.cursor = 'default';
        }

        // --- Attach Mouse Events ---
        imageCanvas.addEventListener('mousedown', handleMouseDown);
        imageCanvas.addEventListener('mousemove', handleMouseMove);
        imageCanvas.addEventListener('mouseup', handleMouseUp);
        imageCanvas.addEventListener('mouseout', handleMouseOut);

        // --- Attach Touch Events ---
        imageCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMouseDown(e);
        });

        imageCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            handleMouseMove(e);
        });

        imageCanvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleMouseUp(e);
        });

        imageCanvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            handleMouseOut();
        });


        /**
         * Updates the hover state and cursor based on mouse position.
         * @param {number} mouseX - Current mouse X coordinate on canvas (in original image pixels).
         * @param {number} mouseY - Current mouse Y coordinate on canvas (in original image pixels).
         */
        function updateHoverState(mouseX, mouseY) {
            if (isDrawing || isDrawingPolygon || isDragging || isDraggingWholeShape) {
                return;
            }

            let newHoveredLineIndex = -2; // -2 for no hover, -1 for referenceLine, >=0 for measurementLines
            let newHoveredPolygonIndex = -1;
            let newCursorStyle = 'default';

            // Check reference line first for endpoint hover
            if (referenceLine && isNearEndpoint(referenceLine, mouseX, mouseY, 10)) {
                newHoveredLineIndex = -1;
                newCursorStyle = 'pointer';
            } else {
                // Prioritize endpoint/vertex hover for other lines
                for (let i = 0; i < measurementLines.length; i++) {
                    if (isNearEndpoint(measurementLines[i], mouseX, mouseY, 10)) {
                        newHoveredLineIndex = i;
                        newCursorStyle = 'pointer';
                        break;
                    }
                }
            }

            if (newHoveredLineIndex === -2) { // Only check polygons if no line endpoint is hovered
                for (let i = 0; i < measurementAreas.length; i++) {
                    if (isNearEndpoint(measurementAreas[i], mouseX, mouseY, 10)) {
                        newHoveredPolygonIndex = i;
                        newCursorStyle = 'pointer';
                        break;
                    }
                }
            }

            // If no endpoint/vertex hovered, check whole shape hover
            if (newHoveredLineIndex === -2 && newHoveredPolygonIndex === -1) {
                // Check reference line first for whole shape hover
                if (referenceLine && isNearLineSegmentOrInsidePolygon(referenceLine, mouseX, mouseY, 5)) {
                    newHoveredLineIndex = -1;
                    newCursorStyle = 'grab';
                } else {
                    for (let i = 0; i < measurementLines.length; i++) {
                        if (isNearLineSegmentOrInsidePolygon(measurementLines[i], mouseX, mouseY, 5)) {
                            newHoveredLineIndex = i;
                            newCursorStyle = 'grab';
                            break;
                        }
                    }
                }

                if (newHoveredLineIndex === -2) {
                    for (let i = 0; i < measurementAreas.length; i++) {
                        if (isNearLineSegmentOrInsidePolygon(measurementAreas[i], mouseX, mouseY, 5)) {
                            newHoveredPolygonIndex = i;
                            newCursorStyle = 'grab';
                            break;
                        }
                    }
                }
            }

            // Apply/revert hover effects for reference line
            if (newHoveredLineIndex === -1 && hoveredLineIndex !== -1) { // Was hovering other line, now reference
                if (hoveredLineIndex !== -2) { // Ensure it was a valid line index
                    measurementLines[hoveredLineIndex].color = originalHoveredLineColor;
                    measurementLines[hoveredLineIndex].fontColor = originalHoveredLineFontColor;
                }
                originalHoveredLineColor = referenceLine.color;
                originalHoveredLineFontColor = referenceLine.fontColor;
                referenceLine.color = 'yellow';
                referenceLine.fontColor = 'yellow';
                hoveredLineIndex = -1;
                drawCanvas();
            } else if (newHoveredLineIndex !== -2 && newHoveredLineIndex !== -1 && hoveredLineIndex === -1) { // Was hovering reference, now other line
                referenceLine.color = originalHoveredLineColor;
                referenceLine.fontColor = originalHoveredLineFontColor;
                originalHoveredLineColor = measurementLines[newHoveredLineIndex].color;
                originalHoveredLineFontColor = measurementLines[newHoveredLineIndex].fontColor;
                measurementLines[newHoveredLineIndex].color = 'yellow';
                measurementLines[newHoveredLineIndex].fontColor = 'yellow';
                hoveredLineIndex = newHoveredLineIndex;
                drawCanvas();
            } else if (newHoveredLineIndex === -1 && hoveredLineIndex === -2) { // Now hovering reference, was hovering nothing
                 if (referenceLine) {
                    originalHoveredLineColor = referenceLine.color;
                    originalHoveredLineFontColor = referenceLine.fontColor;
                    referenceLine.color = 'yellow';
                    referenceLine.fontColor = 'yellow';
                    hoveredLineIndex = -1;
                    drawCanvas();
                 }
            } else if (newHoveredLineIndex === -2 && hoveredLineIndex === -1) { // Now hovering nothing, was hovering reference
                if (referenceLine) {
                    referenceLine.color = originalHoveredLineColor;
                    referenceLine.fontColor = originalHoveredLineFontColor;
                    hoveredLineIndex = -2;
                    drawCanvas();
                }
            } else if (newHoveredLineIndex !== hoveredLineIndex && newHoveredLineIndex !== -2 && newHoveredLineIndex !== -1 && hoveredLineIndex !== -2 && hoveredLineIndex !== -1) { // Switching between other lines
                if (hoveredLineIndex !== -2) {
                    measurementLines[hoveredLineIndex].color = originalHoveredLineColor;
                    measurementLines[hoveredLineIndex].fontColor = originalHoveredLineFontColor;
                }
                originalHoveredLineColor = measurementLines[newHoveredLineIndex].color;
                originalHoveredLineFontColor = measurementLines[newHoveredLineIndex].fontColor;
                measurementLines[newHoveredLineIndex].color = 'yellow';
                measurementLines[newHoveredLineIndex].fontColor = 'yellow';
                hoveredLineIndex = newHoveredLineIndex;
                drawCanvas();
            } else if (newHoveredLineIndex === -2 && hoveredLineIndex !== -2) { // Was hovering a line, now hovering nothing
                if (hoveredLineIndex === -1 && referenceLine) {
                    referenceLine.color = originalHoveredLineColor;
                    referenceLine.fontColor = originalHoveredLineFontColor;
                } else if (hoveredLineIndex !== -2) {
                    measurementLines[hoveredLineIndex].color = originalHoveredLineColor;
                    measurementLines[hoveredLineIndex].fontColor = originalHoveredLineFontColor;
                }
                hoveredLineIndex = -2;
                drawCanvas();
            }


            // Apply/revert hover effects for polygons
            if (newHoveredPolygonIndex !== hoveredPolygonIndex) {
                if (hoveredPolygonIndex !== -1) {
                    measurementAreas[hoveredPolygonIndex].strokeColor = originalHoveredPolygonStrokeColor;
                    measurementAreas[hoveredPolygonIndex].fillColor = originalHoveredPolygonFillColor;
                    measurementAreas[hoveredPolygonIndex].fontColor = originalHoveredPolygonFontColor;
                }
                if (newHoveredPolygonIndex !== -1) {
                    originalHoveredPolygonStrokeColor = measurementAreas[newHoveredPolygonIndex].strokeColor;
                    originalHoveredPolygonFillColor = measurementAreas[newHoveredPolygonIndex].fillColor;
                    originalHoveredPolygonFontColor = measurementAreas[newHoveredPolygonIndex].fontColor;
                    measurementAreas[newHoveredPolygonIndex].strokeColor = 'yellow';
                    measurementAreas[newHoveredPolygonIndex].fillColor = 'rgba(255,255,0,0.4)';
                    measurementAreas[newHoveredPolygonIndex].fontColor = 'yellow';
                }
                hoveredPolygonIndex = newHoveredPolygonIndex;
                drawCanvas();
            }

            imageCanvas.style.cursor = newCursorStyle;
        }


        /**
         * Completes the current polygon being drawn.
         */
        function completePolygon() {
            if (currentPolygonPoints.length >= 3) {
                const newPolygon = {
                    points: [...currentPolygonPoints],
                    strokeColor: '#0000ff',
                    fillColor: 'rgba(0,0,255,0.3)',
                    strokeThickness: 2,
                    fontSize: 16,
                    fontColor: '#ffffff',
                    fontWeight: 'bold',
                    type: 'polygon'
                };
                measurementAreas.push(newPolygon);
                updateMeasurementsList();
                console.log('Polygon completed and added to measurements.');
            } else {
                showMessageModal('A polygon requires at least 3 points to be completed. Drawing cancelled.');
            }
            isDrawingPolygon = false;
            currentPolygonPoints = [];
            currentDrawingLine = null;
            currentMode = 'idle';
            drawAreaBtn.classList.add('btn-primary');
            drawAreaBtn.classList.remove('btn-secondary');
            drawCanvas();
        }


        // --- Scale Modal Functions (for drawing reference line) ---

        /**
         * Displays the scale input modal.
         */
        function showScaleModal() {
            scaleModal.style.display = 'flex';
            scaleLengthInput.value = '';
            scaleUnitSelect.value = 'mm';
        }

        /**
         * Hides the scale input modal.
         */
        function hideScaleModal() {
            scaleModal.style.display = 'none';
        }

        /**
         * Helper to convert a value from a given unit to millimeters.
         * @param {number} value - The value to convert.
         * @param {string} unit - The unit of the value.
         * @returns {number} The value in millimeters.
         */
        function convertUnitToMM(value, unit) {
            switch (unit) {
                case 'um': return value / 1000;
                case 'mm': return value;
                case 'cm': return value * 10;
                case 'm': return value * 1000;
                case 'px': return value / pixelsPerMM; // Convert px to mm if pixelsPerMM is set
                default: return value;
            }
        }

        /**
         * Handles saving the scale from the modal (for drawn reference line).
         */
        saveScaleBtn.addEventListener('click', () => {
            const length = parseFloat(scaleLengthInput.value);
            const unit = scaleUnitSelect.value;

            if (isNaN(length) || length <= 0 || !referenceLine) {
                showMessageModal('Please enter a valid positive length for the reference line.');
                return;
            }

            const referenceLengthInMM = convertUnitToMM(length, unit);
            pixelsPerMM = referenceLine.lengthPx / referenceLengthInMM;
            scaleBaseUnit = unit;

            // Store real-world length and unit in the referenceLine object
            referenceLine.realWorldLength = length;
            referenceLine.realWorldUnit = unit;

            console.log(`Scale set (Draw Line): ${pixelsPerMM.toFixed(2)} pixels per mm (based on ${length} ${unit} = ${referenceLine.lengthPx.toFixed(0)} px)`);

            hideScaleModal();
            drawLineBtn.disabled = false;
            drawAreaBtn.disabled = false;
            addLineByValueBtn.disabled = false;
            currentMode = 'idle';
            updateMeasurementsList(); // This will now display the scale line
            updateScaleInfoDisplay();
            drawCanvas();
        });

        // --- Pixel Scale Input Modal Functions ---

        /**
         * Displays the pixel scale input modal.
         */
        function showPixelScaleModal() {
            pixelScaleModal.style.display = 'flex';
            pixelLengthInput.value = '';
            pixelUnitSelect.value = 'mm';
        }

        /**
         * Hides the pixel scale input modal.
         */
        function hidePixelScaleModal() {
            pixelScaleModal.style.display = 'none';
        }

        /**
         * Handles saving the pixel scale from the modal.
         */
        savePixelScaleBtn.addEventListener('click', () => {
            const length = parseFloat(pixelLengthInput.value);
            const unit = pixelUnitSelect.value;

            if (isNaN(length) || length <= 0) {
                showMessageModal('Please enter a valid positive length for 1 image pixel.');
                return;
            }

            const pixelLengthInMM = convertUnitToMM(length, unit);
            pixelsPerMM = 1 / pixelLengthInMM;
            scaleBaseUnit = unit;

            // For pixel scale, we don't have a drawn referenceLine, but we can create a virtual one
            // to display in the list if desired, or just rely on updateScaleInfoDisplay.
            // For now, let's just update the info display.
            referenceLine = null; // Ensure no drawn reference line exists if using pixel scale
            updateMeasurementsList(); // Clear any old reference line from list
            updateScaleInfoDisplay();

            console.log(`Scale set (1 Pixel): 1 pixel = ${length} ${unit} (${pixelsPerMM.toFixed(2)} pixels per mm)`);

            hidePixelScaleModal();
            drawLineBtn.disabled = false;
            drawAreaBtn.disabled = false;
            addLineByValueBtn.disabled = false;
            currentMode = 'idle';
            drawCanvas();
        });


        // --- Common Modal Close Handlers ---
        scaleModalCloseButton.addEventListener('click', hideScaleModal);
        closePixelScaleModalBtn.addEventListener('click', hidePixelScaleModal);
        closeAreaSettingsModalBtn.addEventListener('click', hideAreaSettingsModal);
        closeAddLineModalBtn.addEventListener('click', hideAddLineModal);
        closeScaleLineSettingsModalBtn.addEventListener('click', hideScaleLineSettingsModal);
        closeLineSettingsModalBtn.addEventListener('click', hideLineSettingsModal);
messageModalCloseBtn.addEventListener('click', hideMessageModal);
        
        window.addEventListener('click', (event) => {
            if (event.target === scaleModal) {
                hideScaleModal();
            }
            if (event.target === pixelScaleModal) {
                hidePixelScaleModal();
            }
            if (event.target === lineSettingsModal) {
                hideLineSettingsModal();
            }
            if (event.target === areaSettingsModal) {
                hideAreaSettingsModal();
            }
            if (event.target === addLineModal) {
                hideAddLineModal();
            }
            if (event.target === scaleLineSettingsModal) {
                hideScaleLineSettingsModal();
            }
            if (event.target === messageModal) {
                if (pendingDeleteIndex !== -1) {
                    if (pendingDeleteType === 'line') {
                        measurementLines.splice(pendingDeleteIndex, 1);
                    } else if (pendingDeleteType === 'area') {
                        measurementAreas.splice(pendingDeleteIndex, 1);
                    }
                    updateMeasurementsList();
                    pendingDeleteIndex = -1;
                    pendingDeleteType = '';
                }
                hideMessageModal();
            }
        });

        // --- Line Settings Modal Functions ---

        /**
         * Opens the line settings modal for a specific line.
         * @param {number} index - The index of the line to edit.
         */
        function openLineSettingsModal(index) {
            editingLineIndex = index;
            const line = measurementLines[index];
            if (line) {
                lineColorPicker.value = line.color || defaultLineSettings.color;
                labelFontSizeInput.value = line.fontSize || defaultLineSettings.fontSize;
                lineThicknessInput.value = line.thickness || defaultLineSettings.thickness;
                labelFontColorPicker.value = line.fontColor || defaultLineSettings.fontColor;
                labelFontWeightSelect.value = line.fontWeight || defaultLineSettings.fontWeight;
                sideBarLengthInput.value = line.barLength || defaultLineSettings.barLength;
                labelVerticalOffsetInput.value = line.labelOffsetY || defaultLineSettings.labelOffsetY;
                rotateLabelCheckbox.checked = line.rotateLabel !== undefined ? line.rotateLabel : defaultLineSettings.rotateLabel;
                lineSettingsModal.style.display = 'flex';
            }
        }

        /**
         * Hides the line settings modal.
         */
        function hideLineSettingsModal() {
            lineSettingsModal.style.display = 'none';
            editingLineIndex = -1;
        }

        /**
         * Handles saving line settings from the modal.
         */
        saveLineSettingsBtn.addEventListener('click', () => {
            if (editingLineIndex !== -1) {
                const line = measurementLines[editingLineIndex];
                line.color = lineColorPicker.value;
                line.fontSize = parseInt(labelFontSizeInput.value);
                line.thickness = parseInt(lineThicknessInput.value);
                line.fontColor = labelFontColorPicker.value;
                line.fontWeight = labelFontWeightSelect.value;
                line.barLength = parseInt(sideBarLengthInput.value);
                line.labelOffsetY = parseInt(labelVerticalOffsetInput.value);
                line.rotateLabel = rotateLabelCheckbox.checked;

                if (isNaN(line.fontSize) || line.fontSize < 8 || line.fontSize > 48) {
                    line.fontSize = 16;
                    showMessageModal('Font size must be between 8 and 48 pixels. Resetting to 16px.');
                }
                if (isNaN(line.thickness) || line.thickness < 1 || line.thickness > 10) {
                    line.thickness = 2;
                    showMessageModal('Line thickness must be between 1 and 10 pixels. Resetting to 2px.');
                }
                if (isNaN(line.barLength) || line.barLength < 0 || line.barLength > 30) {
                    line.barLength = 10;
                    showMessageModal('Side bar length must be between 0 and 30 pixels. Resetting to 10px.');
                }
                if (isNaN(line.labelOffsetY)) {
                    line.labelOffsetY = 0;
                    showMessageModal('Label offset must be a number. Resetting to 0px.');
                }

                // Update currentLineSettings for persistence
                currentLineSettings = {
                    color: line.color,
                    fontSize: line.fontSize,
                    thickness: line.thickness,
                    fontColor: line.fontColor,
                    fontWeight: line.fontWeight,
                    barLength: line.barLength,
                    labelOffsetY: line.labelOffsetY,
                    rotateLabel: line.rotateLabel
                };

                updateMeasurementsList();
                hideLineSettingsModal();
            }
        });

        // Reset Line Settings Button
        resetLineSettingsBtn.addEventListener('click', () => {
            if (editingLineIndex !== -1) {
                const line = measurementLines[editingLineIndex];

                // Apply default settings to the current line object
                Object.assign(line, defaultLineSettings);

                // Update modal inputs to reflect default settings
                lineColorPicker.value = defaultLineSettings.color;
                labelFontSizeInput.value = defaultLineSettings.fontSize;
                lineThicknessInput.value = defaultLineSettings.thickness;
                labelFontColorPicker.value = defaultLineSettings.fontColor;
                labelFontWeightSelect.value = defaultLineSettings.fontWeight;
                sideBarLengthInput.value = defaultLineSettings.barLength;
                labelVerticalOffsetInput.value = defaultLineSettings.labelOffsetY;
                rotateLabelCheckbox.checked = defaultLineSettings.rotateLabel;

                // Also update currentLineSettings so subsequent new lines use defaults
                currentLineSettings = { ...defaultLineSettings };

                updateMeasurementsList();
                showMessageModal('Line settings reset to default for this line.');
            }
        });

        // --- NEW: Scale Line Settings Modal Functions ---
        function openScaleLineSettingsModal() {
            if (!referenceLine) {
                showMessageModal("No scale line has been set yet.");
                return;
            }
            // Populate modal fields with current referenceLine properties
            scaleLineLengthInput.value = referenceLine.realWorldLength;
            scaleLineUnitSelect.value = referenceLine.realWorldUnit;
            scaleLineColorPicker.value = referenceLine.color;
            scaleLabelFontSizeInput.value = referenceLine.fontSize;
            scaleLineThicknessInput.value = referenceLine.thickness;
            scaleLabelFontColorPicker.value = referenceLine.fontColor;
            scaleLabelFontWeightSelect.value = referenceLine.fontWeight;
            scaleSideBarLengthInput.value = referenceLine.barLength;
            scaleLabelVerticalOffsetInput.value = referenceLine.labelOffsetY;
            lockScaleLineCheckbox.checked = referenceLine.locked;

            scaleLineSettingsModal.style.display = 'flex';
        }

        function hideScaleLineSettingsModal() {
            scaleLineSettingsModal.style.display = 'none';
        }

        saveScaleLineSettingsBtn.addEventListener('click', () => {
            if (!referenceLine) return;

            const newLength = parseFloat(scaleLineLengthInput.value);
            const newUnit = scaleLineUnitSelect.value;
            const newLockedState = lockScaleLineCheckbox.checked;

            if (isNaN(newLength) || newLength <= 0) {
                showMessageModal('Please enter a valid positive length for the scale line.');
                return;
            }

            // Update appearance properties
            referenceLine.color = scaleLineColorPicker.value;
            referenceLine.fontSize = parseInt(scaleLabelFontSizeInput.value);
            referenceLine.thickness = parseInt(scaleLineThicknessInput.value);
            referenceLine.fontColor = scaleLabelFontColorPicker.value;
            referenceLine.fontWeight = scaleLabelFontWeightSelect.value;
            referenceLine.barLength = parseInt(scaleSideBarLengthInput.value);
            referenceLine.labelOffsetY = parseInt(scaleLabelVerticalOffsetInput.value);
            referenceLine.locked = newLockedState;

            // Validate inputs
            if (isNaN(referenceLine.fontSize) || referenceLine.fontSize < 8 || referenceLine.fontSize > 48) {
                referenceLine.fontSize = defaultScaleLineSettings.fontSize;
                showMessageModal('Font size must be between 8 and 48 pixels. Resetting to default.');
            }
            if (isNaN(referenceLine.thickness) || referenceLine.thickness < 1 || referenceLine.thickness > 10) {
                referenceLine.thickness = defaultScaleLineSettings.thickness;
                showMessageModal('Line thickness must be between 1 and 10 pixels. Resetting to default.');
            }
            if (isNaN(referenceLine.barLength) || referenceLine.barLength < 0 || referenceLine.barLength > 30) {
                referenceLine.barLength = defaultScaleLineSettings.barLength;
                showMessageModal('Side bar length must be between 0 and 30 pixels. Resetting to default.');
            }
            if (isNaN(referenceLine.labelOffsetY)) {
                referenceLine.labelOffsetY = defaultScaleLineSettings.labelOffsetY;
                showMessageModal('Label offset must be a number. Resetting to default.');
            }


            // Update real-world length and recalculate pixelsPerMM if changed
            if (newLength !== referenceLine.realWorldLength || newUnit !== referenceLine.realWorldUnit) {
                referenceLine.realWorldLength = newLength;
                referenceLine.realWorldUnit = newUnit;
                const realWorldLengthInMM = convertUnitToMM(referenceLine.realWorldLength, referenceLine.realWorldUnit);
                if (referenceLine.lengthPx > 0 && realWorldLengthInMM > 0) {
                    pixelsPerMM = referenceLine.lengthPx / realWorldLengthInMM;
                    scaleBaseUnit = referenceLine.realWorldUnit;
                } else {
                    pixelsPerMM = 0; // Cannot calculate if pixel length or real world length is zero
                }
            }

            updateMeasurementsList();
            updateScaleInfoDisplay();
            drawCanvas(); // Redraw immediately to reflect changes
            hideScaleLineSettingsModal();
        });

        resetScaleLineSettingsBtn.addEventListener('click', () => {
            if (!referenceLine) return;

            // Reset only the appearance properties to defaultScaleLineSettings
            Object.assign(referenceLine, {
                color: defaultScaleLineSettings.color,
                fontSize: defaultScaleLineSettings.fontSize,
                thickness: defaultScaleLineSettings.thickness,
                fontColor: defaultScaleLineSettings.fontColor,
                fontWeight: defaultScaleLineSettings.fontWeight,
                barLength: defaultScaleLineSettings.barLength,
                labelOffsetY: defaultScaleLineSettings.labelOffsetY,
                rotateLabel: defaultScaleLineSettings.rotateLabel,
                locked: defaultScaleLineSettings.locked
            });

            // Update modal inputs to reflect these defaults
            scaleLineColorPicker.value = defaultScaleLineSettings.color;
            scaleLabelFontSizeInput.value = defaultScaleLineSettings.fontSize;
            scaleLineThicknessInput.value = defaultScaleLineSettings.thickness;
            scaleLabelFontColorPicker.value = defaultScaleLineSettings.fontColor;
            scaleLabelFontWeightSelect.value = defaultScaleLineSettings.fontWeight;
            scaleSideBarLengthInput.value = defaultScaleLineSettings.barLength;
            scaleLabelVerticalOffsetInput.value = defaultScaleLineSettings.labelOffsetY;
            lockScaleLineCheckbox.checked = defaultScaleLineSettings.locked;

            updateMeasurementsList();
            drawCanvas(); // Redraw immediately to reflect changes
            showMessageModal('Scale line appearance settings reset to default.');
        });


        // --- Area Settings Modal Functions ---

        /**
         * Opens the area settings modal for a specific polygon.
         * @param {number} index - The index of the polygon to edit.
         */
        function openAreaSettingsModal(index) {
            editingAreaIndex = index;
            const area = measurementAreas[index];
            if (area) {
                areaStrokeColorPicker.value = area.strokeColor || '#0000ff';
                areaFillColorPicker.value = area.fillColor || '#0000ff80';
                areaStrokeThicknessInput.value = area.strokeThickness || 2;
                areaLabelFontSizeInput.value = area.fontSize || 16;
                areaLabelFontColorPicker.value = area.fontColor || '#ffffff';
                areaLabelFontWeightSelect.value = area.fontWeight || 'bold';
                areaSettingsModal.style.display = 'flex';
            }
        }

        /**
         * Hides the area settings modal.
         */
        function hideAreaSettingsModal() {
            areaSettingsModal.style.display = 'none';
            editingAreaIndex = -1;
        }

        /**
         * Handles saving area settings from the modal.
         */
        saveAreaSettingsBtn.addEventListener('click', () => {
            if (editingAreaIndex !== -1) {
                const area = measurementAreas[editingAreaIndex];
                area.strokeColor = areaStrokeColorPicker.value;
                area.fillColor = areaFillColorPicker.value;
                area.strokeThickness = parseInt(areaStrokeThicknessInput.value);
                area.fontSize = parseInt(areaLabelFontSizeInput.value);
                area.fontColor = areaLabelFontColorPicker.value;
                area.fontWeight = areaLabelFontWeightSelect.value;

                if (isNaN(area.fontSize) || area.fontSize < 8 || area.fontSize > 48) {
                    area.fontSize = 16;
                    showMessageModal('Font size must be between 8 and 48 pixels. Resetting to 16px.');
                }
                if (isNaN(area.strokeThickness) || area.strokeThickness < 1 || area.strokeThickness > 10) {
                    area.strokeThickness = 2;
                    showMessageModal('Border thickness must be between 1 and 10 pixels. Resetting to 2px.');
                }

                updateMeasurementsList();
                hideAreaSettingsModal();
            }
        });


        /**
         * Deletes a shape (line or area).
         * @param {number} index - The index of the shape to delete.
         * @param {string} type - The type of shape ('line' or 'area').
         */
        function deleteShape(index, type) {
            pendingDeleteIndex = index;
            pendingDeleteType = type;
            showMessageModal(`Are you sure you want to delete this ${type} measurement?`);
        }

        // --- Add Line by Value Functions ---

        /**
         * Displays the Add Line by Value modal.
         */
        addLineByValueBtn.addEventListener('click', () => {
            if (!currentImage || pixelsPerMM === 0) {
                showMessageModal('Please upload an image and set the scale first.');
                return;
            }
            addLineModal.style.display = 'flex';
            newLineLengthInput.value = '';
            newLineUnitSelect.value = displayUnitSelect.value; // Default to current display unit
            newLineOrientationSelect.value = 'horizontal';
        });

        /**
         * Hides the Add Line by Value modal.
         */
        function hideAddLineModal() {
            addLineModal.style.display = 'none';
        }

        /**
         * Handles drawing a new line based on user input from the modal.
         */
        drawNewLineBtn.addEventListener('click', () => {
            const length = parseFloat(newLineLengthInput.value);
            const unit = newLineUnitSelect.value;
            const orientation = newLineOrientationSelect.value;

            if (isNaN(length) || length <= 0) {
                showMessageModal('Please enter a valid positive length for the new line.');
                return;
            }
            if (pixelsPerMM === 0) {
                showMessageModal('Scale is not set. Please set the image scale first.');
                return;
            }

            // Convert the desired length to pixels based on the current scale
            const lengthPx = convertUnitToPixels(length, unit);

            // Calculate center of the image (in original image pixels)
            const centerX = originalImage.width / 2;
            const centerY = originalImage.height / 2;

            let startX, startY, endX, endY;

            if (orientation === 'horizontal') {
                startX = centerX - (lengthPx / 2);
                startY = centerY;
                endX = centerX + (lengthPx / 2);
                endY = centerY;
            } else { // vertical
                startX = centerX;
                startY = centerY - (lengthPx / 2);
                endX = centerX;
                endY = centerY + (lengthPx / 2);
            }

            const newLine = {
                start: { x: startX, y: startY },
                end: { x: endX, y: endY },
                ...currentLineSettings, // Apply current settings for new line
                type: 'line'
            };

            measurementLines.push(newLine);
            updateMeasurementsList();
            hideAddLineModal();
            console.log(`New ${orientation} line of ${length} ${unit} added.`);
        });

        /**
         * Helper to convert a value from a given unit to pixels.
         * @param {number} value - The value to convert.
         * @param {string} unit - The unit of the value.
         * @returns {number} The value in pixels.
         */
        function convertUnitToPixels(value, unit) {
            if (unit === 'px') {
                return value;
            }
            if (pixelsPerMM === 0) {
                return 0; // Cannot convert if scale not set
            }
            // Convert value to millimeters first
            let valueInMM = convertUnitToMM(value, unit);
            // Convert millimeters to pixels
            return valueInMM * pixelsPerMM;
        }

        // --- Initial Setup ---
        function resizeCanvasContainer() {
            const appContainer = document.getElementById('app-container');
            // Set the canvas container's max height based on the app container
            // This controls the *display size* of the canvas element via CSS.
            canvasContainer.style.maxHeight = `${appContainer.clientHeight - 50}px`;

            // IMPORTANT: Do NOT set imageCanvas.width/height here based on clientWidth/clientHeight.
            // imageCanvas.width and imageCanvas.height should remain at the original image's resolution.
            // The CSS will handle scaling the canvas for display.

            drawCanvas(); // Redraw with potentially new CSS display dimensions
        }

        window.addEventListener('resize', resizeCanvasContainer);
        resizeCanvasContainer();

        setScaleBtn.disabled = true;
        setPixelScaleBtn.disabled = true;
        drawLineBtn.disabled = true;
        drawAreaBtn.disabled = true;
        addLineByValueBtn.disabled = true;
        clearAllBtn.disabled = true;
        saveImageBtn.disabled = true;
        displayUnitSelect.disabled = true;
        toggleRefLineCheckbox.disabled = true;
        imageWidthDisplay.textContent = 'Image Width: Not set';
        imageHeightDisplay.textContent = 'Image Height: Not set';
        updateScaleInfoDisplay();
        drawCanvas();
    </script>
</body>
</html>
