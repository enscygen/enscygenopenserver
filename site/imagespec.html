<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>ImageSpec Pro | Enscygen ORT</title>
  <link rel="icon" type="image/x-icon" href="/Favicon.png">
    
    <!-- Bootstrap Icons for UI elements -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    
    <!-- Chart.js for plotting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Google Fonts for 'Inter' -->
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">

    <style>
        :root {
            --bg-primary: #111827; --bg-card: #1f2937; --border-primary: #374151;
            --border-secondary: #4b5563; --text-primary: #d1d5db; --text-secondary: #9ca3af;
            --text-white: #ffffff; --font-main: 'Inter', sans-serif; --accent-blue: #3b82f6;
            --accent-blue-hover: #2563eb; --accent-green: #22c55e; --accent-red: #ef4444;
            --accent-red-hover: #dc2626; --accent-cyan: #22d3ee;
        }
        html { color-scheme: dark; }
        body {
            background-color: var(--bg-primary); color: var(--text-primary); font-family: var(--font-main);
            font-size: 12px;
            display: flex; height: 100vh; overflow: hidden;
        }
        aside {
            width: 33.33%; min-width: 420px; max-width: 450px; height: 100%; display: flex;
            flex-direction: column; padding: 6px; gap: 6px; overflow-y: auto;
        }
        main { flex-grow: 1; height: 100%; display: flex; flex-direction: column; padding: 6px; }
        ::-webkit-scrollbar { width: 8px; height: 8px;}
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--border-secondary); border-radius: 4px; border: 2px solid var(--bg-primary); }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .card {
            background-color: var(--bg-card); border: 1px solid var(--border-primary);
            border-radius: 6px; padding: 10px; flex-shrink: 0;
        }
        .card-grow { flex-grow: 1; min-height: 0; display: flex; flex-direction: column; }
        h1 { font-size: 18px; font-weight: 600; color: var(--text-white); margin: 0; padding: 0;}
        h2 { font-size: 13px; font-weight: 600; color: var(--text-white); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        header p { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }
        label { display: block; font-size: 10px; font-weight: 500; color: var(--text-secondary); margin-bottom: 3px; text-transform: uppercase; }
        .form-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
        .form-grid-3 { display: grid; grid-template-columns: 1fr 1fr auto; gap: 6px; align-items: flex-end; margin-bottom: 4px; }
        .form-input, .form-select {
            background-color: var(--border-primary); border: 1px solid var(--border-secondary);
            color: var(--text-primary); border-radius: 4px; padding: 4px 7px;
            font-size: 12px; width: 100%; box-sizing: border-box; transition: all 0.2s;
        }
        .form-input:focus, .form-select:focus { outline: none; border-color: var(--accent-blue); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
        input[type='number'] { -moz-appearance: textfield; }
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 5px;
            padding: 4px 9px; border-radius: 4px; font-weight: 500; font-size: 12px;
            transition: all 0.2s; border: 1px solid transparent; cursor: pointer; width: 100%;
        }
        .btn.btn-small { padding: 3px 8px; font-size: 10px; width: auto; }
        .btn-primary { background-color: var(--accent-blue); color: white; border-color: var(--accent-blue); }
        .btn-primary:hover { background-color: var(--accent-blue-hover); }
        .btn-secondary { background-color: var(--border-secondary); color: white; border-color: #6b7280; }
        .btn-secondary:hover { background-color: #6b7280; }
        .btn-danger { background-color: var(--accent-red); color: white; border-color: var(--accent-red); }
        .btn-danger:hover { background-color: var(--accent-red-hover); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .media-wrapper { position: relative; width: 100%; height: 100%; cursor: crosshair; overflow: hidden; border-radius: 6px;}
        #mediaContainer {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0;
            background-color: black; overflow: auto;
        }
        #video, #uploadedImage {
            transform-origin: top left;
            max-width: none;
            position: absolute; top: 0; left: 0;
        }
        #message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: var(--text-secondary); padding: 16px;}
        .hidden { display: none; }
        #roi {
            position: absolute; border: 1px dashed rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.5), inset 0 0 8px rgba(0, 255, 255, 0.3); 
            border-radius: 0; background-color: rgba(0, 255, 255, 0.05); pointer-events: none;
            transition: border-color 0.2s;
        }
        #roi.circle { border-radius: 50%; }
        #roi.out-of-bounds { border-color: var(--accent-red); }
        #roiWarning {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background-color: rgba(239, 68, 68, 0.8); color: white; padding: 4px 10px;
            border-radius: 4px; font-size: 10px; pointer-events: none; z-index: 10;
        }

        #calibrationStatus { display: flex; align-items: center; gap: 8px; height: 100%; font-size: 12px; }
        #results { margin-top: 8px; display: flex; flex-wrap: wrap; gap: 6px; text-align: center; }
        .result-box {
            padding: 5px; border-radius: 4px; flex-grow: 1;
            min-width: 60px; position: relative;
        }
        .delete-wl-btn {
            position: absolute; top: 1px; left: 3px; cursor: pointer; color: var(--text-secondary);
            font-size: 10px; padding: 2px; transition: color 0.2s;
        }
        .delete-wl-btn:hover { color: var(--accent-red); }
        #results .font-bold, #concentrationResult .font-bold { font-weight: 600; font-size: 10px; text-transform: uppercase; }
        .font-mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        #results .text-lg { font-size: 14px; }
        .bg-red { background-color: rgba(127, 29, 29, 0.5); } .bg-green { background-color: rgba(21, 128, 61, 0.5); }
        .bg-blue { background-color: rgba(30, 64, 175, 0.5); }
        #concentrationResult { margin-top: 10px; text-align: center; }
        #estConc { font-size: 20px; color: var(--accent-cyan); }
        .chart-controls { display: flex; justify-content: flex-end; margin-bottom: 6px; }
        .chart-container { position: relative; min-height: 120px; flex-grow: 1; margin-bottom: 8px; }
        #curveFitInfo { font-size: 10px; text-align: center; background-color: var(--bg-primary); padding: 3px; border-radius: 4px; margin-bottom: 8px; }
        .table-container { max-height: 150px; overflow-y: auto; border: 1px solid var(--border-primary); border-radius: 6px; position: relative; }
        table { width: 100%; font-size: 11px; text-align: left; border-collapse: collapse; }
        thead { background-color: var(--bg-card); position: sticky; top: 0; z-index: 10; }
        th, td { padding: 5px; border-bottom: 1px solid var(--border-primary); }
        tbody tr:last-child td { border-bottom: none; }
        .delete-btn { cursor: pointer; color: var(--text-secondary); transition: color 0.2s; } .delete-btn:hover { color: var(--accent-red); }
        .button-group { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; } 
        .button-group .btn, .button-group .form-select { flex: 1; min-width: 90px; }
        .input-group { display:flex; align-items:center; }
        .input-group .form-input { border-top-right-radius:0; border-bottom-right-radius:0; }
        .input-group .btn { border-top-left-radius:0; border-bottom-left-radius:0; width:auto; }
        .inspector-grid { display: grid; grid-template-columns: 90px 1fr; gap: 10px; align-items: center; margin-top: 10px;}
        #roiPreview { width: 90px; height: 90px; background-color: #000; border: 1px solid var(--border-secondary); image-rendering: pixelated; }
        .stats-grid { display: grid; grid-template-columns: auto 1fr; gap: 3px 10px; font-size: 11px; }
        .stats-grid > dt { color: var(--text-secondary); text-align: right; } .stats-grid > dd { color: var(--text-primary); font-weight: 500; }
        
        @media (max-width: 1024px) {
            body { flex-direction: column; height: auto; overflow-y: auto; font-size: 14px; }
            aside { width: 100%; max-width: none; height: auto; overflow-y: visible; padding: 8px; }
            main { width: 100%; height: 60vh; padding: 0 8px 8px 8px; }
            .form-grid, .form-grid-3 { grid-template-columns: 1fr; gap: 12px; }
            .btn, .form-input, .form-select { padding: 12px; font-size: 14px; }
            .btn.btn-small { padding: 8px 12px; font-size: 12px; }
            h1 { font-size: 22px; } h2 { font-size: 16px; }
            label, .font-mono, #results .font-bold, #concentrationResult .font-bold, table, #curveFitInfo { font-size: 12px; }
            .inspector-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <canvas id="canvas" class="hidden"></canvas>
    <input type="file" id="csvUpload" class="hidden" accept=".csv,text/csv">

    <aside>
        <header>
            <h1><i class="bi bi-camera-video-fill" style="color: var(--accent-blue);"></i> ImageSpec Pro</h1>
            <p>Image-Based Spectrophotometer Simulator</p>
        </header>

        <div class="card">
            <h2>Setup & Calibration</h2>
            <div class="form-grid" style="margin-bottom: 12px;">
                <div>
                    <label for="sourceMode">Input Source</label>
                    <select id="sourceMode" class="form-select">
                        <option value="camera">Live Camera</option>
                        <option value="upload">Uploaded Image</option>
                    </select>
                </div>
                 <div id="mediaControlContainer">
                    <div id="cameraControl">
                        <label for="cameraSelect">Select Camera</label>
                        <select id="cameraSelect" class="form-select"><option value="">Waiting for permission...</option></select>
                    </div>
                    <div id="uploadControl" class="hidden">
                         <label for="imageUpload">Upload Image</label>
                         <input type="file" id="imageUpload" accept="image/*" class="form-input">
                    </div>
                </div>
            </div>
            <div class="form-grid">
                <div>
                    <label for="projectName">Project Name</label>
                    <input type="text" id="projectName" class="form-input" value="Untitled Project">
                </div>
                <div>
                    <label>Calibration Status</label>
                    <div id="calibrationStatus">
                        <i class="bi bi-x-circle-fill" style="color:var(--accent-red);"></i><span>Not Calibrated</span>
                    </div>
                </div>
            </div>
             <button id="calibrateBtn" class="btn btn-primary" style="margin-top: 12px;" disabled>
                <i class="bi bi-eyedropper"></i> Calibrate (Set Blank)
            </button>
        </div>
        
        <div class="card">
             <h2>ROI Controls</h2>
             <div class="form-grid">
                 <div><label for="roiShape">Shape</label><select id="roiShape" class="form-select"><option value="square">Square</option><option value="circle">Circle</option><option value="point">Point (1x1 px)</option></select></div>
                 <div><label for="roiSize">Size (px)</label><input type="number" id="roiSize" class="form-input" value="50" min="1"></div>
             </div>
             <div class="inspector-grid">
                <canvas id="roiPreview"></canvas>
                <div>
                    <h2 style="margin-bottom: 4px;">ROI Inspector</h2>
                    <dl class="stats-grid">
                        <dt>Size:</dt><dd id="statRoiSize">0 x 0 px</dd>
                        <dt>Pixels:</dt><dd id="statPixelCount">0</dd>
                        <dt>Avg. Intensity:</dt><dd id="statIntensity">0.00</dd>
                    </dl>
                </div>
            </div>
        </div>

        <div class="card">
             <h2>Measurement</h2>
             <div id="results">
                <div class="result-box bg-red"><p class="font-bold">Abs (R)</p><p id="absR" class="text-lg font-mono">0.000</p></div>
                <div class="result-box bg-green"><p class="font-bold">Abs (G)</p><p id="absG" class="text-lg font-mono">0.000</p></div>
                <div class="result-box bg-blue"><p class="font-bold">Abs (B)</p><p id="absB" class="text-lg font-mono">0.000</p></div>
             </div>
             <div style="margin-top: 12px;"><label>Add Wavelength Channel (nm)</label><div class="input-group"><input type="number" id="wavelengthInput" placeholder="380-780" class="form-input"><button id="addWavelengthBtn" class="btn btn-secondary"><i class="bi bi-plus-lg"></i></button></div></div>
             <div style="margin-top: 12px;"><button id="measureBtn" class="btn btn-primary" disabled><i class="bi bi-beaker"></i> Measure Sample</button></div>
             <div id="concentrationResult" class="hidden"><p class="font-bold">Estimated Concentration</p><p id="estConc" class="font-mono">0.000</p></div>
        </div>
        
        <div class="card card-grow">
            <h2>Standard Curve & Data Log</h2>
            <div class="form-grid-3">
                <div><label>Sample Name</label><input type="text" id="sampleName" class="form-input" value="Sample-1"></div>
                <div><label>Concentration</label><input type="number" id="concentration" placeholder="Optional" class="form-input"></div>
                <button id="logMeasurementBtn" class="btn btn-secondary" disabled><i class="bi bi-journal-plus"></i> Log</button>
            </div>
            <div class="chart-controls">
                <button id="importCsvBtn" class="btn btn-secondary btn-small"><i class="bi bi-table"></i> Import Curve (CSV)</button>
            </div>
            <div class="chart-container"><canvas id="stdCurveChart"></canvas></div>
            <div id="curveFitInfo">Select a channel to build curve.</div>
            <div class="table-container"><table><thead><tr><th>Del</th><th>Sample</th><th>Conc.</th><th>Abs (R)</th><th>Abs (G)</th><th>Abs (B)</th></tr></thead><tbody id="logTableBody"></tbody></table></div>
            <div class="button-group">
                <select id="absChannel" class="form-select"><option value="absR">Curve: Abs (R)</option><option value="absG">Curve: Abs (G)</option><option value="absB">Curve: Abs (B)</option></select>
                <button id="exportCsvBtn" class="btn btn-secondary"><i class="bi bi-download"></i> Export</button>
                <button id="resetBtn" class="btn btn-danger"><i class="bi bi-trash"></i> Reset</button>
            </div>
        </div>

        <div style="background-color: rgba(0,0,0,0.1); border-top: 1px solid var(--border-primary); padding: 10px; margin-top: 8px; font-size: 10px; color: var(--text-secondary); line-height: 1.4; border-radius: 6px;">
            <i class="bi bi-info-circle-fill" style="float: left; margin-right: 8px; font-size: 24px; line-height: 1; color: var(--accent-blue);"></i>
            <strong style="color: var(--text-primary);">Disclaimer:</strong> This tool is a simulation, not a calibrated scientific instrument. It estimates absorbance by applying the Beer-Lambert principle to your camera's RGB pixel brightness. Results are intended for educational and qualitative purposes and may not be suitable for rigorous quantitative analysis.
        </div>
    </aside>

    <main>
        <div class="card card-grow" style="padding: 8px; display:flex; flex-direction:column;">
            <div class="media-wrapper">
                <div id="mediaContainer">
                    <video id="video" class="hidden"></video>
                    <img id="uploadedImage" class="hidden">
                    <div id="message"><i id="messageIcon" class="bi bi-camera-video-off" style="font-size: 2.25rem;"></i><p id="messageText">Select a camera to begin.</p></div>
                </div>
                <div id="roi" class="hidden"></div>
                <div id="roiWarning" class="hidden">Outside Bounds</div>
            </div>
        </div>
    </main>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const elements = {
                video: document.getElementById('video'),
                canvas: document.getElementById('canvas'),
                cameraSelect: document.getElementById('cameraSelect'),
                calibrateBtn: document.getElementById('calibrateBtn'),
                measureBtn: document.getElementById('measureBtn'),
                calibrationStatus: document.getElementById('calibrationStatus'),
                resultsDiv: document.getElementById('results'),
                logTableBody: document.getElementById('logTableBody'),
                sampleNameInput: document.getElementById('sampleName'),
                concentrationInput: document.getElementById('concentration'),
                absChannelSelect: document.getElementById('absChannel'),
                logMeasurementBtn: document.getElementById('logMeasurementBtn'),
                stdCurveChartCanvas: document.getElementById('stdCurveChart'),
                curveFitInfo: document.getElementById('curveFitInfo'),
                exportCsvBtn: document.getElementById('exportCsvBtn'),
                resetBtn: document.getElementById('resetBtn'),
                roiElement: document.getElementById('roi'),
                roiWarning: document.getElementById('roiWarning'),
                roiShapeSelect: document.getElementById('roiShape'),
                roiSizeInput: document.getElementById('roiSize'),
                sourceModeSelect: document.getElementById('sourceMode'),
                cameraControl: document.getElementById('cameraControl'),
                uploadControl: document.getElementById('uploadControl'),
                imageUpload: document.getElementById('imageUpload'),
                uploadedImage: document.getElementById('uploadedImage'),
                message: document.getElementById('message'),
                messageIcon: document.getElementById('messageIcon'),
                messageText: document.getElementById('messageText'),
                wavelengthInput: document.getElementById('wavelengthInput'),
                addWavelengthBtn: document.getElementById('addWavelengthBtn'),
                concentrationResult: document.getElementById('concentrationResult'),
                estConc: document.getElementById('estConc'),
                mediaContainer: document.getElementById('mediaContainer'),
                importCsvBtn: document.getElementById('importCsvBtn'),
                csvUpload: document.getElementById('csvUpload'),
                roiPreviewCanvas: document.getElementById('roiPreview'),
                statRoiSize: document.getElementById('statRoiSize'),
                statPixelCount: document.getElementById('statPixelCount'),
                statIntensity: document.getElementById('statIntensity'),
            };
            elements.ctx = elements.canvas.getContext('2d', { willReadFrequently: true });
            elements.roiPreviewCtx = elements.roiPreviewCanvas.getContext('2d');

            let state = {
                mode: 'camera', isCalibrated: false, blankRgb: null, currentMeasurement: null,
                sampleCounter: 1, measurements: [], customWavelengths: [],
                regression: { m: 0, c: 0, r2: 0, active: false }, currentStream: null,
                roi: { x: 0, y: 0, shape: 'square', size: 50 },
                zoom: 1, mediaReady: false,
            };
            let chart;
            let analysisLoopId = null;

            function wavelengthToRgb(wavelength) {
                let r, g, b; const gamma = 0.80;
                if (wavelength >= 380 && wavelength <= 439) { r = -(wavelength - 440) / (440 - 380); g = 0.0; b = 1.0; } 
                else if (wavelength >= 440 && wavelength <= 489) { r = 0.0; g = (wavelength - 440) / (490 - 440); b = 1.0; } 
                else if (wavelength >= 490 && wavelength <= 509) { r = 0.0; g = 1.0; b = -(wavelength - 510) / (510 - 490); } 
                else if (wavelength >= 510 && wavelength <= 579) { r = (wavelength - 510) / (580 - 510); g = 1.0; b = 0.0; } 
                else if (wavelength >= 580 && wavelength <= 644) { r = 1.0; g = -(wavelength - 645) / (645 - 580); b = 0.0; } 
                else if (wavelength >= 645 && wavelength <= 780) { r = 1.0; g = 0.0; b = 0.0; } 
                else { r = 0.0; g = 0.0; b = 0.0; }
                let factor;
                if (wavelength >= 380 && wavelength <= 419) factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);
                else if (wavelength >= 420 && wavelength <= 780) factor = 1.0;
                else factor = 0.0;
                const pow = (x, p) => x < 0 ? 0 : Math.pow(x, p);
                return { r: Math.round(255 * pow(r * factor, gamma)), g: Math.round(255 * pow(g * factor, gamma)), b: Math.round(255 * pow(b * factor, gamma)) };
            }

            async function getCameras() {
                try {
                    await navigator.mediaDevices.getUserMedia({ video: true });
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    elements.cameraSelect.innerHTML = '<option value="">Select a camera...</option>';
                    if (videoDevices.length === 0) {
                       elements.cameraSelect.innerHTML = '<option value="">No cameras found</option>';
                    }
                    videoDevices.forEach((device, index) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `Camera ${index + 1}`;
                        elements.cameraSelect.appendChild(option);
                    });
                } catch (error) { 
                    elements.cameraSelect.innerHTML = '<option value="">Permission denied</option>';
                    showMessage('bi-exclamation-triangle-fill', 'Camera access denied.');
                }
            }

            async function startCamera(deviceId) {
                if (state.mode !== 'camera' || !deviceId) return;
                stopMedia();
                const constraints = { video: { deviceId: { exact: deviceId }, width: { ideal: 1280 }, height: { ideal: 720 } } };
                try {
                    state.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                    elements.video.srcObject = state.currentStream;
                    await elements.video.play();
                    elements.video.classList.remove('hidden');
                    elements.message.classList.add('hidden');
                    elements.video.addEventListener('loadedmetadata', () => { 
                        state.mediaReady = true;
                        state.roi.x = elements.video.videoWidth / 2;
                        state.roi.y = elements.video.videoHeight / 2;
                        updateRoiPosition(); 
                        updateRoiVisibility(); 
                        startAnalysisLoop();
                        updateUI();
                    }, { once: true });
                } catch (error) { 
                    showMessage('bi-exclamation-triangle-fill', `Failed to start camera.`); 
                    state.mediaReady = false; updateUI();
                }
            }
            
            function stopMedia() {
                state.mediaReady = false;
                if (state.currentStream) { state.currentStream.getTracks().forEach(track => track.stop()); state.currentStream = null; }
                stopAnalysisLoop();
            }

            function resetZoomAndScroll() {
                state.zoom = 1;
                const media = getActiveMediaElement();
                media.style.transform = `scale(1)`;
                elements.mediaContainer.scrollTop = 0;
                elements.mediaContainer.scrollLeft = 0;
            }

            function setMode(newMode) {
                state.mode = newMode;
                stopMedia();
                resetZoomAndScroll();
                
                elements.video.classList.add('hidden');
                elements.uploadedImage.classList.add('hidden');
                
                if (newMode === 'camera') {
                    elements.cameraControl.classList.remove('hidden');
                    elements.uploadControl.classList.add('hidden');
                    if (elements.cameraSelect.value) {
                        startCamera(elements.cameraSelect.value);
                    } else {
                        showMessage('bi-camera-video-off', 'Select a camera to begin.');
                    }
                } else { // upload mode
                    elements.cameraControl.classList.add('hidden');
                    elements.uploadControl.classList.remove('hidden');
                    if (elements.uploadedImage.src) { 
                        elements.uploadedImage.classList.remove('hidden'); 
                        elements.message.classList.add('hidden');
                        state.mediaReady = true;
                        state.roi.x = elements.uploadedImage.naturalWidth / 2;
                        state.roi.y = elements.uploadedImage.naturalHeight / 2;
                        startAnalysisLoop();
                    }
                    else { showMessage('bi-upload', 'Upload an image to begin analysis.'); }
                }
                updateRoiVisibility();
                updateUI();
            }


            function handleImageUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                stopMedia();
                resetZoomAndScroll();
                const reader = new FileReader();
                reader.onload = (event) => {
                    elements.uploadedImage.src = event.target.result;
                    elements.uploadedImage.onload = () => {
                        elements.uploadedImage.classList.remove('hidden');
                        elements.message.classList.add('hidden');
                        state.mediaReady = true;
                        state.roi.x = elements.uploadedImage.naturalWidth / 2;
                        state.roi.y = elements.uploadedImage.naturalHeight / 2;
                        updateRoiPosition(); 
                        updateRoiVisibility();
                        updateUI();
                        startAnalysisLoop();
                    };
                };
                reader.readAsDataURL(file);
            }
            
            function getActiveMediaElement(){ return state.mode === 'camera' ? elements.video : elements.uploadedImage; }
            function showMessage(iconClass, text) { elements.message.classList.remove('hidden'); elements.messageIcon.className = `bi ${iconClass}`; elements.messageText.textContent = text; }

            function updateRoiFromControls() {
                state.roi.shape = elements.roiShapeSelect.value;
                state.roi.size = parseInt(elements.roiSizeInput.value, 10) || 1;
                if (state.roi.shape === 'point') { state.roi.size = 1; elements.roiSizeInput.value = 1; }
                updateRoiPosition();
            }
            
            function updateRoiVisibility() { elements.roiElement.classList.toggle('hidden', !state.mediaReady); }

            function updateRoiPosition() {
                if (!state.mediaReady) return;
                const scrollLeft = elements.mediaContainer.scrollLeft;
                const scrollTop = elements.mediaContainer.scrollTop;
                const cssX = state.roi.x * state.zoom - scrollLeft;
                const cssY = state.roi.y * state.zoom - scrollTop;
                const cssSize = state.roi.size * state.zoom;
                
                elements.roiElement.style.width = `${cssSize}px`;
                elements.roiElement.style.height = `${cssSize}px`;
                elements.roiElement.style.left = `${cssX - cssSize / 2}px`;
                elements.roiElement.style.top = `${cssY - cssSize / 2}px`;
                elements.roiElement.classList.toggle('circle', state.roi.shape === 'circle');
            }

            function analyzeCurrentFrame() {
                if (!state.mediaReady) return null;
                const media = getActiveMediaElement();
                let naturalWidth, naturalHeight;
                if (state.mode === 'camera') {
                    if (!(elements.video.readyState >= 2)) return null;
                    naturalWidth = elements.video.videoWidth; naturalHeight = elements.video.videoHeight;
                } else {
                    if (!(elements.uploadedImage.complete && elements.uploadedImage.naturalWidth > 0)) return null;
                    naturalWidth = elements.uploadedImage.naturalWidth; naturalHeight = elements.uploadedImage.naturalHeight;
                }
                if (naturalWidth === 0) return null;

                elements.canvas.width = naturalWidth;
                elements.canvas.height = naturalHeight;
                elements.ctx.drawImage(media, 0, 0, naturalWidth, naturalHeight);

                const centerX = state.roi.x;
                const centerY = state.roi.y;
                const isOutOfBounds = centerX < 0 || centerX >= naturalWidth || centerY < 0 || centerY >= naturalHeight;
                elements.roiWarning.classList.toggle('hidden', !isOutOfBounds);
                elements.roiElement.classList.toggle('out-of-bounds', isOutOfBounds);
                if (isOutOfBounds) {
                     elements.statRoiSize.textContent = `N/A`;
                     elements.statPixelCount.textContent = `0`;
                     elements.statIntensity.textContent = `0.00`;
                     elements.roiPreviewCtx.clearRect(0,0,100,100);
                    return null;
                }
                const radius = state.roi.size / 2;
                if (state.roi.shape === 'point') {
                    const pixel = elements.ctx.getImageData(Math.floor(centerX), Math.floor(centerY), 1, 1).data;
                    const intensity = (pixel[0] + pixel[1] + pixel[2]) / 3;
                    elements.roiPreviewCtx.fillStyle = `rgb(${pixel[0]},${pixel[1]},${pixel[2]})`;
                    elements.roiPreviewCtx.fillRect(0,0,100,100);
                    elements.statRoiSize.textContent = `1 x 1 px`;
                    elements.statPixelCount.textContent = 1;
                    elements.statIntensity.textContent = intensity.toFixed(2);
                    return { r: pixel[0], g: pixel[1], b: pixel[2] };
                }

                let r = 0, g = 0, b = 0, count = 0;
                const startX = Math.max(0, Math.floor(centerX - radius));
                const startY = Math.max(0, Math.floor(centerY - radius));
                const endX = Math.min(naturalWidth, Math.floor(centerX + radius));
                const endY = Math.min(naturalHeight, Math.floor(centerY + radius));
                
                if (endX <= startX || endY <= startY) return {r:0, g:0, b:0};
                
                const roiWidth = endX - startX;
                const roiHeight = endY - startY;
                const imageData = elements.ctx.getImageData(startX, startY, roiWidth, roiHeight);
                const data = imageData.data;
                const width = imageData.width;

                for (let y = 0; y < roiHeight; y++) {
                    for (let x = 0; x < roiWidth; x++) {
                        let include = false;
                        if (state.roi.shape === 'square') {
                            include = true;
                        } else { // circle
                            const dx = (startX + x) - centerX;
                            const dy = (startY + y) - centerY;
                            if (dx * dx + dy * dy <= radius * radius) include = true;
                        }
                        if (include) {
                            const i = (y * width + x) * 4;
                            r += data[i]; g += data[i+1]; b += data[i+2];
                            count++;
                        }
                    }
                }
                const avgIntensity = count > 0 ? (r + g + b) / (count * 3) : 0;
                elements.roiPreviewCtx.clearRect(0,0,100,100);
                elements.roiPreviewCtx.drawImage(elements.canvas, startX, startY, roiWidth, roiHeight, 0, 0, 100, 100);
                elements.statRoiSize.textContent = `${roiWidth} x ${roiHeight} px`;
                elements.statPixelCount.textContent = count;
                elements.statIntensity.textContent = avgIntensity.toFixed(2);
                return count > 0 ? { r: r/count, g: g/count, b: b/count } : {r:0, g:0, b:0};
            }

            function startAnalysisLoop() {
                stopAnalysisLoop();
                analysisLoopId = setInterval(() => { analyzeCurrentFrame(); }, 100);
            }
            function stopAnalysisLoop() { if (analysisLoopId) { clearInterval(analysisLoopId); analysisLoopId = null; } }
            
            function handleCalibrate() { 
                if(!state.mediaReady) return;
                const analysis = analyzeCurrentFrame(); 
                if (analysis) { 
                    state.blankRgb = {r: analysis.r, g: analysis.g, b: analysis.b}; 
                    state.isCalibrated = true; updateUI(); 
                } else { alert("Calibration failed. Ensure ROI is within image bounds."); }
            }
            
            function handleMeasure() {
                if (!state.isCalibrated) { alert("Please calibrate first."); return; }
                if (!state.mediaReady) return;
                const analysis = analyzeCurrentFrame();
                if (!analysis) { alert("Measurement failed. Ensure ROI is within image bounds."); return; }
                const sampleRgb = {r: analysis.r, g: analysis.g, b: analysis.b};
                const safeLog = (I0, I) => (I > 0 && I0 > 0) ? Math.log10(I0 / I) : 0;
                const measurement = {
                    absR: safeLog(state.blankRgb.r, sampleRgb.r),
                    absG: safeLog(state.blankRgb.g, sampleRgb.g),
                    absB: safeLog(state.blankRgb.b, sampleRgb.b),
                };
                state.customWavelengths.forEach(wl => {
                    const targetRgb = wavelengthToRgb(wl);
                    const blankIntensity = (state.blankRgb.r * targetRgb.r + state.blankRgb.g * targetRgb.g + state.blankRgb.b * targetRgb.b);
                    const sampleIntensity = (sampleRgb.r * targetRgb.r + sampleRgb.g * targetRgb.g + sampleRgb.b * targetRgb.b);
                    measurement[`abs${wl}`] = safeLog(blankIntensity, sampleIntensity);
                });
                state.currentMeasurement = measurement;
                updateUI();
            }

            function handleLogMeasurement() {
                if (!state.currentMeasurement) { alert("Please measure a sample first."); return; }
                const conc = parseFloat(elements.concentrationInput.value);
                const newMeasurement = {
                    id: Date.now(),
                    name: elements.sampleNameInput.value,
                    concentration: isNaN(conc) ? null : conc,
                    ...state.currentMeasurement
                };
                state.measurements.push(newMeasurement);
                state.sampleCounter++;
                elements.sampleNameInput.value = `Sample-${state.sampleCounter}`;
                elements.concentrationInput.value = '';
                updateUI();
            }

            function handleAddWavelength() {
                const wl = parseInt(elements.wavelengthInput.value, 10);
                if (!isNaN(wl) && wl >= 380 && wl <= 780 && !state.customWavelengths.includes(wl)) {
                    state.customWavelengths.push(wl);
                    state.customWavelengths.sort((a,b) => a - b);
                    updateUI();
                }
                elements.wavelengthInput.value = '';
            }

            function handleDeleteWavelength(wl) {
                state.customWavelengths = state.customWavelengths.filter(w => w !== wl);
                state.measurements.forEach(m => delete m[`abs${wl}`]);
                if (elements.absChannelSelect.value === `abs${wl}`) { elements.absChannelSelect.value = 'absR'; }
                updateUI();
            }

            function handleDeleteMeasurement(id) { state.measurements = state.measurements.filter(m => m.id !== id); updateUI(); }

            function handleCsvUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const lines = e.target.result.trim().split('\n');
                        const dataPoints = lines.map(line => line.split(/[,;\t]/).map(parseFloat)).filter(row => row.length === 2 && !isNaN(row[0]) && !isNaN(row[1]));
                        if (dataPoints.length === 0) throw new Error("No valid data points found.");
                        if (!confirm(`Found ${dataPoints.length} points. This will replace existing standard curve data. Proceed?`)) return;
                        state.measurements = state.measurements.filter(m => m.concentration === null);
                        const channel = elements.absChannelSelect.value;
                        dataPoints.forEach(([conc, abs], i) => {
                             const newMeasurement = { id: Date.now() + i, name: `Imported-${i+1}`, concentration: conc, absR: 0, absG: 0, absB: 0 };
                             newMeasurement[channel] = abs;
                             state.measurements.push(newMeasurement);
                        });
                        updateUI();
                    } catch (error) { alert(`Error parsing CSV file: ${error.message}`); } 
                    finally { elements.csvUpload.value = ''; }
                };
                reader.readAsText(file);
            }

            function calculateAndUpdateRegression() {
                const channel = elements.absChannelSelect.value;
                const points = state.measurements
                    .filter(m => m.concentration !== null && m[channel] !== undefined)
                    .map(m => ({ x: m.concentration, y: m[channel] }));

                if (points.length < 2) { state.regression = { m: 0, c: 0, r2: 0, active: false }; return; }
                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
                const n = points.length;
                points.forEach(p => { sumX += p.x; sumY += p.y; sumXY += p.x * p.y; sumX2 += p.x * p.x; sumY2 += p.y * p.y; });
                const m = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const c = (sumY - m * sumX) / n;
                const rNumerator = (n * sumXY - sumX * sumY);
                const rDenominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
                const r = rDenominator === 0 ? 0 : rNumerator / rDenominator;
                state.regression = { m, c, r2: r * r, active: true };
            }

            function updateUI() {
                elements.calibrateBtn.disabled = !state.mediaReady;
                elements.measureBtn.disabled = !state.mediaReady || !state.isCalibrated;
                elements.logMeasurementBtn.disabled = !state.currentMeasurement;

                if (state.isCalibrated) { elements.calibrationStatus.innerHTML = `<i class="bi bi-check-circle-fill" style="color:var(--accent-green);"></i><span>Calibrated</span>`; } 
                else { elements.calibrationStatus.innerHTML = `<i class="bi bi-x-circle-fill" style="color:var(--accent-red);"></i><span>Not Calibrated</span>`; }
                
                elements.resultsDiv.querySelectorAll('.dynamic-wl').forEach(el => el.remove());
                if(state.currentMeasurement) {
                    Object.keys(state.currentMeasurement).forEach(key => {
                        const el = document.getElementById(key);
                        if (el) el.textContent = state.currentMeasurement[key].toFixed(3);
                    });
                } else { ['absR', 'absG', 'absB'].forEach(key => { const el = document.getElementById(key); if(el) el.textContent = '0.000'; }); }

                state.customWavelengths.forEach(wl => {
                    const rgb = wavelengthToRgb(wl);
                    const box = document.createElement('div');
                    box.className = 'result-box dynamic-wl';
                    box.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.5)`;
                    box.innerHTML = `<i class="bi bi-trash-fill delete-wl-btn" data-wl="${wl}"></i><p class="font-bold">${wl} nm</p><p id="abs${wl}" class="text-lg font-mono">${state.currentMeasurement?.[`abs${wl}`]?.toFixed(3) || '0.000'}</p>`;
                    elements.resultsDiv.appendChild(box);
                });

                elements.logTableBody.innerHTML = '';
                let newAbsChannelOptions = '<option value="absR">Curve: Abs (R)</option><option value="absG">Curve: Abs (G)</option><option value="absB">Curve: Abs (B)</option>';
                const allWlHeaders = state.customWavelengths.map(wl => `<th>Abs (${wl}nm)</th>`).join('');
                document.querySelector('thead tr').innerHTML = `<th>Del</th><th>Sample</th><th>Conc.</th><th>Abs (R)</th><th>Abs (G)</th><th>Abs (B)</th>${allWlHeaders}`;
                
                state.measurements.forEach(m => {
                    const allWlCells = state.customWavelengths.map(wl => `<td class="font-mono">${m[`abs${wl}`]?.toFixed(3) || '-'}</td>`).join('');
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td><i class="bi bi-trash-fill delete-btn" data-id="${m.id}"></i></td>
                        <td>${m.name}</td>
                        <td class="font-mono">${m.concentration !== null ? m.concentration.toFixed(3) : '-'}</td>
                        <td class="font-mono">${m.absR ? m.absR.toFixed(3) : '0.000'}</td>
                        <td class="font-mono">${m.absG ? m.absG.toFixed(3) : '0.000'}</td>
                        <td class="font-mono">${m.absB ? m.absB.toFixed(3) : '0.000'}</td>
                        ${allWlCells}`;
                    elements.logTableBody.appendChild(row);
                });
                state.customWavelengths.forEach(wl => { newAbsChannelOptions += `<option value="abs${wl}">Curve: Abs (${wl}nm)</option>`; });
                const currentChannel = elements.absChannelSelect.value;
                elements.absChannelSelect.innerHTML = newAbsChannelOptions;
                elements.absChannelSelect.value = elements.absChannelSelect.querySelector(`option[value="${currentChannel}"]`) ? currentChannel : 'absR';

                calculateAndUpdateRegression();
                updateChart();
                if(state.regression.active) {
                    const {m, c, r2} = state.regression;
                    elements.curveFitInfo.textContent = `y = ${m.toFixed(4)}x + ${c.toFixed(4)} | R² = ${r2.toFixed(4)}`;
                    if(state.currentMeasurement && m !== 0) {
                        const absValue = state.currentMeasurement[elements.absChannelSelect.value];
                        const concentration = (absValue - c) / m;
                        elements.estConc.textContent = concentration.toFixed(3);
                        elements.concentrationResult.classList.remove('hidden');
                    } else { elements.concentrationResult.classList.add('hidden'); }
                } else { elements.curveFitInfo.textContent = 'Add ≥2 points with concentration to build curve.'; elements.concentrationResult.classList.add('hidden'); }
            }

            function updateChart() {
                if (!chart) return;
                const channel = elements.absChannelSelect.value;
                const points = state.measurements
                    .filter(m => m.concentration !== null && m[channel] !== undefined)
                    .map(m => ({ x: m.concentration, y: m[channel] }));

                chart.data.datasets[0].data = points;
                if (state.regression.active && points.length > 1) {
                    const xValues = points.map(p => p.x).filter(x => x !== null);
                    if (xValues.length > 0) {
                        const minX = Math.min(...xValues), maxX = Math.max(...xValues);
                        const { m, c } = state.regression;
                        chart.data.datasets[1].data = [{ x: minX, y: m * minX + c }, { x: maxX, y: m * maxX + c }];
                    } else {
                        chart.data.datasets[1].data = [];
                    }
                } else { chart.data.datasets[1].data = []; }
                
                const channelName = channel.startsWith('abs') ? channel.replace('abs', '') : channel;
                chart.options.scales.y.title.text = `Absorbance (${channelName})`;
                chart.update();
            }

            function handleExport() {
                if (state.measurements.length === 0) { alert("No data to export."); return; }
                let csvContent = "data:text/csv;charset=utf-8,";
                const headers = ["Sample", "Concentration", "Abs_R", "Abs_G", "Abs_B", ...state.customWavelengths.map(wl => `Abs_${wl}nm`)];
                csvContent += headers.join(",") + "\n";
                state.measurements.forEach(m => {
                    const row = [
                        m.name, m.concentration ?? '', m.absR.toFixed(4), m.absG.toFixed(4), m.absB.toFixed(4),
                        ...state.customWavelengths.map(wl => m[`abs${wl}`]?.toFixed(4) ?? '')
                    ];
                    csvContent += row.join(",") + "\n";
                });
                const link = document.createElement("a");
                link.setAttribute("href", encodeURI(csvContent));
                link.setAttribute("download", `${document.getElementById('projectName').value}_data.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            function handleReset() {
                 if (!confirm("This will reset all data, calibration, and custom wavelengths. Are you sure?")) return;
                 stopMedia();
                 resetZoomAndScroll();
                 state = {
                    mode: state.mode, isCalibrated: false, blankRgb: null, currentMeasurement: null,
                    sampleCounter: 1, measurements: [], customWavelengths: [],
                    regression: { m: 0, c: 0, r2: 0, active: false }, currentStream: null,
                    roi: { ...state.roi }, zoom: 1, mediaReady: false
                 };
                 elements.sampleNameInput.value = 'Sample-1';
                 elements.concentrationInput.value = '';
                 setMode(elements.sourceModeSelect.value); 
                 updateUI();
            }
            
            function handleZoom(event) {
                if (!state.mediaReady || !event.ctrlKey) return;
                event.preventDefault();
                const media = getActiveMediaElement();
                const rect = elements.mediaContainer.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                const scrollLeft = elements.mediaContainer.scrollLeft;
                const scrollTop = elements.mediaContainer.scrollTop;
                const zoomFactor = 1.1;
                const oldZoom = state.zoom;
                if (event.deltaY < 0) { state.zoom = Math.min(state.zoom * zoomFactor, 10); } 
                else { state.zoom = Math.max(state.zoom / zoomFactor, 1); }
                media.style.transform = `scale(${state.zoom})`;
                const newScrollLeft = (scrollLeft + mouseX) * (state.zoom / oldZoom) - mouseX;
                const newScrollTop = (scrollTop + mouseY) * (state.zoom / oldZoom) - mouseY;
                elements.mediaContainer.scrollLeft = newScrollLeft;
                elements.mediaContainer.scrollTop = newScrollTop;
                updateRoiPosition();
            }

            function init() {
                elements.calibrateBtn.addEventListener('click', handleCalibrate);
                elements.measureBtn.addEventListener('click', handleMeasure);
                elements.logMeasurementBtn.addEventListener('click', handleLogMeasurement);
                elements.exportCsvBtn.addEventListener('click', handleExport);
                elements.resetBtn.addEventListener('click', handleReset);
                elements.importCsvBtn.addEventListener('click', () => elements.csvUpload.click());
                elements.csvUpload.addEventListener('change', handleCsvUpload);
                elements.cameraSelect.addEventListener('change', () => startCamera(elements.cameraSelect.value));
                elements.sourceModeSelect.addEventListener('change', (e) => setMode(e.target.value));
                elements.imageUpload.addEventListener('change', handleImageUpload);
                elements.roiShapeSelect.addEventListener('change', updateRoiFromControls);
                elements.roiSizeInput.addEventListener('change', updateRoiFromControls);
                elements.addWavelengthBtn.addEventListener('click', handleAddWavelength);
                elements.absChannelSelect.addEventListener('change', updateUI);
                elements.logTableBody.addEventListener('click', (e) => { if (e.target.classList.contains('delete-btn')) { handleDeleteMeasurement(parseInt(e.target.dataset.id, 10)); }});
                elements.resultsDiv.addEventListener('click', (e) => { if (e.target.classList.contains('delete-wl-btn')) { handleDeleteWavelength(parseInt(e.target.dataset.wl, 10)); }});
                
                elements.mediaContainer.addEventListener('mousemove', (e) => {
                    if (!state.mediaReady) return;
                    const rect = elements.mediaContainer.getBoundingClientRect();
                    const scrollLeft = elements.mediaContainer.scrollLeft;
                    const scrollTop = elements.mediaContainer.scrollTop;
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    state.roi.x = (mouseX + scrollLeft) / state.zoom;
                    state.roi.y = (mouseY + scrollTop) / state.zoom;
                    updateRoiPosition();
                });
                
                elements.mediaContainer.addEventListener('wheel', handleZoom, { passive: false });
                window.addEventListener('resize', updateRoiPosition);

                chart = new Chart(elements.stdCurveChartCanvas, {
                    type: 'scatter',
                    data: { datasets: [
                        { label: 'Logged Points', data: [], backgroundColor: 'rgba(59, 130, 246, 0.7)', pointRadius: 5 },
                        { label: 'Regression Line', data: [], type: 'line', fill: false, borderColor: 'rgba(239, 68, 68, 0.7)', borderWidth: 2, pointRadius: 0 }
                    ]},
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: { legend: { display: false }},
                        scales: {
                            x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Concentration', color: 'var(--text-secondary)' }, ticks: { color: 'var(--text-secondary)', font: { size: 10 } }, grid: { color: 'var(--border-primary)' } },
                            y: { title: { display: true, text: 'Absorbance', color: 'var(--text-secondary)' }, ticks: { color: 'var(--text-secondary)', font: { size: 10 } }, grid: { color: 'var(--border-primary)' }, beginAtZero: true }
                        }
                    }
                });
                
                getCameras();
                setMode('camera'); 
                updateRoiFromControls();
                updateUI();
            }
            init();
        });
    </script>
</body>
</html>


