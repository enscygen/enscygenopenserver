<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ImageSpec | Enscygen ORT</title>
    <link rel="icon" type="image/x-icon" href="/Favicon.png" />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
          --bg-color: #121212;
          --surface-color: #1e1e1e;
          --primary-color: #bb86fc;
          --primary-variant-color: #3700b3;
          --secondary-color: #03dac6;
          --text-color: #e0e0e0;
          --text-color-muted: #888;
          --border-color: #333;
          --error-color: #cf6679;
          --font-family: 'Inter', sans-serif;
      }

      * {
          box-sizing: border-box;
          margin: 0;
          padding: 0;
      }

      html,
      body {
          height: 100%;
          
          font-family: var(--font-family);
          background-color: var(--bg-color);
          color: var(--text-color);
          font-size: 14px;
      }

      .app-container {
          display: grid;
          grid-template-columns: 280px 1fr 280px;
          grid-template-rows: auto 1fr auto;
          grid-template-areas: "header header header" "controls canvas data" "results results results";
          gap: 8px;
          padding: 8px;
      }

      .app-header {
          grid-area: header;
      }

      .controls-panel {
          grid-area: controls;
      }

      .canvas-container {
          grid-area: canvas;
      }

      .data-panel {
          grid-area: data;
      }

      .results-panel {
          grid-area: results;
      }

      .panel {
          background-color: var(--surface-color);
          border-radius: 8px;
          border: 1px solid var(--border-color);
          padding: 12px;
          display: flex;
          flex-direction: column;
          gap: 16px;
          overflow-y: auto;
      }

      .panel-title {
          font-size: 1.1em;
          font-weight: 500;
          display: flex;
          align-items: center;
          gap: 8px;
          margin: 0;
      }

      .collapsible-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          cursor: pointer;
          padding-bottom: 8px;
          border-bottom: 1px solid var(--border-color);
          margin-bottom: 8px;
      }

      .collapse-icon {
          font-size: 1.2em;
          transition: transform 0.3s ease;
      }

      .collapsible-content {
          max-height: 500px;
          overflow: hidden;
          transition: max-height 0.3s ease-out, padding 0.3s ease-out;
          display: flex;
          flex-direction: column;
          gap: 12px;
      }

      .collapsible:not(.open) .collapsible-content {
          max-height: 0;
          padding-top: 0;
          padding-bottom: 0;
      }

      .collapsible:not(.open) .collapse-icon {
          transform: rotate(-90deg);
      }

      .app-header {
          text-align: center;
          padding: 4px 0;
          font-size: 1.5em;
          font-weight: 600;
          color: var(--primary-color);
      }

      .form-group {
          display: flex;
          flex-direction: column;
          gap: 6px;
      }

      label {
          font-weight: 500;
          color: var(--text-color-muted);
          font-size: 0.9em;
      }

      input[type="text"],
      input[type="number"],
      select {
          width: 100%;
          padding: 8px;
          background-color: var(--bg-color);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          color: var(--text-color);
          font-size: 0.95em;
      }

      input:focus,
      select:focus {
          outline: none;
          border-color: var(--primary-color);
      }

      button {
          padding: 8px 12px;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          background-color: var(--primary-variant-color);
          color: #fff;
          font-weight: 500;
          transition: background-color 0.2s;
      }

      button:hover:not(:disabled) {
          background-color: var(--primary-color);
      }

      button:disabled {
          background-color: #333;
          cursor: not-allowed;
          color: #888;
      }

      .button-secondary {
          background-color: #444;
      }

      .button-secondary:hover {
          background-color: #555;
      }

      .icon-button {
          background: none;
          border: none;
          color: var(--text-color-muted);
          cursor: pointer;
          padding: 4px;
          border-radius: 50%;
      }

      .icon-button:hover {
          color: var(--secondary-color);
          background-color: rgba(3, 218, 198, 0.1);
      }

      .canvas-container {
          position: relative;
          background-color: #000;
          border-radius: 8px;
          overflow: hidden;
          display: flex;
          align-items: center;
          justify-content: center;
          min-height: 200px;
      }

      #mainCanvas,
      #roiCanvas {
          position: absolute;
          top: 0;
          left: 0;
          max-width: 100%;
          max-height: 100%;
          object-fit: contain;
      }

      #videoFeed {
          display: none;
      }

      #wavelengthList {
          list-style: none;
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
      }

      #wavelengthList li {
          padding: 4px 8px;
          border-radius: 12px;
          font-size: 0.9em;
          display: flex;
          align-items: center;
          gap: 6px;
          border: 1px solid #fff3;
      }

      #wavelengthList li button {
          background: none;
          border: none;
          color: inherit;
          cursor: pointer;
          padding: 0;
          font-size: 1.1em;
          line-height: 1;
      }

      #liveAbsorbanceValue {
          font-size: 2em;
          font-weight: 600;
          color: var(--secondary-color);
          text-align: center;
          margin: auto 0;
          transition: opacity 0.3s;
      }

      #liveAbsorbanceLabel {
          font-size: 0.8em;
          color: var(--text-color-muted);
          text-align: center;
          height: 1.2em;
      }

      .results-panel {
          max-height: 30vh;
      }

      #resultsTable {
          width: 100%;
          border-collapse: collapse;
          font-size: 0.9em;
      }

      #resultsTable th,
      #resultsTable td {
          padding: 8px;
          text-align: left;
          border-bottom: 1px solid var(--border-color);
      }

      #resultsTable thead {
          position: sticky;
          top: 0;
          background: var(--surface-color);
      }

      #resultsTable th {
          font-weight: 600;
          color: var(--text-color-muted);
      }

      .roi-thumbnail {
          width: 24px;
          height: 24px;
          border-radius: 4px;
          border: 1px solid #555;
      }

      .modal {
          display: none;
          position: fixed;
          z-index: 1000;
          left: 0;
          top: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          justify-content: center;
          align-items: center;
      }

      .modal-content {
          background-color: var(--surface-color);
          padding: 20px;
          border-radius: 8px;
          width: 90%;
          max-width: 500px;
          border: 1px solid var(--border-color);
      }

      .modal-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          border-bottom: 1px solid var(--border-color);
          padding-bottom: 10px;
          margin-bottom: 20px;
      }

      .close-button {
          background: none;
          border: none;
          font-size: 1.5rem;
          color: var(--text-color);
          cursor: pointer;
      }

      .radio-group {
          display: flex;
          border: 1px solid var(--border-color);
          border-radius: 4px;
          overflow: hidden;
      }

      .radio-group input[type="radio"] {
          display: none;
      }

      .radio-group label {
          flex: 1;
          text-align: center;
          padding: 8px;
          cursor: pointer;
          background-color: var(--bg-color);
          color: var(--text-color-muted);
          transition: all 0.2s;
          font-size: 0.9em;
      }

      .radio-group input[type="radio"]:checked+label {
          background-color: var(--primary-variant-color);
          color: white;
      }

      .input-row {
          display: flex;
          gap: 8px;
          align-items: center;
      }

      .input-row>* {
          flex: 1;
      }

      .info-preview-container {
          display: flex;
          gap: 10px;
          align-items: center;
          margin-top: 10px;
      }

      .info-preview-image {
          max-width: 128px;
          max-height: 128px;
          border: 1px solid var(--border-color);
          border-radius: 4px;
          image-rendering: pixelated;
      }

      @media (max-width: 900px) {
          .app-container {
              grid-template-columns: 1fr;
              grid-template-rows: auto auto auto auto 1fr;
              grid-template-areas: "header" "controls" "data" "canvas" "results";
              height: auto;
              overflow-y: auto;
          }

          .panel {
              min-height: auto;
          }

          .canvas-container {
              min-height: 300px;
              height: 50vh;
          }

          .results-panel {
              max-height: none;
          }
      }

      /* --- Styles for the new "ImageSpec Settings" section --- */

/* 1. Main container for each setting row (e.g., "Lock-in Blank: [icon] [checkbox]") */
/* This creates the perfect alignment between the label on the left and the controls on the right. */
.setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 2px 0; /* Adds a little vertical breathing room */
}

/* 2. Inner container for the controls (the icon and the checkbox) */
/* This ensures the icon and checkbox are perfectly aligned with each other. */
.setting-control {
    display: flex;
    align-items: center;
    gap: 12px; /* Provides consistent spacing between the icon and the checkbox */
}

/* 3. Styling for the clickable info icon */
.info-icon-settings {
    color: var(--text-color-muted); /* Matches the muted text color of the app */
    font-size: 1.2em; /* Makes the icon slightly larger and easier to click */
    cursor: pointer;
    transition: color 0.2s ease-in-out; /* Smooth transition for hover effect */
}

.info-icon-settings:hover {
    color: var(--secondary-color); /* Matches the app's highlight color on hover */
}

/* 4. Styling for the custom checkbox */
/* This uses a modern CSS property to style the native checkbox to match the dark theme. */
.styled-checkbox {
    /* This is the key property. It colors the checkmark and highlight with our app's primary purple. */
    accent-color: var(--primary-color);

    /* Appearance and Sizing */
    -webkit-appearance: none;
    appearance: none;
    margin: 0;
    width: 18px;
    height: 18px;
    cursor: pointer;

    /* Styling for the UNCHECKED state */
    background-color: var(--bg-color); /* Matches the app's darkest background */
    border: 1px solid var(--border-color); /* Matches other borders */
    border-radius: 4px; /* Slightly rounded corners */

    /* Positioning and layout */
    position: relative;
    display: grid;
    place-content: center;
}

/* Styling for the CHECKMARK itself (a pseudo-element) */
.styled-checkbox::before {
    content: '';
    width: 10px;
    height: 10px;
    transform: scale(0); /* Hidden by default */
    transition: 120ms transform ease-in-out;
    box-shadow: inset 1em 1em var(--primary-color);
    
    /* Creates the checkmark shape */
    transform-origin: bottom left;
    clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
}

/* Styling for the CHECKED state */
.styled-checkbox:checked::before {
    transform: scale(1); /* Makes the checkmark visible when checked */
}

      /* --- CSS for the Chart Data Table --- */

/* 1. Styling for the scrollable container holding the table. */
/* This creates a defined, bordered area that will scroll if the content is too tall. */
#chartDataTableContainer div[style*="overflow-y: auto"] {
    border-radius: 4px;
    border: 1px solid var(--border-color);
}

/* 2. Basic table setup for clean lines and full width. */
#chartDataTable {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9em;
}

/* 3. Table Header (thead) styling. */
/* The "position: sticky" is the key feature that makes the header stay at the top when you scroll. */
#chartDataTable thead {
    position: sticky;
    top: 0;
    /* The background must match the panel color to hide scrolling content underneath. */
    background: var(--surface-color);
}

/* 4. Table Header Cells (th) styling. */
/* This makes the headers look distinct from the data. */
#chartDataTable th {
    font-weight: 600;
    color: var(--text-color-muted);
    text-align: left;
    padding: 8px 12px;
    border-bottom: 2px solid var(--border-color); /* A slightly thicker border for emphasis */
}

/* 5. Table Body Cells (td) styling. */
/* This ensures data is clean and readable. */
#chartDataTable td {
    padding: 8px 12px;
    border-bottom: 1px solid var(--border-color);
    color: var(--text-color);
    /* This helps with long numbers, but you can remove it if you prefer wrapping */
    white-space: nowrap;
}

/* 6. Hover effect for table rows (tbody tr). */
/* Provides visual feedback to the user as they move their mouse over the data. */
#chartDataTable tbody tr:hover {
    background-color: rgba(255, 255, 255, 0.05); /* A subtle highlight */
}

/* 7. Remove the bottom border from the very last row in the table for a cleaner look. */
#chartDataTable tbody tr:last-child td {
    border-bottom: none;
}

/* 8. Custom Scrollbar Styling (for WebKit browsers like Chrome, Edge, Safari). */
/* This makes the scrollbar match the dark theme instead of using the default bright white one. */
#chartDataTableContainer div[style*="overflow-y: auto"]::-webkit-scrollbar {
    width: 8px;
}

#chartDataTableContainer div[style*="overflow-y: auto"]::-webkit-scrollbar-track {
    background: var(--surface-color); /* The background of the scrollbar track */
}

#chartDataTableContainer div[style*="overflow-y: auto"]::-webkit-scrollbar-thumb {
    background-color: #555; /* The color of the scrollbar itself */
    border-radius: 6px;
    border: 2px solid var(--surface-color); /* Creates a nice padding effect */
}

#chartDataTableContainer div[style*="overflow-y: auto"]::-webkit-scrollbar-thumb:hover {
    background-color: #777; /* A lighter color when you hover over the scrollbar */
}

      /* --- CSS for the Modernized ROI Info Modal --- */

/* 1. Main flex container for the two-column layout */
.info-modal-body {
    display: flex;
    align-items: flex-start; /* Aligns items to the top */
    gap: 20px; /* Space between the thumbnail and the data table */
}

/* 2. Container for the thumbnail preview on the left */
.info-modal-preview {
    flex-shrink: 0; /* Prevents the image from shrinking */
    width: 128px;
}

/* 3. The thumbnail image itself */
.info-modal-preview img {
    width: 100%;
    height: 128px;
    object-fit: cover; /* Ensures the image fills the space nicely */
    border-radius: 6px;
    border: 1px solid var(--border-color);
    image-rendering: pixelated; /* Keeps pixel art sharp */
    background-color: #000; /* Background for transparent parts (e.g., circle mask) */
}

/* 4. Container for the data on the right */
.info-modal-details {
    flex-grow: 1; /* Allows the data section to take up the remaining space */
    display: flex;
    flex-direction: column;
    gap: 12px; /* Space between each data row */
}

/* 5. Styling for each individual data row (e.g., "Name: Sample 1") */
.info-data-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
    font-size: 0.95em;
}

/* Remove border from the last row for a cleaner look */
.info-data-row:last-child {
    border-bottom: none;
    padding-bottom: 0;
}

/* 6. Styling for the label/key part of the row (e.g., "Name:") */
.info-data-row .label {
    color: var(--text-color-muted);
    font-weight: 500;
}

/* 7. Styling for the value part of the row (e.g., "Sample 1") */
.info-data-row .value {
    color: var(--text-color);
    font-weight: 400;
    text-align: right;
}

/* 8. Specific styling for the color swatch in the "Avg RGB" row */
.info-color-swatch {
    display: inline-block;
    width: 16px;
    height: 16px;
    border-radius: 4px;
    border: 1px solid #fff;
    vertical-align: middle;
    margin-right: 8px;
}

      /* 9. Container for the entire histogram section */
.info-histogram-container {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid var(--border-color);
}

/* 10. Container for the top-level (data source) toggle buttons */
.histogram-data-source {
    margin-bottom: 10px;
    padding-bottom: 10px;
    border-bottom: 1px dashed var(--border-color); /* Dashed border to separate controls */
    font-size: 0.9em;
    text-align: center;
}

/* 11. Container for the bottom-level (chart type) toggle buttons */
.histogram-controls {
    display: flex;
    justify-content: center;
    margin-bottom: 15px;
}

/* 12. The canvas for the chart itself */
#roiHistogramCanvas {
    max-height: 200px;
    width: 100%;
}

      /* --- CSS for the Live Measurement Spinner --- */
.spinner-icon {
    display: inline-block;
    animation: spin 1.5s linear infinite;
}

@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}
/* --- CSS for the Image Manipulation Section --- */

/* --- CSS for the Image Manipulation Section (Compact & Refined) --- */

/* 1. Main container for each setting row. Reduced vertical padding for a tighter layout. */


/* 2. Container for a slider and its number input. Tighter spacing. */
.slider-control {
    display: flex;
    align-items: center;
    gap: 8px; /* Reduced from 10px to bring elements closer */
}

/* 3. The number input next to a slider. Made significantly more compact. */
.slider-input {
    width: 30px; /* Reduced from 60px */
    padding: 2px 4px; /* Reduced padding for a smaller vertical profile */
    font-size: 0.8em; /* Smaller font for a more subtle look */
    text-align: center;
    background-color: #000; /* Darker background to blend in more */
    -moz-appearance: textfield; /* Hides arrows in Firefox */
}
/* Hides arrows in Chrome/Safari/Edge */
.slider-input::-webkit-outer-spin-button,
.slider-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

/* 4. General styling for the sliders (unchanged, but included for completeness) */
.styled-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 8px;
    background: var(--bg-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    outline: none;
    cursor: pointer;
}

/* 5. Styling for the slider's "thumb" or handle (unchanged) */
.styled-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: var(--primary-color);
    border-radius: 50%;
    border: 2px solid var(--surface-color);
    box-shadow: 0 0 2px rgba(0,0,0,0.5);
    transition: background-color 0.2s;
}
.styled-slider::-webkit-slider-thumb:hover {
    background: var(--secondary-color);
}

/* Styling for Firefox thumb (unchanged) */
.styled-slider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: var(--primary-color);
    border-radius: 50%;
    border: 1px solid var(--surface-color);
    box-shadow: 0 0 2px rgba(0,0,0,0.5);
    transition: background-color 0.2s;
}
.styled-slider::-moz-range-thumb:hover {
    background: var(--secondary-color);
}
    </style>
  </head>

  <body>
    <div class="app-container">
      <header class="app-header"><div style="text-align:center; width:100%;">
  <a href="https://enscygen.web.app/ORT/imagetools/imagespec-launcher" style="display:inline-block;">
    <img src="https://enscygen.web.app/assets/brand/imagespec-logo.png" 
         alt="Enscygen ImageSpec Pro" 
         style="max-width:200px; width:100%; height:auto; display:inline-block; border:none;">
  </a>
</div></header>
      <aside class="panel controls-panel">
        <section class="collapsible open">
          <div class="collapsible-header">
            <h3 class="panel-title"><i class="bi bi-camera"></i> Source</h3>
            <i class="bi bi-chevron-up collapse-icon"></i>
          </div>
          <div class="collapsible-content">
            <div class="form-group">
              <div class="radio-group">
                <input
                  type="radio"
                  id="sourceUpload"
                  name="source"
                  value="upload"
                  checked
                />
                <label for="sourceUpload"
                  ><i class="bi bi-upload"></i> Upload</label
                >
                <input
                  type="radio"
                  id="sourceCamera"
                  name="source"
                  value="camera"
                />
                <label for="sourceCamera"
                  ><i class="bi bi-camera-video"></i> Camera</label
                >
              </div>
              <input
                type="file"
                id="imageLoader"
                accept="image/*"
                style="display: none;"
              />
              <button id="uploadButton" class="button-secondary">
                Select Image
              </button>
            </div>
          </div>
        </section>
        <section class="collapsible open">
          <div class="collapsible-header">
            <h3 class="panel-title">
              <i class="bi bi-plus-circle-dotted"></i> ROI Selection
            </h3>
            <i class="bi bi-chevron-up collapse-icon"></i>
          </div>
          <div class="collapsible-content">
            <div class="form-group">
              <label>ROI Type</label>
              <div class="radio-group">
                <input
                  type="radio"
                  id="roiTypeBlank"
                  name="roiType"
                  value="blank"
                />
                <label for="roiTypeBlank">Blank</label>
                <input
                  type="radio"
                  id="roiTypeSample"
                  name="roiType"
                  value="sample"
                  checked
                />
                <label for="roiTypeSample">Sample</label>
              </div>
            </div>
            <div class="form-group">
              <label for="roiShape">Shape</label>
              <select id="roiShape">
                <option value="square">Square</option>
                <option value="circle">Circle</option>
                <option value="pixel">Pixel</option>
              </select>
            </div>
            <div class="form-group">
              <label for="roiSize">Size (px)</label>
              <input type="number" id="roiSize" value="20" min="1" max="500" />
            </div>
            <div class="form-group">
              <label for="roiName">Name (Optional)</label>
              <input
                type="text"
                id="roiName"
                placeholder="Auto (e.g., Sample 1)"
              />
            </div>
            <small style="color:var(--text-color-muted); text-align:center;"
              >Click on the image to place an ROI.</small
            >
          </div>
        </section>
        <section class="collapsible open">
          <div class="collapsible-header">
            <h3 class="panel-title">
              <i class="bi bi-spectrometer"></i> Wavelengths (nm)
            </h3>
            <i class="bi bi-chevron-up collapse-icon"></i>
          </div>
          <div class="collapsible-content">
            <div class="form-group">
              <div class="input-row">
                <input
                  type="number"
                  id="wavelengthInput"
                  placeholder="e.g., 540"
                  min="380"
                  max="780"
                />
                <button id="addWavelengthBtn">Add</button>
              </div>
            </div>
            <ul id="wavelengthList"></ul>
          </div>
        </section>
      </aside>
      <main class="canvas-container">
        <video id="videoFeed" autoplay playsinline></video>
        <canvas id="mainCanvas"></canvas> <canvas id="roiCanvas"></canvas>
        <p id="canvas-placeholder" style="color:var(--text-color-muted);">
          Upload an image or start the camera
        </p>
      </main>
      <aside class="panel data-panel">
        <section class="collapsible open">
          <div class="collapsible-header">
            <h3 class="panel-title">
              <i class="bi bi-graph-up"></i> Live Absorbance
            </h3>
            <i class="bi bi-chevron-up collapse-icon"></i>
          </div>
          <div class="collapsible-content" style="justify-content: center;">
            <div id="liveAbsorbanceLabel"></div>
            <div id="liveAbsorbanceValue">-</div>
            <small
              style="color:var(--text-color-muted); text-align:center;"
              id="liveAbsorbanceInfo"
              >No Blank ROI set</small
            >
          </div>
        </section>
        <section class="collapsible open">
          <div class="collapsible-header">
            <h3 class="panel-title">
              <i class="bi bi-gear"></i> Measurement Mode
            </h3>
            <i class="bi bi-chevron-up collapse-icon"></i>
          </div>
          <div class="collapsible-content">
            <div class="form-group">
              <select id="measurementMode">
                <option value="static">Static Absorbance at Point</option>
                <option value="series">Series Wavelength Scan</option>
                <option value="time">Absorbance at Time Points</option>
              </select>
            </div>
            <div
              id="series-scan-options"
              class="form-group"
              style="display:none;"
            >
              <label>Wavelength Range (nm)</label>
              <div class="input-row">
                <input
                  type="number"
                  id="seriesStart"
                  placeholder="Start"
                  value="400"
                />
                <input
                  type="number"
                  id="seriesEnd"
                  placeholder="End"
                  value="700"
                />
              </div>
              <input
                type="number"
                id="seriesStep"
                placeholder="Step"
                value="10"
              />
            </div>
            <div
              id="time-series-options"
              class="form-group"
              style="display:none;"
            >
              <label>Time Points (seconds, comma-separated)</label>
              <input
                type="text"
                id="timePoints"
                placeholder="e.g. 0, 30, 60, 120"
                value="0, 5, 10"
              />
            </div>
            <button id="startMeasurementBtn">Start Measurement</button>
            <small id="timeSeriesCountdown" style="display: none; text-align: center; color: var(--text-color-muted); margin-top: 8px;"></small>
          </div>
        </section>

        
<section class="collapsible open">
    <div class="collapsible-header">
        <h3 class="panel-title"><i class="bi bi-toggles"></i> ImageSpec Settings</h3>
        <i class="bi bi-chevron-up collapse-icon"></i>
    </div>
    <div class="collapsible-content">
       <!-- Add these to the "ImageSpec Settings" collapsible-content -->
<div class="setting-row">
    <label for="stabilityThreshold">Stability Threshold (± Abs)</label>
    <input type="number" id="stabilityThreshold" class="slider-input" value="0.005" step="0.001">
</div>
<div class="setting-row">
    <label for="stabilityTime">Stability Time (s)</label>
    <input type="number" id="stabilityTime" class="slider-input" value="2">
</div>
<div class="setting-row">
    <label for="stabilityAverageCheck">Average Final Reading</label>
    <input type="checkbox" id="stabilityAverageCheck" class="styled-checkbox" checked>
</div>
<div class="setting-row">
    <label for="hideCapturedCheck" title="If checked, any ROI that is 'Captured & Locked' will be hidden from the image canvas.">Hide Captured ROI from image</label>
    <input type="checkbox" id="hideCapturedCheck" class="styled-checkbox" checked>
</div>

    </div>
</section>

        <!-- Insert this new section after "ImageSpec Settings" -->
<section class="collapsible open">
    <div class="collapsible-header">
        <h3 class="panel-title"><i class="bi bi-sliders"></i> Image Manipulation</h3>
        <i class="bi bi-chevron-up collapse-icon"></i>
    </div>
    <div class="collapsible-content">
        <!-- Brightness Control -->
        <div class="setting-row">
            <label for="brightnessSlider">Brightness</label>
            <div class="slider-control">
                <input type="range" id="brightnessSlider" class="styled-slider" min="0" max="200" value="100">
                <input type="number" id="brightnessInput" class="slider-input" min="0" max="200" value="100">
            </div>
        </div>
        <!-- Contrast Control -->
        <div class="setting-row">
            <label for="contrastSlider">Contrast</label>
            <div class="slider-control">
                <input type="range" id="contrastSlider" class="styled-slider" min="0" max="200" value="100">
                <input type="number" id="contrastInput" class="slider-input" min="0" max="200" value="100">
            </div>
        </div>
        <!-- Grayscale Control -->
        <div class="setting-row">
            <label for="grayscaleCheck">Grayscale</label>
            <input type="checkbox" id="grayscaleCheck" class="styled-checkbox">
        </div>
        <!-- Revert Button -->
        <button id="revertFiltersBtn" class="button-secondary" style="margin-top: 10px;">Revert to Original</button>
    </div>
</section>



<div id="settingsInfoModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="settingsInfoTitle">Setting Information</h2>
            <button class="close-button">&times;</button>
        </div>
        <p id="settingsInfoContent" style="line-height: 1.6;"></p>
    </div>
</div>

      </aside>
      <footer class="panel results-panel">
        <section class="collapsible open">
          <div class="collapsible-header">
            <h3 class="panel-title">
              <i class="bi bi-table"></i> ROI Data
              <!-- Add this new button -->
              <button
                id="downloadCsvBtn"
                class="icon-button"
                title="Download as CSV"
                style="margin-left: auto;"
              >
                <i class="bi bi-download"></i>
              </button>
              <button
    id="chartAllBtn"
    class="icon-button"
    title="Chart All Samples"
>
    <i class="bi bi-graph-up-arrow"></i>
              </button>
            </h3>
            <i class="bi bi-chevron-up collapse-icon"></i>
          </div>

          <div class="collapsible-content">
            <div style="overflow-x: auto; width: 100%;">
              <table id="resultsTable">
                <thead>
                  <tr>
                    <th></th>
                    <th>Name</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </section>
      </footer>
    </div>
    <div id="roiEditModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>Edit ROI</h2>
          <button class="close-button">&times;</button>
        </div>
        <div class="form-group">
          <label for="editRoiName">Name</label>
          <input type="text" id="editRoiName" />
        </div>
        <div class="form-group">
          <label for="editRoiShape">Shape</label>
          <select id="editRoiShape">
            <option value="square">Square</option>
            <option value="circle">Circle</option>
            <option value="pixel">Pixel</option>
          </select>
        </div>
        <div class="form-group">
          <label for="editRoiSize">Size</label>
          <input type="number" id="editRoiSize" min="1" />
        </div>
        <div class="form-group">
          <label for="editRoiColor">Border Color</label>
          <input
            type="color"
            id="editRoiColor"
            style="width:100%; height: 40px; padding: 0;"
          />
        </div>
        <button id="saveRoiChangesBtn" style="margin-top: 20px;">
          Save Changes
        </button>
      </div>
    </div>
    <div id="roiInfoModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>ROI Information</h2>
          <button class="close-button">&times;</button>
        </div>
        <div id="roiInfoContent"></div>
      </div>
    </div>
    <div id="chartModal" class="modal">
      <div class="modal-content" style="max-width: 800px;">
        <div class="modal-header">
          <h2 id="chartTitle">Measurement Chart</h2>
          <button class="close-button">&times;</button>
        </div>
        <canvas id="measurementChart"></canvas>
      
<div id="chartDataTableContainer" style="display: none; margin-top: 20px;">
    <div style="display: flex; justify-content: flex-end; margin-bottom: 10px;">
        <button id="downloadChartCsvBtn" class="icon-button" title="Download Chart Data as CSV">
            <i class="bi bi-download"></i>
        </button>
    </div>
    <div style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 4px;">
        <table id="chartDataTable" style="width: 100%; border-collapse: collapse;">
            <thead style="position: sticky; top: 0; background: var(--surface-color);"></thead>
            <tbody></tbody>
        </table>
    </div>
</div>



        
      </div>
    </div>

    <!-- Master Chart Modal for All Samples -->
<div id="masterChartModal" class="modal">
    <div class="modal-content" style="max-width: 90vw; max-height: 90vh; display: flex; flex-direction: column;">
        <div class="modal-header">
            <h2 id="masterChartTitle">All Samples Chart</h2>
            <button class="close-button">&times;</button>
        </div>
        
        <!-- Controls for the Master Chart -->
        <div id="master-chart-controls" style="display: flex; gap: 20px; padding: 10px 0; align-items: center;">
            <div class="form-group">
                <label for="masterChartDataType">Data Source:</label>
                <select id="masterChartDataType"></select>
            </div>
            <div class="form-group">
                <label>Chart Type:</label>
                <div class="radio-group" id="masterChartTypeToggle">
                    <input type="radio" id="chartTypeLine" name="masterChartType" value="line" checked>
                    <label for="chartTypeLine"><i class="bi bi-graph-up"></i> Line</label>
                    <input type="radio" id="chartTypeBar" name="masterChartType" value="bar">
                    <label for="chartTypeBar"><i class="bi bi-bar-chart-line"></i> Bar</label>
                </div>
            </div>
          <div class="form-group" id="masterChartWavelengthControl" style="display: none;">
    <label for="masterChartWavelengthSelect">Wavelength:</label>
    <select id="masterChartWavelengthSelect"></select>
          </div>

          <div class="form-group">
    <label for="masterChartHeightInput">Chart Height (px):</label>
    <input type="number" id="masterChartHeightInput" class="slider-input" value="300" min="150" step="50">
          </div>
        </div>

        <!-- Chart and Table Container -->
        <div style="flex-grow: 1; min-height: 0; display: flex; flex-direction: column; gap: 10px;">
            <div id="masterChartCanvasContainer" style="flex: 1; min-height: 0; position: relative; height: 300px;">
                 <canvas id="masterChartCanvas"></canvas>
            </div>
            <!-- We will add a data table here later if needed, following the same pattern -->
        </div>
    </div>
</div>

    <!-- The Main Capture Modal -->
<div id="captureModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="captureModalTitle">Capture & Lock ROI Data</h2>
            <button class="close-button">&times;</button>
        </div>
        <p id="captureModalText" style="line-height: 1.6;"></p>
        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
            <button id="captureStableBtn" class="button-secondary">Capture at Stable Reading</button>
            <button id="captureNowBtn">Capture Immediately</button>
        </div>
    </div>
</div>

<!-- The Release Confirmation Modal -->
<div id="releaseModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="releaseModalTitle">Release ROI?</h2>
            <button class="close-button">&times;</button>
        </div>
        <p id="releaseModalText"></p>
        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
            <button id="releaseCancelBtn" class="button-secondary">Cancel</button>
            <button id="releaseConfirmBtn" style="background-color: var(--error-color);">Confirm Release</button>
        </div>
    </div>
</div>


    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const imageLoader = document.getElementById("imageLoader");
        const uploadButton = document.getElementById("uploadButton");
        const mainCanvas = document.getElementById("mainCanvas");
        const roiCanvas = document.getElementById("roiCanvas");
        const videoFeed = document.getElementById("videoFeed");
        const canvasPlaceholder = document.getElementById("canvas-placeholder");
        const mainCtx = mainCanvas.getContext("2d", {
          willReadFrequently: true,
        });
        const roiCtx = roiCanvas.getContext("2d");
        const sourceRadios = document.querySelectorAll('input[name="source"]');
        const wavelengthInput = document.getElementById("wavelengthInput");
        const addWavelengthBtn = document.getElementById("addWavelengthBtn");
        const wavelengthList = document.getElementById("wavelengthList");
        const roiTypeRadios = document.querySelectorAll(
          'input[name="roiType"]'
        );
        const roiShapeSelect = document.getElementById("roiShape");
        const roiSizeInput = document.getElementById("roiSize");
        const roiNameInput = document.getElementById("roiName");
        const liveAbsorbanceValue = document.getElementById(
          "liveAbsorbanceValue"
        );
        const liveAbsorbanceLabel = document.getElementById(
          "liveAbsorbanceLabel"
        );
        const liveAbsorbanceInfo =
          document.getElementById("liveAbsorbanceInfo");
        const measurementModeSelect =
          document.getElementById("measurementMode");
        const seriesScanOptions = document.getElementById(
          "series-scan-options"
        );
        const timeSeriesOptions = document.getElementById(
          "time-series-options"
        );
        const startMeasurementBtn = document.getElementById(
          "startMeasurementBtn"
        );
        const resultsTableBody = document.querySelector("#resultsTable tbody");
        const resultsTableHead = document.querySelector(
          "#resultsTable thead tr"
        );
        const roiEditModal = document.getElementById("roiEditModal");
        const roiInfoModal = document.getElementById("roiInfoModal");
        const chartModal = document.getElementById("chartModal");
        const saveRoiChangesBtn = document.getElementById("saveRoiChangesBtn");
        const editRoiName = document.getElementById("editRoiName");
        const editRoiShape = document.getElementById("editRoiShape");
        const editRoiSize = document.getElementById("editRoiSize");
        const editRoiColor = document.getElementById("editRoiColor");
        const downloadCsvBtn = document.getElementById("downloadCsvBtn");
        const chartDataTableContainer = document.getElementById('chartDataTableContainer');
const chartDataTable = document.getElementById('chartDataTable');
const downloadChartCsvBtn = document.getElementById('downloadChartCsvBtn');
        const chartAllBtn = document.getElementById('chartAllBtn');
const masterChartModal = document.getElementById('masterChartModal');
const masterChartDataType = document.getElementById('masterChartDataType');
const masterChartTypeToggle = document.getElementById('masterChartTypeToggle');
        const brightnessSlider = document.getElementById('brightnessSlider');
const brightnessInput = document.getElementById('brightnessInput');
const contrastSlider = document.getElementById('contrastSlider');
const contrastInput = document.getElementById('contrastInput');
const grayscaleCheck = document.getElementById('grayscaleCheck');
const revertFiltersBtn = document.getElementById('revertFiltersBtn');
        const masterChartWavelengthControl = document.getElementById('masterChartWavelengthControl');
const masterChartWavelengthSelect = document.getElementById('masterChartWavelengthSelect');
        const masterChartHeightInput = document.getElementById('masterChartHeightInput');
const masterChartCanvasContainer = document.getElementById('masterChartCanvasContainer');


        // Add these new constants with your other element references

// --- References for New Modals ---
const captureModal = document.getElementById('captureModal');
const releaseModal = document.getElementById('releaseModal');

// --- References for Buttons inside the Capture Modal ---
const captureNowBtn = document.getElementById('captureNowBtn');
const captureStableBtn = document.getElementById('captureStableBtn');

// --- References for Buttons inside the Release Modal ---
const releaseConfirmBtn = document.getElementById('releaseConfirmBtn');
const releaseCancelBtn = document.getElementById('releaseCancelBtn');

          

// --- References for New Stability Settings ---
const stabilityThresholdInput = document.getElementById('stabilityThreshold');
const stabilityTimeInput = document.getElementById('stabilityTime');
const stabilityAverageCheck = document.getElementById('stabilityAverageCheck');

        const hideCapturedCheck = document.getElementById('hideCapturedCheck');

        // Add this with your other const declarations at the top of the script

const timeSeriesCountdown = document.getElementById('timeSeriesCountdown');




        

const settingsInfoModal = document.getElementById('settingsInfoModal');
const settingsInfoTitle = document.getElementById('settingsInfoTitle');
const settingsInfoContent = document.getElementById('settingsInfoContent');

        let currentlyEditingRoiId = null;
        let currentChartDataForCSV = null;

        let appState = {
          sourceType: "upload",
          rois: [],
          wavelengths: [540],
          blankRoiId: null,
          nextSampleId: 1,
          isDragging: false,
          draggedRoi: null,
          dragOffsetX: 0,
          dragOffsetY: 0,
          videoStream: null,
          measurementChart: null,
          isMeasuring: false,
  referenceSnapshots: {},
    stabilitySettings: {
        threshold: 0.005,
        time: 2,
        useAverage: true
    },
          liveAbsorbanceIndex: 0,
          liveAbsorbanceInterval: null,
          selectedRoiId: null,
          masterChart: null,
          hideCapturedRois: true,
          originalImageData: null, // This will store the raw pixel data of the original image
    imageFilters: {
        brightness: 100,
        contrast: 100,
        grayscale: false,
    },
          roiHistogramChart: null
        };

        async function waitForStableReading(roi) {
    return new Promise((resolve, reject) => {
        const { threshold, time, useAverage } = appState.stabilitySettings;
        const checkInterval = 250; // Check 4 times per second
        const requiredStableChecks = (time * 1000) / checkInterval;
        const maxWaitTime = 30000; // 30 second timeout to prevent infinite loops

        let readingHistory = [];
        let stableCounter = 0;

        const timeout = setTimeout(() => {
            clearInterval(interval);
            reject(new Error("Reading did not stabilize within 30 seconds."));
        }, maxWaitTime);

        const interval = setInterval(() => {
            // Force a single frame draw and calculation
            mainCtx.drawImage(videoFeed, 0, 0, mainCanvas.width, mainCanvas.height);
            calculateAllAbsorbances();
            
            const currentAbsorbance = roi.absorbance[appState.wavelengths[0]] || 0;
            readingHistory.push(parseFloat(currentAbsorbance));
            if (readingHistory.length < 2) return; // Need at least two readings to compare

            const lastReading = readingHistory[readingHistory.length - 2];
            if (Math.abs(currentAbsorbance - lastReading) < threshold) {
                stableCounter++;
            } else {
                stableCounter = 0; // Reset counter if it fluctuates
            }

            if (stableCounter >= requiredStableChecks) {
                clearInterval(interval);
                clearTimeout(timeout);
                let finalReadingRoi = roi;
                if (useAverage) {
                    // Create a temporary copy to not mutate the live ROI
                    const finalRoiState = JSON.parse(JSON.stringify(roi));
                    const stableReadings = readingHistory.slice(-requiredStableChecks);
                    const avgAbs = stableReadings.reduce((a, b) => a + b, 0) / stableReadings.length;
                    finalRoiState.absorbance[appState.wavelengths[0]] = avgAbs.toFixed(3);
                    finalReadingRoi = finalRoiState;
                }
                resolve(finalReadingRoi);
            }
        }, checkInterval);
    });
}

        
function createRoiSnapshot(roi) {
    if (!roi) return null;

    const avgColor = getRoiAverageColor(roi);
    if (!avgColor) return null;

    // Create the thumbnail image data
    let thumbnailDataUrl = '';
    try {
        const size = roi.shape === 'pixel' ? 5 : roi.size;
        const halfSize = Math.floor(size / 2);
        const thumbCanvas = document.createElement('canvas');
        thumbCanvas.width = size;
        thumbCanvas.height = size;
        const thumbCtx = thumbCanvas.getContext('2d');
        const imageData = mainCtx.getImageData(roi.x - halfSize, roi.y - halfSize, size, size);
        thumbCtx.putImageData(imageData, 0, 0);

        if (roi.shape === 'circle') {
            thumbCtx.globalCompositeOperation = 'destination-in';
            thumbCtx.beginPath();
            thumbCtx.arc(halfSize, halfSize, halfSize, 0, Math.PI * 2);
            thumbCtx.fill();
        }
        thumbnailDataUrl = thumbCanvas.toDataURL();
    } catch (e) {
        console.error("Could not create thumbnail snapshot:", e);
    }

    return {
        id: roi.id,
        name: roi.name,
        avgColor: avgColor,
        pixelCount: avgColor.count,
        thumbnailDataUrl: thumbnailDataUrl
    };
}

        
        function wavelengthToRgb(lambda) {
          let r, g, b;
          if (lambda >= 380 && lambda <= 439) {
            r = -(lambda - 440) / (440 - 380);
            g = 0.0;
            b = 1.0;
          } else if (lambda >= 440 && lambda <= 489) {
            r = 0.0;
            g = (lambda - 440) / (490 - 440);
            b = 1.0;
          } else if (lambda >= 490 && lambda <= 509) {
            r = 0.0;
            g = 1.0;
            b = -(lambda - 510) / (510 - 490);
          } else if (lambda >= 510 && lambda <= 579) {
            r = (lambda - 510) / (580 - 510);
            g = 1.0;
            b = 0.0;
          } else if (lambda >= 580 && lambda <= 644) {
            r = 1.0;
            g = -(lambda - 645) / (645 - 580);
            b = 0.0;
          } else if (lambda >= 645 && lambda <= 780) {
            r = 1.0;
            g = 0.0;
            b = 0.0;
          } else {
            r = 0.0;
            g = 0.0;
            b = 0.0;
          }
          let factor;
          if (lambda >= 380 && lambda <= 419) {
            factor = 0.3 + (0.7 * (lambda - 380)) / (420 - 380);
          } else if (lambda >= 420 && lambda <= 700) {
            factor = 1.0;
          } else if (lambda >= 701 && lambda <= 780) {
            factor = 0.3 + (0.7 * (780 - lambda)) / (780 - 700);
          } else {
            factor = 0.0;
          }
          const gamma = 0.8;
          const adjust = (color) =>
            Math.round(255 * Math.pow(color * factor, gamma));
          return { r: adjust(r), g: adjust(g), b: adjust(b) };
        }
        function getRoiAverageColor(roi) {
          if (!mainCanvas.width || !mainCanvas.height) return null;
          const size = roi.shape === "pixel" ? 1 : roi.size;
          const halfSize = size / 2;
          const startX = Math.round(roi.x - halfSize);
          const startY = Math.round(roi.y - halfSize);
          if (
            startX + size < 0 ||
            startX > mainCanvas.width ||
            startY + size < 0 ||
            startY > mainCanvas.height
          )
            return null;
          const imageData = mainCtx.getImageData(
            Math.max(0, startX),
            Math.max(0, startY),
            Math.min(size, mainCanvas.width - startX),
            Math.min(size, mainCanvas.height - startY)
          );
          const data = imageData.data;
          let r = 0,
            g = 0,
            b = 0,
            count = 0;
          for (let i = 0; i < data.length; i += 4) {
            const pixelX = Math.max(0, startX) + ((i / 4) % imageData.width);
            const pixelY =
              Math.max(0, startY) + Math.floor(i / 4 / imageData.width);
            let inShape = false;
            if (roi.shape === "square" || roi.shape === "pixel") {
              inShape = true;
            } else if (roi.shape === "circle") {
              const dx = pixelX - roi.x;
              const dy = pixelY - roi.y;
              if (dx * dx + dy * dy <= halfSize * halfSize) inShape = true;
            }
            if (inShape) {
              r += data[i];
              g += data[i + 1];
              b += data[i + 2];
              count++;
            }
          }
          if (count === 0) return { r: 0, g: 0, b: 0, count: 0 };
          return { r: r / count, g: g / count, b: b / count, count };
        }
        function getWavelengthChannelWeights(wl) {
          const bluePeak = 450,
            greenPeak = 540,
            redPeak = 620;
          const blueSpread = 60,
            greenSpread = 70,
            redSpread = 60;
          const gaussian = (x, peak, spread) =>
            Math.exp(-((x - peak) ** 2) / (2 * spread ** 2));
          let bWeight = gaussian(wl, bluePeak, blueSpread);
          let gWeight = gaussian(wl, greenPeak, greenSpread);
          let rWeight = gaussian(wl, redPeak, redSpread);
          const totalWeight = bWeight + gWeight + rWeight;
          if (totalWeight === 0) return { r: 0, g: 0, b: 0 };
          return {
            r: rWeight / totalWeight,
            g: gWeight / totalWeight,
            b: bWeight / totalWeight,
          };
        }

        
        function calculateAllAbsorbances() {
    // Determine the correct blank color (from snapshot or live)
    const blankSnapshot = appState.referenceSnapshots[appState.blankRoiId];
    const blankColor = blankSnapshot ? blankSnapshot.avgColor : getRoiAverageColor(appState.rois.find(r => r.id === appState.blankRoiId));
    const blankRoi = appState.rois.find(r => r.id === appState.blankRoiId);

    // Validate that a blank exists and has color data
    if (!blankRoi || !blankColor) {
        liveAbsorbanceInfo.textContent = "No Blank ROI set";
        appState.rois.filter(r => r.type === 'sample').forEach(sampleRoi => { sampleRoi.absorbance = {}; });
        updateResultsTable();
        updateLiveAbsorbanceDisplay();
        return;
    }

    liveAbsorbanceInfo.textContent = `Blank: ${blankRoi.name}`;

    // Process all ROIs
    appState.rois.forEach(roi => {
        const snapshot = appState.referenceSnapshots[roi.id];
        
        // If the ROI is a reference, restore its stored absorbance data.
        if (snapshot) {
            roi.absorbance = { ...snapshot.absorbance };
        // If it's a live ROI (Blank or Sample), perform a live calculation.
        } else if (roi.type === 'sample' || roi.type === 'blank') {
            const sampleColor = getRoiAverageColor(roi);
            if (!sampleColor) { roi.absorbance = {}; return; }
            
            appState.wavelengths.forEach(wl => {
                const weights = getWavelengthChannelWeights(wl);
                const blankIntensity = weights.r * blankColor.r + weights.g * blankColor.g + weights.b * blankColor.b;
                const sampleIntensity = weights.r * sampleColor.r + weights.g * sampleColor.g + weights.b * sampleColor.b;
                if (blankIntensity > 0 && sampleIntensity > 0) {
                    roi.absorbance[wl] = -Math.log10(sampleIntensity / blankIntensity).toFixed(3);
                } else {
                    roi.absorbance[wl] = 'inf';
                }
            });
        }
    });

    // Refresh the UI with the final, correct data
    updateResultsTable();
          updateLiveAbsorbanceDisplay();
    
}



// ADD THIS NEW HELPER FUNCTION SOMEWHERE NEAR THE TOP OF YOUR SCRIPT
function resetLiveAbsorbanceTimer() {
    // Clear the old timer
    if (appState.liveAbsorbanceInterval) {
        clearInterval(appState.liveAbsorbanceInterval);
    }
    // Start a new one
    appState.liveAbsorbanceInterval = setInterval(() => {
        if (appState.wavelengths.length > 1) { // Only cycle if there's more than one
            appState.liveAbsorbanceIndex = (appState.liveAbsorbanceIndex + 1) % appState.wavelengths.length;
        }
        liveAbsorbanceValue.style.opacity = 0;
        setTimeout(() => {
            updateLiveAbsorbanceDisplay(false); // Call without resetting timer again
            liveAbsorbanceValue.style.opacity = 1;
        }, 300);
    }, 2500);
}



        
        function updateLiveAbsorbanceDisplay(shouldResetTimer = true) { // Add a parameter
    if (shouldResetTimer) {
        resetLiveAbsorbanceTimer();
    }
    let targetRoi = null;

          // Priority 1: Find the user-selected ROI
          if (appState.selectedRoiId) {
            targetRoi = appState.rois.find(
              (r) => r.id === appState.selectedRoiId
            );
          }

          // Priority 2: If no selection, find the last added sample ROI
          if (!targetRoi) {
            const samples = appState.rois.filter((r) => r.type === "sample");
            if (samples.length > 0) {
              targetRoi = samples[samples.length - 1];
            }
          }

          const blankRoi = appState.rois.find(
            (r) => r.id === appState.blankRoiId
          );

          // Now, update the display based on the targetRoi we found
          if (targetRoi && blankRoi && appState.wavelengths.length > 0) {
            if (appState.liveAbsorbanceIndex >= appState.wavelengths.length) {
              appState.liveAbsorbanceIndex = 0;
            }

            const wl = appState.wavelengths[appState.liveAbsorbanceIndex];
            const absorbance = targetRoi.absorbance[wl];
            const rgb = wavelengthToRgb(wl);

            // Update text content and apply the matching color
            liveAbsorbanceLabel.textContent = `${targetRoi.name} @ ${wl} nm`;
            liveAbsorbanceValue.textContent = absorbance || "-";
            liveAbsorbanceValue.style.color = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
            liveAbsorbanceInfo.textContent = `Blank: ${blankRoi.name}`;
          } else {
            // Default state if no valid sample/blank/wavelength
            liveAbsorbanceLabel.textContent = "";
            liveAbsorbanceValue.textContent = "-";
            liveAbsorbanceValue.style.color = "var(--secondary-color)"; // Reset to default color

            if (!blankRoi) {
              liveAbsorbanceInfo.textContent = "No Blank ROI set";
            } else if (!targetRoi) {
              liveAbsorbanceInfo.textContent = "No Sample ROI set";
            } else {
              liveAbsorbanceInfo.textContent = "No Wavelengths added";
            }
          }
        }

        document.querySelectorAll(".collapsible-header").forEach((header) => {
          header.addEventListener("click", () => {
            header.closest(".collapsible").classList.toggle("open");
          });
        });
        /**
 * REPLACEMENT for drawROIs
 * This new version checks the "Hide Captured ROI" setting before deciding whether to
 * hide a captured reference from the canvas.
 */
function drawROIs() {
    // 1. Clear the canvas for a fresh render.
    roiCtx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);

    // 2. Loop through every ROI in the application state.
    appState.rois.forEach(roi => {

        // --- NEW: Conditional Hiding Logic ---
        // First, check if a snapshot exists for this ROI.
        const isCaptured = !!appState.referenceSnapshots[roi.id];

        // THEN, check if the "hide" setting is enabled AND the ROI is captured.
        if (isCaptured && appState.hideCapturedRois) {
            // If both are true, skip drawing this ROI.
            return;
        }
        // --- END of New Logic ---


        // 3. If the ROI was not hidden, proceed with the original drawing logic.
        const size = roi.shape === 'pixel' ? 5 : roi.size;
        const halfSize = size / 2;
        roiCtx.strokeStyle = roi.color;
        roiCtx.lineWidth = 2;
        roiCtx.fillStyle = `${roi.color}33`; // Semi-transparent fill
        roiCtx.font = "12px Arial";
        roiCtx.textAlign = "center";

        // Draw the shape (circle or square)
        roiCtx.beginPath();
        if (roi.shape === 'circle') {
            roiCtx.arc(roi.x, roi.y, halfSize, 0, Math.PI * 2);
        } else {
            roiCtx.rect(roi.x - halfSize, roi.y - halfSize, size, size);
        }
        roiCtx.stroke();
        roiCtx.fill();

        // Draw the name label above the ROI
        roiCtx.fillStyle = roi.color;
        roiCtx.fillText(roi.name, roi.x, roi.y - halfSize - 5);

        // Draw the positional lock icon
        if (roi.locked) {
            roiCtx.font = "15px Arial";
            roiCtx.fillStyle = roi.color;
            roiCtx.fillText('🔒', roi.x, roi.y + halfSize + 15);
        }
    });
}
        function updateWavelengthList() {
          wavelengthList.innerHTML = "";
          appState.wavelengths.forEach((wl) => {
            const rgb = wavelengthToRgb(wl);
            const li = document.createElement("li");
            li.style.backgroundColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
            const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            li.style.color = brightness > 128 ? "#000" : "#fff";
            li.innerHTML = `${wl} nm <button data-wl="${wl}" class="delete-wl">&times;</button>`;
            wavelengthList.appendChild(li);
          });
          updateResultsTableHeader();
        }
        function updateResultsTableHeader() {
          let headers = `<th></th><th>Name</th>`;
          headers += appState.wavelengths
            .map((wl) => `<th>${wl} nm</th>`)
            .join("");
          headers += `<th>Actions</th>`;
          resultsTableHead.innerHTML = headers;
        }

        
        function updateResultsTable() {
    resultsTableBody.innerHTML = '';
    appState.rois.forEach(roi => {
        const tr = document.createElement('tr');
        let thumbCellHtml = '';
        const snapshot = appState.referenceSnapshots[roi.id];

        // Use the snapshot for the thumbnail if it exists, otherwise generate a live one.
        if (snapshot) {
            thumbCellHtml = `<img src="${snapshot.thumbnailDataUrl}" class="roi-thumbnail" style="border-radius: ${roi.shape === 'circle' ? '50%' : '4px'};" title="Reference Snapshot">`;
        } else {
            const avgColor = getRoiAverageColor(roi) || { r: 0, g: 0, b: 0 };
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = 24; thumbCanvas.height = 24;
            const thumbCtx = thumbCanvas.getContext('2d');
            thumbCtx.fillStyle = `rgb(${avgColor.r.toFixed(0)}, ${avgColor.g.toFixed(0)}, ${avgColor.b.toFixed(0)})`;
            thumbCtx.fillRect(0, 0, 24, 24);
            thumbCellHtml = `<img src="${thumbCanvas.toDataURL()}" class="roi-thumbnail" title="Live ROI">`;
        }
        
        // --- REPLACE THE LINE FROM STEP 2 WITH THIS ENTIRE BLOCK ---

// First, check if a batch time-series scan is currently running.
const isBatchTimeScanRunning = appState.isMeasuring && measurementModeSelect.value === 'time';
let absorbanceCells = ''; // Initialize the variable

// Now, decide what to put in the data cells.
if (isBatchTimeScanRunning && roi.type === 'sample') {
    // If a scan is running, fill the data cells with a spinning icon.
    absorbanceCells = appState.wavelengths.map(() => `<td><i class="bi bi-arrow-repeat spinner-icon"></i></td>`).join('');
} else {
    // Otherwise (if not measuring or in another mode), show the actual absorbance values.
    absorbanceCells = appState.wavelengths.map(wl => `<td>${roi.absorbance ? (roi.absorbance[wl] || '-') : '-'}</td>`).join('');
}
// --- END OF THE REPLACEMENT BLOCK ---

        // Conditionally create the "Capture & Lock" button with the correct text.
        const isReference = !!snapshot;
        const captureBtnText = isReference ? 'Captured! Release?' : 'Capture & Lock';
        const captureBtnTitle = isReference ? 'Release this reference and make it a live ROI again' : 'Save a snapshot of this data as a permanent reference';
        const captureBtn = `<button class="button-secondary capture-lock-btn" data-id="${roi.id}" title="${captureBtnTitle}" style="padding: 2px 6px; font-size: 0.8em; white-space: nowrap;">${captureBtnText}</button>`;
        
        const seriesChartBtn = roi.seriesData ? `<button class="icon-button chart-roi-btn" data-id="${roi.id}" title="View Wavelength Scan Chart"><i class="bi bi-bar-chart"></i></button>` : '';
        const timeChartBtn = roi.timeSeriesData ? `<button class="icon-button timeseries-chart-btn" data-id="${roi.id}" title="View Time Series Chart"><i class="bi bi-clock"></i></button>` : '';

        tr.innerHTML = `
            <td>${thumbCellHtml}</td>
            <td>${roi.name}</td>
            ${absorbanceCells}
            <td>
                ${captureBtn}
                <button class="icon-button lock-roi-btn" data-id="${roi.id}" title="Toggle Position Lock">${roi.locked ? '<i class="bi bi-lock-fill"></i>' : '<i class="bi bi-unlock-fill"></i>'}</button>
                <button class="icon-button edit-roi-btn" data-id="${roi.id}" title="Edit"><i class="bi bi-pencil"></i></button>
                <button class="icon-button info-roi-btn" data-id="${roi.id}" title="Info"><i class="bi bi-info-circle"></i></button>
                ${seriesChartBtn}
                ${timeChartBtn}
                <button class="icon-button delete-roi-btn" data-id="${roi.id}" title="Delete"><i class="bi bi-trash"></i></button>
            </td>`;
        resultsTableBody.appendChild(tr);
    });
}

        function handleImageUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
            setCanvasSize(img.width, img.height);
            mainCtx.drawImage(img, 0, 0);
            canvasPlaceholder.style.display = 'none';
            appState.originalImageData = mainCtx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);

            // --- NEW, SIMPLIFIED LOGIC ---
            // Get the IDs of all ROIs that have been saved as references.
            const referenceIds = Object.keys(appState.referenceSnapshots);
            // Filter the main ROIs array, keeping ONLY those that are references.
            appState.rois = appState.rois.filter(r => referenceIds.includes(r.id));
            
            // After filtering, update the official blankRoiId to be the ID of the
            // blank ROI if it still exists in the filtered array.
            appState.blankRoiId = appState.rois.find(r => r.type === 'blank')?.id || null;
            
            // Recalculate and redraw the UI with the preserved reference ROIs.
            calculateAllAbsorbances();
            drawROIs();
        };
        img.src = event.target.result;
    };
    reader.readAsDataURL(file);
}

        async function startCamera() {
          try {
            if (appState.videoStream) {
              appState.videoStream.getTracks().forEach((track) => track.stop());
            }
            appState.videoStream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: "environment" },
            });
            videoFeed.srcObject = appState.videoStream;
            videoFeed.onloadedmetadata = () => {
              setCanvasSize(videoFeed.videoWidth, videoFeed.videoHeight);
              canvasPlaceholder.style.display = "none";
              requestAnimationFrame(drawVideoFrame);
            };
          } catch (err) {
            console.error("Error accessing camera:", err);
            alert("Could not access camera. Please check permissions.");
          }
        }
        function stopCamera() {
          if (appState.videoStream) {
            appState.videoStream.getTracks().forEach((track) => track.stop());
            appState.videoStream = null;
          }
        }
        function drawVideoFrame() {
          if (
            appState.sourceType === "camera" &&
            !videoFeed.paused &&
            !videoFeed.ended &&
            !appState.isMeasuring
          ) {
            mainCtx.drawImage(
              videoFeed,
              0,
              0,
              mainCanvas.width,
              mainCanvas.height
            );
            calculateAllAbsorbances();
            requestAnimationFrame(drawVideoFrame);
          }
        }
        function setCanvasSize(width, height) {
          mainCanvas.width = roiCanvas.width = width;
          mainCanvas.height = roiCanvas.height = height;
          drawROIs();
        }
        uploadButton.addEventListener("click", () => imageLoader.click());
        imageLoader.addEventListener("change", handleImageUpload);
        // REPLACE THE OLD FUNCTION WITH THIS ONE
sourceRadios.forEach((radio) => {
    radio.addEventListener("change", (e) => {
        appState.sourceType = e.target.value;
        if (appState.sourceType === "camera") {
            startCamera();
            uploadButton.style.display = "none";
            imageLoader.style.display = "none"; // This is correct
        } else {
            stopCamera();
            uploadButton.style.display = "block";
            // CORRECTED LINE:
            imageLoader.style.display = "none"; // The native input should ALWAYS be hidden.
        }
    });
});

        addWavelengthBtn.addEventListener("click", () => {
          const wl = parseInt(wavelengthInput.value);
          if (wl >= 380 && wl <= 780 && !appState.wavelengths.includes(wl)) {
            appState.wavelengths.push(wl);
            appState.wavelengths.sort((a, b) => a - b);
            wavelengthInput.value = "";
            updateWavelengthList();
            calculateAllAbsorbances();
          }
        });
        wavelengthList.addEventListener("click", (e) => {
          if (e.target.classList.contains("delete-wl")) {
            const wlToRemove = parseInt(e.target.dataset.wl);
            appState.wavelengths = appState.wavelengths.filter(
              (wl) => wl !== wlToRemove
            );
            updateWavelengthList();
            calculateAllAbsorbances();
          }
        });
        roiCanvas.addEventListener("mousedown", (e) => {
          const rect = roiCanvas.getBoundingClientRect();
          const scaleX = roiCanvas.width / rect.width;
          const scaleY = roiCanvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;
          let clickedOnRoi = null;
          for (let i = appState.rois.length - 1; i >= 0; i--) {
            const roi = appState.rois[i];
            const dist = Math.sqrt(
              Math.pow(x - roi.x, 2) + Math.pow(y - roi.y, 2)
            );
            if (dist < roi.size / 2) {
              clickedOnRoi = roi;
              break;
            }
          }
          if (clickedOnRoi && !clickedOnRoi.locked) {
            appState.isDragging = true;
            appState.draggedRoi = clickedOnRoi;
            appState.dragOffsetX = x - clickedOnRoi.x;
            appState.dragOffsetY = y - clickedOnRoi.y;
          } else if (!clickedOnRoi && mainCanvas.width > 0) {
            addRoi(x, y);
          }
        });
        roiCanvas.addEventListener("mousemove", (e) => {
          if (appState.isDragging && appState.draggedRoi) {
            const rect = roiCanvas.getBoundingClientRect();
            const scaleX = roiCanvas.width / rect.width;
            const scaleY = roiCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            appState.draggedRoi.x = x - appState.dragOffsetX;
            appState.draggedRoi.y = y - appState.dragOffsetY;
            appState.draggedRoi.x = Math.max(
              0,
              Math.min(mainCanvas.width, appState.draggedRoi.x)
            );
            appState.draggedRoi.y = Math.max(
              0,
              Math.min(mainCanvas.height, appState.draggedRoi.y)
            );
            drawROIs();
            calculateAllAbsorbances();
          }
        });
        window.addEventListener("mouseup", () => {
          appState.isDragging = false;
          appState.draggedRoi = null;
        });

        
        resultsTableBody.addEventListener("click", (e) => {
    const row = e.target.closest("tr");
    if (!row) return;

    // This part handles row selection/highlighting
    const buttonInRow = row.querySelector("td:last-child button");
    if (buttonInRow) {
        const id = buttonInRow.dataset.id;
        const roi = appState.rois.find((r) => r.id === id);
        if (roi && roi.type === "sample") {
            if (appState.selectedRoiId === id) {
                appState.selectedRoiId = null;
                row.style.backgroundColor = "";
            } else {
                appState.selectedRoiId = id;
                document.querySelectorAll("#resultsTable tbody tr").forEach((tr) => (tr.style.backgroundColor = ""));
                row.style.backgroundColor = "rgba(187, 134, 252, 0.2)";
            }
        }
      updateLiveAbsorbanceDisplay();
        
    }

    // This part handles specific button clicks
    const button = e.target.closest("button");
    if (!button) return;

    const id = button.dataset.id;
    const roi = appState.rois.find((r) => r.id === id);

    // --- NEW LOGIC for the Capture & Lock button ---
    if (button.classList.contains("capture-lock-btn")) {
        if (appState.referenceSnapshots[id]) {
            openReleaseModal(id); // If it's already a reference, open the release modal.
        } else {
            openCaptureModal(id); // Otherwise, open the capture modal.
        }
    } else if (button.classList.contains("lock-roi-btn")) {
        if (roi) { roi.locked = !roi.locked; drawROIs(); updateResultsTable(); }
    } else if (button.classList.contains("edit-roi-btn")) {
        openEditModal(id);
    } else if (button.classList.contains("info-roi-btn")) {
        openInfoModal(id);
    } else if (button.classList.contains("chart-roi-btn")) {
        if (roi && roi.seriesData) { showChart(roi.seriesData, "Wavelength (nm)", "Absorbance", `${roi.name} - Wavelength Scan`, 'series'); }
    } else if (button.classList.contains("timeseries-chart-btn")) {
        if (roi && roi.timeSeriesData) { showChart(roi.timeSeriesData, 'Time (s)', 'Absorbance', `${roi.name} - Time Series`, 'time'); }
    } else if (button.classList.contains("delete-roi-btn")) {
        appState.rois = appState.rois.filter((roi) => roi.id !== id);
        delete appState.referenceSnapshots[id]; // Also delete its snapshot
        if (appState.blankRoiId === id) appState.blankRoiId = null;
        if (appState.selectedRoiId === id) appState.selectedRoiId = null;
        drawROIs();
        calculateAllAbsorbances();
    }
});
        
downloadCsvBtn.addEventListener("click", (e) => {
    // This stops the click from bubbling up to the collapsible header.
    e.stopPropagation(); 
    // This then runs the original function as intended.
    downloadDataAsCSV();
});


        document.addEventListener('click', (e) => {
    if (e.target.classList.contains('info-icon-settings')) {
        const infoType = e.target.dataset.info;
        if (infoType === 'blank') {
            settingsInfoTitle.textContent = 'Lock-in Blank Explained';
            settingsInfoContent.textContent = 'When checked, the app "locks in" the color value of your Blank ROI. This allows you to change the image (e.g., upload a new one or swap samples in the live camera) without losing your calibration. Once a Sample ROI is placed, the Blank ROI will disappear from the view to reduce clutter, as its value is already stored in memory.';
        } else if (infoType === 'sample') {
            settingsInfoTitle.textContent = 'Lock-in Sample Explained';
            settingsInfoContent.textContent = 'When checked, the app locks the first Sample ROI you place. This is useful for comparative analysis. The locked sample ROI will disappear from the view when you place a second sample, allowing you to use the full frame to measure a new sample against the original locked one.';
        }
        settingsInfoModal.style.display = 'flex';
    }
});

settingsInfoModal.querySelector('.close-button').addEventListener('click', () => settingsInfoModal.style.display = 'none');

        

        downloadChartCsvBtn.addEventListener('click', downloadChartDataAsCSV);


        



        measurementModeSelect.addEventListener("change", (e) => {
          seriesScanOptions.style.display =
            e.target.value === "series" ? "block" : "none";
          timeSeriesOptions.style.display =
            e.target.value === "time" ? "block" : "none";
          document.querySelectorAll(".chart-roi-btn").forEach((btn) => {
            btn.style.display =
              e.target.value === "series" ? "inline-block" : "none";
          });
        });
        startMeasurementBtn.addEventListener("click", handleStartMeasurement);

        // Main button to open the master chart modal

chartAllBtn.addEventListener('click', (e) => {
    // This stops the click from bubbling up to the collapsible header.
    e.stopPropagation();
    // This then runs the original function as intended.
    openMasterChartModal();
});


// Close button for the new modal
masterChartModal.querySelector('.close-button').addEventListener('click', () => {
    masterChartModal.style.display = 'none';
    if (appState.masterChart) {
        appState.masterChart.destroy(); // Important: clean up the chart instance
    }
});


        function generateMasterChart(dataType, chartType, selectedWavelength) {
    if (appState.masterChart) {
        appState.masterChart.destroy();
    }

    const samples = appState.rois.filter(r => r.type === 'sample');
    if (samples.length === 0) return;

    let chartData = { labels: [], datasets: [] };
    let chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
            x: { ticks: { color: '#aaa' }, grid: { color: '#444' } },
            y: { ticks: { color: '#aaa' }, grid: { color: '#444' }, title: { display: true, text: 'Absorbance', color: '#fff' } }
        },
        plugins: {
            legend: { labels: { color: '#fff' } },
            title: { display: false }
        }
    };

    if (dataType === 'static') {
        chartData.labels = appState.wavelengths.map(wl => `${wl} nm`);
        chartOptions.scales.x.title = { display: true, text: 'Wavelength (nm)', color: '#fff' };
        samples.forEach(sample => {
            chartData.datasets.push({
                label: sample.name,
                data: appState.wavelengths.map(wl => sample.absorbance[wl] || 0),
                backgroundColor: chartType === 'bar' ? sample.color : `${sample.color}33`,
                borderColor: sample.color,
                tension: 0.1,
                fill: chartType === 'line'
            });
        });

    } else if (dataType === 'series') {
        const referenceSample = samples.find(s => s.seriesData);
        if (!referenceSample) return;
        chartData.labels = referenceSample.seriesData.labels;
        chartOptions.scales.x.title = { display: true, text: 'Wavelength (nm)', color: '#fff' };
        samples.forEach(sample => {
            if (sample.seriesData) {
                chartData.datasets.push({
                    label: sample.name,
                    data: sample.seriesData.datasets[0].data,
                    borderColor: sample.color,
                    backgroundColor: 'transparent',
                    tension: 0.1,
                    fill: false
                });
            }
        });

    } else if (dataType === 'time') {
        const referenceSample = samples.find(s => s.timeSeriesData);
        if (!referenceSample) return;
        chartData.labels = referenceSample.timeSeriesData.labels.map(t => `${t}s`);
        chartOptions.scales.x.title = { display: true, text: 'Time (s)', color: '#fff' };
        samples.forEach(sample => {
            if (sample.timeSeriesData) {
                const targetDataset = sample.timeSeriesData.datasets.find(ds => ds.label === `${selectedWavelength} nm`);
                if (targetDataset) {
                    chartData.datasets.push({
                        label: sample.name,
                        data: targetDataset.data,
                        borderColor: sample.color,
                        backgroundColor: 'transparent',
                        tension: 0.1,
                        fill: false
                    });
                }
            }
        });
        chartOptions.plugins.title = { display: true, text: `Time Series Comparison for ${selectedWavelength} nm`, color: '#fff', font: { size: 16 } };
    }

    appState.masterChart = new Chart(document.getElementById('masterChartCanvas'), {
        type: chartType,
        data: chartData,
        options: chartOptions
    });
}


        /**
 * REPLACEMENT for openMasterChartModal
 * This is the main controller function that opens and manages the master chart modal.
 * It dynamically configures the UI controls and orchestrates chart redraws.
 */
function openMasterChartModal() {
    const samples = appState.rois.filter(r => r.type === 'sample');
    if (samples.length === 0) {
        alert("Please add at least one sample ROI to generate a chart.");
        return;
    }

    // 1. Check which types of measurement data are available across all samples.
    const hasStatic = true; // Static data is always considered available.
    const hasSeries = samples.some(s => s.seriesData);
    const hasTime = samples.some(s => s.timeSeriesData);

    // 2. Dynamically populate the "Data Source" dropdown with only the available options.
    masterChartDataType.innerHTML = '';
    if (hasStatic) masterChartDataType.innerHTML += `<option value="static">Static Absorbance</option>`;
    if (hasSeries) masterChartDataType.innerHTML += `<option value="series">Series Wavelength Scan</option>`;
    if (hasTime) masterChartDataType.innerHTML += `<option value="time">Time Series Data</option>`;

    // 3. Define the main function that redraws the chart when data source or type changes.
    const redrawMasterChart = () => {
        const dataType = masterChartDataType.value;
        const chartType = document.querySelector('input[name="masterChartType"]:checked').value;

        // Conditionally show/hide and populate the wavelength selector for time-series data.
        if (dataType === 'time') {
            masterChartWavelengthControl.style.display = 'block';
            const referenceSample = samples.find(s => s.timeSeriesData);
            if (referenceSample) {
                const currentSelection = masterChartWavelengthSelect.value;
                masterChartWavelengthSelect.innerHTML = ''; // Clear old options
                referenceSample.timeSeriesData.datasets.forEach(dataset => {
                    const wl = dataset.label.replace(' nm', '');
                    const option = document.createElement('option');
                    option.value = wl;
                    option.textContent = `${wl} nm`;
                    masterChartWavelengthSelect.appendChild(option);
                });
                if (currentSelection) masterChartWavelengthSelect.value = currentSelection;
            }
        } else {
            masterChartWavelengthControl.style.display = 'none';
        }
        
        // Disable the Bar chart option if the data source isn't "Static Absorbance".
        const barChartRadio = document.getElementById('chartTypeBar');
        barChartRadio.disabled = (dataType !== 'static');
        if (barChartRadio.disabled && barChartRadio.checked) {
            document.getElementById('chartTypeLine').checked = true; // Default back to Line chart
        }
        
        const finalChartType = document.querySelector('input[name="masterChartType"]:checked').value;
        const selectedWavelength = masterChartWavelengthSelect.value;
        
        // Call the main generator with all the current settings.
        generateMasterChart(dataType, finalChartType, selectedWavelength);
    };

    // 4. Define a separate, lightweight function to handle only the height change.
    const handleHeightChange = () => {
        const newHeight = parseInt(masterChartHeightInput.value);
        if (newHeight >= 150) {
            masterChartCanvasContainer.style.height = `${newHeight}px`;
            // Tell the Chart.js instance to resize to its container without a full redraw.
            if (appState.masterChart) {
                appState.masterChart.resize();
            }
        }
    };
    
    // 5. Initialize the chart height when the modal is first opened.
    handleHeightChange();

    // 6. Remove any old, lingering event listeners to prevent bugs from multiple clicks.
    masterChartDataType.removeEventListener('change', redrawMasterChart);
    masterChartTypeToggle.querySelectorAll('input').forEach(radio => radio.removeEventListener('change', redrawMasterChart));
    masterChartWavelengthSelect.removeEventListener('change', redrawMasterChart);
    masterChartHeightInput.removeEventListener('input', handleHeightChange);

    // 7. Attach fresh event listeners to all controls.
    masterChartDataType.addEventListener('change', redrawMasterChart);
    masterChartTypeToggle.querySelectorAll('input').forEach(radio => radio.addEventListener('change', redrawMasterChart));
    masterChartWavelengthSelect.addEventListener('change', redrawMasterChart);
    masterChartHeightInput.addEventListener('input', handleHeightChange);

    // 8. Perform the initial draw of the chart based on the default values of the controls.
    redrawMasterChart();
    
    // 9. Finally, display the entire modal.
    masterChartModal.style.display = 'flex';
}
        
        function addRoi(x, y) {
    // 1. Get all the properties for the new ROI from the UI controls.
    const type = document.querySelector('input[name="roiType"]:checked').value;
    const id = 'roi-' + Date.now();
    const name = roiNameInput.value || (type === 'blank' ? 'Blank' : `Sample ${appState.nextSampleId++}`);

    const newRoi = {
        id: id,
        name: name,
        type: type,
        shape: roiShapeSelect.value,
        size: parseInt(roiSizeInput.value),
        x: x,
        y: y,
        color: type === 'blank' ? '#03dac6' : '#bb86fc',
        absorbance: {},
        locked: false
    };

    // 2. Handle logic specific to placing a "Blank" ROI.
    if (type === 'blank') {
        // Ensure only one blank exists by removing any previous ones.
        appState.rois = appState.rois.filter(r => r.type !== 'blank');
        appState.blankRoiId = id;

        // --- "Lock-in Blank" Logic ---
        // If the lock setting is active, create a complete snapshot of the blank's data
        // at this exact moment and store it.
        if (appState.isBlankLocked) {
            appState.lockedBlankData = createRoiSnapshot(newRoi);
        }
    }

    // 3. Handle logic specific to placing a "Sample" ROI.
    if (type === 'sample') {
        // --- "Lock-in Sample" Logic ---
        // If the lock setting is active AND no sample has been locked yet,
        // this new ROI becomes the locked one.
        if (appState.isSampleLocked && !appState.lockedSampleData) {
            // Create a complete data snapshot of this sample and store it.
            appState.lockedSampleData = createRoiSnapshot(newRoi);
            // Also store its ID for faster lookups in other functions (like drawROIs).
            appState.lockedSampleRoiId = newRoi.id;
        }
    }

    // 4. Add the newly created ROI to the main array.
    appState.rois.push(newRoi);
    roiNameInput.value = ''; // Clear the input field for the next ROI.

    // 5. Trigger a full UI and data refresh.
    // These functions will now use the new state (locked data, etc.) to render correctly.
    drawROIs();
    calculateAllAbsorbances();
}
        function openEditModal(id) {
          const roi = appState.rois.find((r) => r.id === id);
          if (roi) {
            currentlyEditingRoiId = id;
            editRoiName.value = roi.name;
            editRoiShape.value = roi.shape;
            editRoiSize.value = roi.size;
            editRoiColor.value = roi.color;
            roiEditModal.style.display = "flex";
          }
        }
        saveRoiChangesBtn.addEventListener("click", () => {
          const roi = appState.rois.find((r) => r.id === currentlyEditingRoiId);
          if (roi) {
            roi.name = editRoiName.value;
            roi.shape = editRoiShape.value;
            roi.size = parseInt(editRoiSize.value);
            roi.color = editRoiColor.value;
            if (roi.type === "blank") {
              roi.color = "#03dac6";
            }
            drawROIs();
            calculateAllAbsorbances();
            closeAllModals();
          }
        });
        function openInfoModal(id) {
    const roi = appState.rois.find(r => r.id === id);
    if (!roi) return;

    let infoData;

    // --- THIS IS THE CRITICAL FIX ---
    // First, check the new, correct reference system to see if a snapshot exists for this ROI.
    const snapshot = appState.referenceSnapshots[roi.id];

    if (snapshot) {
        // If a snapshot exists, use that as the source of truth for all data.
        infoData = snapshot;
    } else {
        // If no snapshot exists, it's a live ROI, so create a snapshot on-the-fly from the current canvas.
        infoData = createRoiSnapshot(roi);
    }
    // --- END OF FIX ---
    
    const content = document.getElementById('roiInfoContent');
    if (!infoData) {
        content.innerHTML = `<p>Could not retrieve data for this ROI.</p>`;
        roiInfoModal.style.display = 'flex';
        return;
    }

    // This section now correctly uses `infoData` which is guaranteed to be from the right source (snapshot or live).
    const previewImageHtml = `<div class="info-preview-container">
        <img src="${infoData.thumbnailDataUrl}" class="info-preview-image" title="ROI Snapshot" style="border-radius: ${roi.shape === 'circle' ? '50%' : '6px'};">
        <p><strong>Average Color:</strong> <span style="display:inline-block; width: 16px; height: 16px; background-color: rgb(${infoData.avgColor.r.toFixed(0)}, ${infoData.avgColor.g.toFixed(0)}, ${infoData.avgColor.b.toFixed(0)}); border: 1px solid #fff; vertical-align: middle;"></span></p>
    </div>`;

    content.innerHTML = `
        <div class="info-modal-body">
            <div class="info-modal-preview">
                <img src="${infoData.thumbnailDataUrl}" style="border-radius: ${roi.shape === 'circle' ? '50%' : '6px'};" title="ROI Snapshot">
            </div>
            <div class="info-modal-details">
                <div class="info-data-row"><span class="label">Name:</span><span class="value">${infoData.name}</span></div>
                <div class="info-data-row"><span class="label">Pixels in ROI:</span><span class="value">${infoData.pixelCount}</span></div>
                <div class="info-data-row"><span class="label">Avg RGB:</span><span class="value"><span class="info-color-swatch" style="background-color: rgb(${infoData.avgColor.r.toFixed(0)}, ${infoData.avgColor.g.toFixed(0)}, ${infoData.avgColor.b.toFixed(0)})"></span>R:${infoData.avgColor.r.toFixed(1)}, G:${infoData.avgColor.g.toFixed(1)}, B:${infoData.avgColor.b.toFixed(1)}</span></div>
            </div>
        </div>
        <!-- The rest of your histogram logic will go here -->
    `;

    // (The histogram logic that follows this block will also now work correctly because it uses 'infoData')
    // ... all the existing, correct histogram logic ...
    
    // Calculate ALL potential data types upfront to make UI updates instantaneous.
    const averagedHistData = calculateAveragedHistogramData(infoData.avgColor);
    // Actual pixel data is only calculated if it's not a snapshot to save performance.
    const actualHistData = snapshot ? null : calculateHistogramData(roi); // Use the snapshot flag here

    const redrawHistogram = () => {
        const sourceType = snapshot ? 'averaged' : document.querySelector('input[name="histSource"]:checked').value;
        const histType = document.querySelector('input[name="histType"]:checked').value;
        const dataToDraw = (sourceType === 'actual') ? actualHistData : averagedHistData;
        
        drawHistogram(dataToDraw, histType, sourceType, roi);
    };

    // (Code to add the histogram HTML and attach listeners remains the same as your current correct version)
    // For completeness, here is the rest of the function:
    const dataSourceToggleHtml = snapshot
        ? `<div class="histogram-data-source"><p style="color:var(--text-color-muted)">Showing histogram based on stored average value.</p></div>`
        : `<div class="histogram-data-source"><div class="radio-group"><input type="radio" id="histSourceActual" name="histSource" value="actual" checked><label for="histSourceActual">Actual Pixels</label><input type="radio" id="histSourceAveraged" name="histSource" value="averaged"><label for="histSourceAveraged">Averaged Value</label></div></div>`;

    content.querySelector('.info-modal-body').insertAdjacentHTML('afterend', `
        <div class="info-histogram-container">
            ${dataSourceToggleHtml}
            <div class="histogram-controls"><div class="radio-group"><input type="radio" id="histTypeRGB" name="histType" value="rgb" checked><label for="histTypeRGB">RGB</label><input type="radio" id="histTypeGrayscale" name="histType" value="grayscale"><label for="histTypeGrayscale">Grayscale</label><input type="radio" id="histTypeSpectral" name="histType" value="spectral"><label for="histTypeSpectral">Spectral</label></div></div>
            <div style="position: relative; height: 200px;"><canvas id="roiHistogramCanvas"></canvas></div>
        </div>
    `);
    
    content.addEventListener('change', (e) => {
        if (e.target.name === 'histSource' || e.target.name === 'histType') {
            redrawHistogram();
        }
    });

    redrawHistogram();
    
    roiInfoModal.style.display = 'flex';
}

        function closeAllModals() {
          document
            .querySelectorAll(".modal")
            .forEach((modal) => (modal.style.display = "none"));
          currentlyEditingRoiId = null;
        }
        document
          .querySelectorAll(".modal .close-button")
          .forEach((btn) => btn.addEventListener("click", closeAllModals));
        window.addEventListener("click", (e) => {
          if (e.target.classList.contains("modal")) {
            closeAllModals();
          }
        });
        async function handleStartMeasurement() {
    if (appState.isMeasuring) return;
    appState.isMeasuring = true;
    startMeasurementBtn.disabled = true;
          updateResultsTable();
    const mode = measurementModeSelect.value;
           

    try {
        if (mode === "series") {
            // Update button text based on whether a sample is selected or not.
            startMeasurementBtn.textContent = appState.selectedRoiId ? "Scanning Selected..." : "Scanning All Samples...";
            // Pass the selected ID (or null if none is selected) to the function.
            await runSeriesScan(appState.selectedRoiId);

        } else if (mode === "time") {
          timeSeriesCountdown.style.display = 'block';
            // The same logic applies to the time series measurement.
            startMeasurementBtn.textContent = appState.selectedRoiId ? "Measuring Selected..." : "Measuring All Samples...";
            await runTimeSeries(appState.selectedRoiId);
        }
    } catch (e) {
        // This catch block handles intentional stops (like alerts) so the button text isn't reset.
        console.error("Measurement stopped or failed: ", e.message);
    } finally {
        appState.isMeasuring = false;
        startMeasurementBtn.textContent = "Start Measurement";
        startMeasurementBtn.disabled = false;
      timeSeriesCountdown.style.display = 'none';
        timeSeriesCountdown.textContent = '';
      updateResultsTable(); 
    }
}
        function runSeriesScan(roiId) {
    return new Promise((resolve, reject) => {
        let samplesToScan = [];

        // --- Logic to Build the Scan List ---
        if (roiId) {
            // Case 1: A specific ROI was selected.
            const selectedSample = appState.rois.find(r => r.id === roiId);
            if (selectedSample) {
                samplesToScan.push(selectedSample);
            }
        } else {
            // Case 2: No ROI was selected. Get ALL sample ROIs.
            samplesToScan = appState.rois.filter(r => r.type === 'sample');
        }

        // --- Validation ---
        if (samplesToScan.length === 0) {
            alert("No samples found to scan.");
            return reject(new Error("No samples found."));
        }
        const blankRoi = appState.rois.find(r => r.id === appState.blankRoiId);
        if (!blankRoi) {
            alert("Please set a Blank ROI before starting a scan.");
            return reject(new Error("No Blank ROI."));
        }

        const start = parseInt(document.getElementById("seriesStart").value);
        const end = parseInt(document.getElementById("seriesEnd").value);
        const step = parseInt(document.getElementById("seriesStep").value);
        const blankColor = getRoiAverageColor(blankRoi);

        // --- Main Processing Loop ---
        samplesToScan.forEach(sampleRoi => {
            const sampleColor = getRoiAverageColor(sampleRoi);
            const seriesData = {
                labels: [],
                datasets: [{ label: "Absorbance", data: [], borderColor: "#03dac6", backgroundColor: "#03dac633", tension: 0.1, fill: true }],
            };

            for (let wl = start; wl <= end; wl += step) {
                const weights = getWavelengthChannelWeights(wl);
                const blankIntensity = weights.r * blankColor.r + weights.g * blankColor.g + weights.b * blankColor.b;
                const sampleIntensity = weights.r * sampleColor.r + weights.g * sampleColor.g + weights.b * sampleColor.b;
                let absorbance = 0;
                if (blankIntensity > 0 && sampleIntensity > 0) {
                    absorbance = -Math.log10(sampleIntensity / blankIntensity);
                }
                seriesData.labels.push(wl);
                seriesData.datasets[0].data.push(absorbance);
            }
            // Save the calculated data directly to the corresponding ROI object.
            sampleRoi.seriesData = seriesData;
        });

        alert(`Wavelength scan complete for ${samplesToScan.length} sample(s).`);
      updateResultsTable();
        
        // If only one sample was processed, open its chart automatically for convenience.
        if (samplesToScan.length === 1) {
            const singleSample = samplesToScan[0];
            showChart(singleSample.seriesData, 'Wavelength (nm)', 'Absorbance', `${singleSample.name} - Wavelength Scan`, 'series');
        }
        
        resolve(); // Signal completion.
    });
}
        /**
 * Asynchronously runs a time-series measurement.
 * - If an roiId is provided, it measures that single sample and updates its chart/table in real-time.
 * - If roiId is null, it measures ALL available samples synchronously at each time point.
 * @param {string | null} roiId The ID of the specific sample to measure, or null to measure all.
 */
async function runTimeSeries(roiId) {
    let samplesToScan = [];

    // 1. Build the list of samples to be measured based on user selection.
    if (roiId) {
        const selectedSample = appState.rois.find(r => r.id === roiId);
        if (selectedSample) samplesToScan.push(selectedSample);
    } else {
        samplesToScan = appState.rois.filter(r => r.type === 'sample');
    }

    // 2. Validate all necessary conditions before starting the measurement.
    if (samplesToScan.length === 0) {
        alert("No samples found to measure.");
        throw new Error("No samples found.");
    }
    if (appState.sourceType !== "camera") {
        alert("Time series measurement requires the live camera source.");
        throw new Error("Camera not active.");
    }
    if (!appState.blankRoiId) {
        alert("Please set a Blank ROI before starting a measurement.");
        throw new Error("No Blank ROI.");
    }
    const timePointsInput = document.getElementById("timePoints").value;
    const timePoints = timePointsInput.split(",").map(t => parseFloat(t.trim())).filter(t => !isNaN(t) && t >= 0).sort((a, b) => a - b);
    if (timePoints.length === 0) {
        alert("Please enter valid, comma-separated time points.");
        throw new Error("Invalid time points.");
    }

  let countdownInterval = null;

    // 3. Prepare the data storage structures for each sample that will be measured.
    samplesToScan.forEach(sample => {
        const timeData = { labels: [], datasets: [] };
        appState.wavelengths.forEach(wl => {
            const rgb = wavelengthToRgb(wl);
            timeData.datasets.push({ label: `${wl} nm`, data: [], borderColor: `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`, backgroundColor: `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)`, tension: 0.1, pointRadius: 4, fill: true });
        });
        sample.timeSeriesData = timeData; // Attach the empty data structure to the sample's state.
    });

    // 4. If this is a single-sample run, open its chart modal immediately.
    // The chart will be empty at first and will populate in real-time.
    if (samplesToScan.length === 1) {
        const singleSample = samplesToScan[0];
        showChart(singleSample.timeSeriesData, 'Time (s)', 'Absorbance', `${singleSample.name} - Time Series`, 'time');
    }

    // 5. Start the main asynchronous measurement process.
    // This outer promise ensures the function waits until all time points are complete.
    await new Promise(resolve => {
        let timeIndex = 0;

        function measureAtNextTimePoint() {
            if (timeIndex >= timePoints.length) {
              if(countdownInterval) clearInterval(countdownInterval);
                resolve(); // All time points are measured; resolve the promise.
                return;
            }

            const targetTime = timePoints[timeIndex];
            const previousTime = timeIndex > 0 ? timePoints[timeIndex - 1] : 0;
            const delay = (targetTime - previousTime) * 1000;

          if(countdownInterval) clearInterval(countdownInterval); // Clear any previous timer
            let secondsLeft = Math.ceil(delay / 1000);
            
            if (delay > 0) {
                timeSeriesCountdown.textContent = `Next measurement in ${secondsLeft}s...`;
                countdownInterval = setInterval(() => {
                    secondsLeft--;
                    timeSeriesCountdown.textContent = `Next measurement in ${secondsLeft}s...`;
                    if (secondsLeft <= 0) {
                        clearInterval(countdownInterval);
                    }
                }, 1000);
            } else {
                 timeSeriesCountdown.textContent = 'Measuring now...';
            }

            startMeasurementBtn.textContent = `Waiting for ${targetTime}s...`;

            setTimeout(() => {
              if(countdownInterval) clearInterval(countdownInterval); // Ensure timer is stopped
                startMeasurementBtn.textContent = `Measuring All Samples @ ${targetTime}s`;

                // A. Capture a single, definitive frame from the video. This is the key to synchronicity.
                mainCtx.drawImage(videoFeed, 0, 0, mainCanvas.width, mainCanvas.height);

                // B. Loop through ALL samples for this single point in time.
                samplesToScan.forEach(sampleRoi => {
                    // This function now uses the same captured frame for all sample calculations.
                    calculateAllAbsorbances();
                    
                    const timeData = sampleRoi.timeSeriesData;
                    timeData.labels.push(targetTime); // Add the time point to this sample's data.

                    // Add the absorbance value for each wavelength to this sample's data.
                    appState.wavelengths.forEach((wl, wlIndex) => {
                        timeData.datasets[wlIndex].data.push(sampleRoi.absorbance[wl] || 0);
                    });
                });

                // C. If this is a single-sample run, update its chart AND table in real-time.
                if (samplesToScan.length === 1 && appState.measurementChart) {
                    appState.measurementChart.update(); // Update the graph.
                    const singleSample = samplesToScan[0];
                    generateChartTable(singleSample.timeSeriesData, 'time', `${singleSample.name} - Time Series`); // Update the table.
                }

                timeIndex++;
                measureAtNextTimePoint(); // Schedule the next measurement.
            }, delay);
        }

        measureAtNextTimePoint(); // Initiate the first measurement (t=0).
    });

    // 6. Provide final feedback to the user.
    alert(`Time series measurement complete for ${samplesToScan.length} sample(s).`);
  
}
        /**
 * Displays the measurement chart modal with a graph and a corresponding data table.
 *
 * @param {object} data The Chart.js data object (labels, datasets).
 * @param {string} xLabel The label for the X-axis.
 * @param {string} yLabel The label for the Y-axis.
 * @param {string} titleText The main title for the chart and modal.
 * @param {string} mode The type of measurement being displayed ('series' for wavelength or 'time' for time points).
 */
function showChart(data, xLabel, yLabel, titleText, mode) {
    // 1. Get a reference to the canvas element for the chart.
    const chartCanvas = document.getElementById('measurementChart');

    // 2. Destroy any previously existing chart instance.
    // This is crucial to prevent memory leaks and rendering glitches when showing a new chart.
    if (appState.measurementChart) {
        appState.measurementChart.destroy();
    }

    // 3. Set the title of the modal.
    document.getElementById('chartTitle').textContent = titleText;

    // 4. Create the new Chart.js instance with the provided data and styling options.
    appState.measurementChart = new Chart(chartCanvas, {
        type: 'line',
        data: data,
        options: {
            responsive: true,
            scales: {
                x: {
                    title: { display: true, text: xLabel, color: '#fff' },
                    ticks: { color: '#aaa' },
                    grid: { color: '#444' }
                },
                y: {
                    title: { display: true, text: yLabel, color: '#fff' },
                    ticks: { color: '#aaa' },
                    grid: { color: '#444' }
                }
            },
            plugins: {
                legend: {
                    labels: { color: '#fff' }
                }
            }
        }
    });

    // --- NEW LOGIC for Data Table and CSV Preparation ---

    // 5. Generate and populate the HTML table with the same data used by the chart.
    generateChartTable(data, mode, titleText);

    // 6. Store the chart's data in a globally accessible variable.
    // This allows the separate "downloadChartCsvBtn" event listener to access the correct data when clicked.
    currentChartDataForCSV = { data, mode, title: titleText };

    // 7. Make the container for the table and download button visible.
    chartDataTableContainer.style.display = 'block';

    // --- END of New Logic ---


    // 8. Finally, display the entire modal.
    chartModal.style.display = 'flex';
}

        function downloadDataAsCSV() {
          // 1. Define CSV Headers
          const headers = [
            "Name",
            ...appState.wavelengths.map((wl) => `${wl} nm`),
          ];

          // 2. Map ROI data to CSV rows
          const rows = appState.rois.map((roi) => {
            // Enclose the name in double quotes to handle commas within names
            const name = `"${roi.name}"`;

            // Get the absorbance value for each wavelength in the correct order
            const values = appState.wavelengths.map((wl) => {
              return roi.absorbance ? roi.absorbance[wl] || "" : "";
            });

            // Combine the name and values into a single row string
            return [name, ...values].join(",");
          });

          // 3. Combine headers and rows into a single CSV string
          const csvContent = [headers.join(","), ...rows].join("\n");

          // 4. Create a Blob and trigger the download
          const blob = new Blob([csvContent], {
            type: "text/csv;charset=utf-8;",
          });
          const link = document.createElement("a");
          if (link.download !== undefined) {
            // Check for browser support
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "ImageSpec_ROI_Data.csv");
            link.style.visibility = "hidden";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          }
        }

        // REPLACE THE OLD FUNCTION WITH THIS NEW ONE
function generateChartTable(chartData, mode, title) {
    const tableHead = chartDataTable.querySelector('thead');
    const tableBody = chartDataTable.querySelector('tbody');
    tableHead.innerHTML = '';
    tableBody.innerHTML = '';
    let headHtml = '<tr>';
    let bodyHtml = '';

    // CORRECTED: Extract the sample name for both modes to ensure consistency.
    const sampleName = title.split(' - ')[0];

    if (mode === 'series') { // Wavelength Scan
        // CORRECTED: The headers now match the format you requested.
        headHtml += '<th>Measurement Point</th><th>Absorbance</th>';
        chartData.labels.forEach((wl, index) => {
            const absorbance = chartData.datasets[0].data[index].toFixed(4);
            // CORRECTED: The first cell is now formatted with the sample name and wavelength.
            bodyHtml += `<tr><td>${sampleName} @ ${wl}nm</td><td>${absorbance}</td></tr>`;
        });
    } else if (mode === 'time') { // Time Points (This part was already correct)
        headHtml += '<th>Measurement Point</th>';
        chartData.datasets.forEach(dataset => {
            headHtml += `<th>${dataset.label}</th>`;
        });
        chartData.labels.forEach((time, timeIndex) => {
            bodyHtml += `<tr><td>${sampleName} @ ${time}s</td>`;
            chartData.datasets.forEach(dataset => {
                const absorbance = dataset.data[timeIndex] !== null ? dataset.data[timeIndex].toFixed(4) : '-';
                bodyHtml += `<td>${absorbance}</td>`;
            });
            bodyHtml += '</tr>';
        });
    }

    headHtml += '</tr>';
    tableHead.innerHTML = headHtml;
    tableBody.innerHTML = bodyHtml;
}


        function downloadChartDataAsCSV() {
    if (!currentChartDataForCSV) return;

    const { data, mode, title } = currentChartDataForCSV;
    let csvContent = '';
    let headers = [];
    let rows = [];

    if (mode === 'series') {
        headers = ['Wavelength (nm)', 'Absorbance'];
        rows = data.labels.map((wl, index) => `${wl},${data.datasets[0].data[index].toFixed(4)}`);
    } else if (mode === 'time') {
        const sampleName = title.split(' - ')[0];
        headers = ['Measurement Point', ...data.datasets.map(d => d.label)];
        rows = data.labels.map((time, timeIndex) => {
            const rowData = data.datasets.map(d => (d.data[timeIndex] !== null ? d.data[timeIndex].toFixed(4) : ''));
            return `"${sampleName} @ ${time}s",${rowData.join(',')}`;
        });
    }

    csvContent = [headers.join(','), ...rows].join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const filename = title.replace(/\s/g, '_') + '.csv';
    link.setAttribute('href', URL.createObjectURL(blob));
    link.setAttribute('download', filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

        /**
 * Creates a "perfect" histogram based on a single average color value.
 * The result is a sharp spike at the average intensity for each channel.
 * @param {object} avgColor An object with {r, g, b} properties.
 * @returns {object} A histogram data object.
 */
function calculateAveragedHistogramData(avgColor) {
    const redBins = new Array(256).fill(0);
    const greenBins = new Array(256).fill(0);
    const blueBins = new Array(256).fill(0);
    const lumBins = new Array(256).fill(0);

    const r = Math.round(avgColor.r);
    const g = Math.round(avgColor.g);
    const b = Math.round(avgColor.b);

    redBins[r] = 1; // A single "count" at the average value
    greenBins[g] = 1;
    blueBins[b] = 1;

    const luminance = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
    lumBins[luminance] = 1;

    return { red: redBins, green: greenBins, blue: blueBins, luminance: lumBins };
}

/**
 * Calculates the frequency of each intensity value (0-255) for the R, G, B,
 * and Luminance channels for all pixels within a given ROI's shape.
 * @param {object} roi The ROI object to analyze.
 * @returns {object|null} An object containing arrays for each channel's histogram data, or null.
 */
function calculateHistogramData(roi) {
    if (!roi || !mainCanvas.width || !mainCanvas.height) return null;

    const redBins = new Array(256).fill(0);
    const greenBins = new Array(256).fill(0);
    const blueBins = new Array(256).fill(0);
    const lumBins = new Array(256).fill(0);

    const size = roi.shape === 'pixel' ? 1 : roi.size;
    const halfSize = size / 2;
    const startX = Math.round(roi.x - halfSize);
    const startY = Math.round(roi.y - halfSize);

    try {
        const imageData = mainCtx.getImageData(
            Math.max(0, startX), Math.max(0, startY),
            Math.min(size, mainCanvas.width - startX), Math.min(size, mainCanvas.height - startY)
        );
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            const pixelX = Math.max(0, startX) + ((i / 4) % imageData.width);
            const pixelY = Math.max(0, startY) + Math.floor((i / 4) / imageData.width);

            let inShape = false;
            if (roi.shape === 'square' || roi.shape === 'pixel') {
                inShape = true;
            } else if (roi.shape === 'circle') {
                const dx = pixelX - roi.x;
                const dy = pixelY - roi.y;
                if (dx * dx + dy * dy <= halfSize * halfSize) inShape = true;
            }

            if (inShape) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                redBins[r]++;
                greenBins[g]++;
                blueBins[b]++;
                const luminance = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                lumBins[luminance]++;
            }
        }
        return { red: redBins, green: greenBins, blue: blueBins, luminance: lumBins };
    } catch (e) {
        console.error("Error calculating histogram data:", e);
        return null;
    }
}

/**
 * Draws a histogram on the modal's canvas, adapting its style for different data types.
 * @param {object} histogramData The data object from one of the calculation functions.
 * @param {string} mode The type of chart to draw: 'rgb', 'grayscale', or 'spectral'.
 * @param {string} sourceType The source of the data: 'actual' or 'averaged'.
 * @param {object} roi The ROI object, needed only for spectral calculation.
 */
/**
 * Draws a histogram on the modal's canvas, adapting its style for different data types.
 * @param {object} histogramData The data object from one of the calculation functions.
 * @param {string} mode The type of chart to draw: 'rgb', 'grayscale', or 'spectral'.
 * @param {string} sourceType The source of the data: 'actual' or 'averaged'.
 * @param {object} roi The ROI object, needed only for spectral calculation.
 */
function drawHistogram(histogramData, mode, sourceType, roi) {
    if (appState.roiHistogramChart) {
        appState.roiHistogramChart.destroy();
    }
    const canvas = document.getElementById('roiHistogramCanvas');
    if (!canvas) return;
    if (!histogramData && mode !== 'spectral') {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
    }

    let chartData = { labels: [], datasets: [] };
    const labels = Array.from(Array(256).keys());
    let chartType = 'bar';
    let yAxisLabel = 'Pixel Count';

    if (sourceType === 'averaged') {
        chartType = 'line';
        yAxisLabel = 'Presence';
    }
    if (mode === 'spectral') {
        chartType = 'line';
        yAxisLabel = 'Relative Intensity';
    }

    if (mode === 'rgb') {
        chartData = { labels: labels, datasets: [
            { label: 'Red', data: histogramData.red, backgroundColor: 'rgba(255, 99, 132, 0.7)', borderColor: 'rgb(255, 99, 132)', stepped: sourceType === 'averaged', pointRadius: 0, borderWidth: 1 },
            { label: 'Green', data: histogramData.green, backgroundColor: 'rgba(75, 192, 192, 0.7)', borderColor: 'rgb(75, 192, 192)', stepped: sourceType === 'averaged', pointRadius: 0, borderWidth: 1 },
            { label: 'Blue', data: histogramData.blue, backgroundColor: 'rgba(54, 162, 235, 0.7)', borderColor: 'rgb(54, 162, 235)', stepped: sourceType === 'averaged', pointRadius: 0, borderWidth: 1 }
        ]};
    } else if (mode === 'grayscale') {
        chartData = { labels: labels, datasets: [{ label: 'Luminance', data: histogramData.luminance, backgroundColor: 'rgba(200, 200, 200, 0.7)', borderColor: 'rgb(200, 200, 200)', stepped: sourceType === 'averaged', pointRadius: 0, borderWidth: 1 }]};
    } else if (mode === 'spectral' && roi) {
        const avgColor = getRoiAverageColor(roi);
        const spectralLabels = [];
        const spectralData = [];
        for (let wl = 400; wl <= 700; wl += 5) {
            const weights = getWavelengthChannelWeights(wl);
            const intensity = weights.r * avgColor.r + weights.g * avgColor.g + weights.b * avgColor.b;
            spectralLabels.push(wl);
            spectralData.push(intensity);
        }
        chartData = {
            labels: spectralLabels,
            datasets: [{ label: 'Spectral Intensity', data: spectralData, borderColor: '#bb86fc', tension: 0.2, fill: false, pointRadius: 0 }]
        };
    }

    appState.roiHistogramChart = new Chart(canvas, {
        type: chartType,
        data: chartData,
        options: {
            responsive: true, maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true, ticks: { color: '#aaa', precision: 0 }, grid: { color: '#444' }, title: { display: true, text: yAxisLabel, color: '#fff' } },
                x: { ticks: { color: '#aaa', maxRotation: 0, autoSkip: true, maxTicksLimit: 10 }, grid: { color: '#444' }, title: { display: true, text: (mode === 'spectral') ? 'Wavelength (nm)' : 'Intensity', color: '#fff' } }
            },
            plugins: { legend: { labels: { color: '#fff' } } }
        }
    });
}

        /**
 * Applies the current filter settings (brightness, contrast, grayscale)
 * to the original image data and redraws it on the main canvas.
 */
function applyImageFilters() {
    if (!appState.originalImageData) return; // Exit if there's no original image to work from

    const originalData = appState.originalImageData.data;
    const manipulatedData = new Uint8ClampedArray(originalData); // Create a copy to manipulate

    const brightness = (appState.imageFilters.brightness - 100) * 2.55; // Scale to -255 to 255
    const contrast = appState.imageFilters.contrast / 100; // Scale to 0 to 2
    const grayscale = appState.imageFilters.grayscale;

    const clamp = (value) => Math.max(0, Math.min(255, value)); // Helper to keep values in 0-255 range

    for (let i = 0; i < manipulatedData.length; i += 4) {
        let r = originalData[i];
        let g = originalData[i + 1];
        let b = originalData[i + 2];

        // Apply Contrast
        r = clamp(((r / 255 - 0.5) * contrast + 0.5) * 255);
        g = clamp(((g / 255 - 0.5) * contrast + 0.5) * 255);
        b = clamp(((b / 255 - 0.5) * contrast + 0.5) * 255);

        // Apply Brightness
        r = clamp(r + brightness);
        g = clamp(g + brightness);
        b = clamp(b + brightness);

        // Apply Grayscale
        if (grayscale) {
            const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
            r = g = b = luminance;
        }

        manipulatedData[i] = r;
        manipulatedData[i + 1] = g;
        manipulatedData[i + 2] = b;
    }

    // Put the newly manipulated pixel data back onto the canvas
    mainCtx.putImageData(new ImageData(manipulatedData, mainCanvas.width, mainCanvas.height), 0, 0);
    
    // After redrawing the canvas, all ROI measurements must be recalculated
    calculateAllAbsorbances();
}

        // This function syncs the state and triggers a redraw.
const handleFilterChange = () => {
    // Update state from UI
    appState.imageFilters.brightness = parseInt(brightnessInput.value);
    appState.imageFilters.contrast = parseInt(contrastInput.value);
    appState.imageFilters.grayscale = grayscaleCheck.checked;

    // Apply the filters and recalculate everything
    applyImageFilters();
};

// Link sliders to their input boxes
brightnessSlider.addEventListener('input', () => { brightnessInput.value = brightnessSlider.value; handleFilterChange(); });
brightnessInput.addEventListener('input', () => { brightnessSlider.value = brightnessInput.value; handleFilterChange(); });
contrastSlider.addEventListener('input', () => { contrastInput.value = contrastSlider.value; handleFilterChange(); });
contrastInput.addEventListener('input', () => { contrastSlider.value = contrastInput.value; handleFilterChange(); });

// Listener for the checkbox
grayscaleCheck.addEventListener('change', handleFilterChange);

// Listener for the revert button
revertFiltersBtn.addEventListener('click', () => {
    // Reset the UI controls
    brightnessSlider.value = 100;
    brightnessInput.value = 100;
    contrastSlider.value = 100;
    contrastInput.value = 100;
    grayscaleCheck.checked = false;

    // Trigger a filter update, which will now use the default values.
    handleFilterChange();
});




// REPLACE THE OLD BLOCK WITH THIS NEW ONE

// --- Event Listeners for New Modals & Settings ---

// Listeners for the Stability Settings inputs, now using cached constants.
stabilityThresholdInput.addEventListener('change', (e) => { appState.stabilitySettings.threshold = parseFloat(e.target.value); });
stabilityTimeInput.addEventListener('change', (e) => { appState.stabilitySettings.time = parseInt(e.target.value); });
stabilityAverageCheck.addEventListener('change', (e) => { appState.stabilitySettings.useAverage = e.target.checked; });

// Listeners for the Capture Modal
captureNowBtn.addEventListener('click', () => {
    const roi = appState.rois.find(r => r.id === appState.activeModalRoiId);
    if (roi) {
        const snapshot = createRoiSnapshot(roi);
        if (snapshot) {
            snapshot.absorbance = { ...roi.absorbance };
            appState.referenceSnapshots[roi.id] = snapshot;
        }
    }
    closeAllModals();
    updateResultsTable();
});

captureStableBtn.addEventListener('click', async (e) => {
    const roi = appState.rois.find(r => r.id === appState.activeModalRoiId);
    if (!roi) return;
    const btn = e.target;
    btn.disabled = true;
    document.getElementById('captureNowBtn').disabled = true;
    btn.textContent = "Stabilizing... (0%)";
    try {
        const finalRoiState = await waitForStableReading(roi);
        const snapshot = createRoiSnapshot(finalRoiState);
        if (snapshot) {
            snapshot.absorbance = { ...finalRoiState.absorbance };
            appState.referenceSnapshots[roi.id] = snapshot;
        }
        closeAllModals();
        updateResultsTable();
    } catch (err) {
        alert(err.message);
    } finally {
        btn.disabled = false;
        document.getElementById('captureNowBtn').disabled = false;
        btn.textContent = "Capture at Stable Reading";
    }
});

// Listeners for the Release Modal
releaseConfirmBtn.addEventListener('click', () => {
    if (appState.activeModalRoiId) {
        delete appState.referenceSnapshots[appState.activeModalRoiId];
        if (appState.blankRoiId === appState.activeModalRoiId) {
            appState.blankRoiId = null;
        }
    }
    closeAllModals();
    updateResultsTable();
});

releaseCancelBtn.addEventListener('click', closeAllModals);

        /**
 * Opens the "Capture & Lock" modal for a specific ROI.
 * @param {string} roiId The ID of the ROI to capture.
 */
function openCaptureModal(roiId) {
    appState.activeModalRoiId = roiId;
    const roi = appState.rois.find(r => r.id === roiId);
    if (!roi) return;
    document.getElementById('captureModalTitle').textContent = `Capture & Lock "${roi.name}"`;
    document.getElementById('captureModalText').innerHTML = `This will save a snapshot of the current data for this ROI. Locked data is preserved when you upload a new image or manipulate the current one, serving as a permanent reference for <strong>${roi.type === 'blank' ? 'calibration' : 'comparison'}</strong>.`;
    // Only show the "Stable Reading" button if the camera is active
    document.getElementById('captureStableBtn').style.display = appState.sourceType === 'camera' ? 'block' : 'none';
    document.getElementById('captureModal').style.display = 'flex';
}

/**
 * Opens the "Release" confirmation modal for a specific ROI.
 * @param {string} roiId The ID of the ROI to release.
 */
function openReleaseModal(roiId) {
    appState.activeModalRoiId = roiId;
    const roi = appState.rois.find(r => r.id === roiId);
    if (!roi) return;
    document.getElementById('releaseModalTitle').textContent = `Release "${roi.name}"?`;
    document.getElementById('releaseModalText').innerHTML = `Are you sure you want to release this reference? The stored snapshot data will be permanently deleted, and this ROI will revert to a <strong>live measurement</strong>.`;
    document.getElementById('releaseModal').style.display = 'flex';
}


        hideCapturedCheck.addEventListener('change', (e) => {
    // Update the app's state to match the checkbox
    appState.hideCapturedRois = e.target.checked;
    // Immediately redraw the canvas to apply the change
    drawROIs();
});
        
function init() {
    updateWavelengthList();
    calculateAllAbsorbances(); // This will call updateLiveAbsorbanceDisplay, which now starts the timer.
    console.log("ImageSpec Pro Initialized");
}

        init();
      });
    </script>
  </body>
</html>
