<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ImageSpec | Enscygen ORT</title>
    <link rel="icon" type="image/x-icon" href="/Favicon.png" />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
          --bg-color: #121212;
          --surface-color: #1e1e1e;
          --primary-color: #bb86fc;
          --primary-variant-color: #3700b3;
          --secondary-color: #03dac6;
          --text-color: #e0e0e0;
          --text-color-muted: #888;
          --border-color: #333;
          --error-color: #cf6679;
          --font-family: 'Inter', sans-serif;
      }

      * {
          box-sizing: border-box;
          margin: 0;
          padding: 0;
      }

      html,
      body {
          height: 100%;
          overflow: hidden;
          font-family: var(--font-family);
          background-color: var(--bg-color);
          color: var(--text-color);
          font-size: 14px;
      }

      .app-container {
          display: grid;
          grid-template-columns: 280px 1fr 280px;
          grid-template-rows: auto 1fr auto;
          grid-template-areas: "header header header" "controls canvas data" "results results results";
          gap: 8px;
          padding: 8px;
      }

      .app-header {
          grid-area: header;
      }

      .controls-panel {
          grid-area: controls;
      }

      .canvas-container {
          grid-area: canvas;
      }

      .data-panel {
          grid-area: data;
      }

      .results-panel {
          grid-area: results;
      }

      .panel {
          background-color: var(--surface-color);
          border-radius: 8px;
          border: 1px solid var(--border-color);
          padding: 12px;
          display: flex;
          flex-direction: column;
          gap: 16px;
          overflow-y: auto;
      }

      .panel-title {
          font-size: 1.1em;
          font-weight: 500;
          display: flex;
          align-items: center;
          gap: 8px;
          margin: 0;
      }

      .collapsible-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          cursor: pointer;
          padding-bottom: 8px;
          border-bottom: 1px solid var(--border-color);
          margin-bottom: 8px;
      }

      .collapse-icon {
          font-size: 1.2em;
          transition: transform 0.3s ease;
      }

      .collapsible-content {
          max-height: 500px;
          overflow: hidden;
          transition: max-height 0.3s ease-out, padding 0.3s ease-out;
          display: flex;
          flex-direction: column;
          gap: 12px;
      }

      .collapsible:not(.open) .collapsible-content {
          max-height: 0;
          padding-top: 0;
          padding-bottom: 0;
      }

      .collapsible:not(.open) .collapse-icon {
          transform: rotate(-90deg);
      }

      .app-header {
          text-align: center;
          padding: 4px 0;
          font-size: 1.5em;
          font-weight: 600;
          color: var(--primary-color);
      }

      .form-group {
          display: flex;
          flex-direction: column;
          gap: 6px;
      }

      label {
          font-weight: 500;
          color: var(--text-color-muted);
          font-size: 0.9em;
      }

      input[type="text"],
      input[type="number"],
      select {
          width: 100%;
          padding: 8px;
          background-color: var(--bg-color);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          color: var(--text-color);
          font-size: 0.95em;
      }

      input:focus,
      select:focus {
          outline: none;
          border-color: var(--primary-color);
      }

      button {
          padding: 8px 12px;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          background-color: var(--primary-variant-color);
          color: #fff;
          font-weight: 500;
          transition: background-color 0.2s;
      }

      button:hover:not(:disabled) {
          background-color: var(--primary-color);
      }

      button:disabled {
          background-color: #333;
          cursor: not-allowed;
          color: #888;
      }

      .button-secondary {
          background-color: #444;
      }

      .button-secondary:hover {
          background-color: #555;
      }

      .icon-button {
          background: none;
          border: none;
          color: var(--text-color-muted);
          cursor: pointer;
          padding: 4px;
          border-radius: 50%;
      }

      .icon-button:hover {
          color: var(--secondary-color);
          background-color: rgba(3, 218, 198, 0.1);
      }

      .canvas-container {
          position: relative;
          background-color: #000;
          border-radius: 8px;
          overflow: hidden;
          display: flex;
          align-items: center;
          justify-content: center;
          min-height: 200px;
      }

      #mainCanvas,
      #roiCanvas {
          position: absolute;
          top: 0;
          left: 0;
          max-width: 100%;
          max-height: 100%;
          object-fit: contain;
      }

      #videoFeed {
          display: none;
      }

      #wavelengthList {
          list-style: none;
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
      }

      #wavelengthList li {
          padding: 4px 8px;
          border-radius: 12px;
          font-size: 0.9em;
          display: flex;
          align-items: center;
          gap: 6px;
          border: 1px solid #fff3;
      }

      #wavelengthList li button {
          background: none;
          border: none;
          color: inherit;
          cursor: pointer;
          padding: 0;
          font-size: 1.1em;
          line-height: 1;
      }

      #liveAbsorbanceValue {
          font-size: 2em;
          font-weight: 600;
          color: var(--secondary-color);
          text-align: center;
          margin: auto 0;
          transition: opacity 0.3s;
      }

      #liveAbsorbanceLabel {
          font-size: 0.8em;
          color: var(--text-color-muted);
          text-align: center;
          height: 1.2em;
      }

      .results-panel {
          max-height: 30vh;
      }

      #resultsTable {
          width: 100%;
          border-collapse: collapse;
          font-size: 0.9em;
      }

      #resultsTable th,
      #resultsTable td {
          padding: 8px;
          text-align: left;
          border-bottom: 1px solid var(--border-color);
      }

      #resultsTable thead {
          position: sticky;
          top: 0;
          background: var(--surface-color);
      }

      #resultsTable th {
          font-weight: 600;
          color: var(--text-color-muted);
      }

      .roi-thumbnail {
          width: 24px;
          height: 24px;
          border-radius: 4px;
          border: 1px solid #555;
      }

      .modal {
          display: none;
          position: fixed;
          z-index: 1000;
          left: 0;
          top: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          justify-content: center;
          align-items: center;
      }

      .modal-content {
          background-color: var(--surface-color);
          padding: 20px;
          border-radius: 8px;
          width: 90%;
          max-width: 500px;
          border: 1px solid var(--border-color);
      }

      .modal-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          border-bottom: 1px solid var(--border-color);
          padding-bottom: 10px;
          margin-bottom: 20px;
      }

      .close-button {
          background: none;
          border: none;
          font-size: 1.5rem;
          color: var(--text-color);
          cursor: pointer;
      }

      .radio-group {
          display: flex;
          border: 1px solid var(--border-color);
          border-radius: 4px;
          overflow: hidden;
      }

      .radio-group input[type="radio"] {
          display: none;
      }

      .radio-group label {
          flex: 1;
          text-align: center;
          padding: 8px;
          cursor: pointer;
          background-color: var(--bg-color);
          color: var(--text-color-muted);
          transition: all 0.2s;
          font-size: 0.9em;
      }

      .radio-group input[type="radio"]:checked+label {
          background-color: var(--primary-variant-color);
          color: white;
      }

      .input-row {
          display: flex;
          gap: 8px;
          align-items: center;
      }

      .input-row>* {
          flex: 1;
      }

      .info-preview-container {
          display: flex;
          gap: 10px;
          align-items: center;
          margin-top: 10px;
      }

      .info-preview-image {
          max-width: 128px;
          max-height: 128px;
          border: 1px solid var(--border-color);
          border-radius: 4px;
          image-rendering: pixelated;
      }

      @media (max-width: 900px) {
          .app-container {
              grid-template-columns: 1fr;
              grid-template-rows: auto auto auto auto 1fr;
              grid-template-areas: "header" "controls" "data" "canvas" "results";
              height: auto;
              overflow-y: auto;
          }

          .panel {
              min-height: auto;
          }

          .canvas-container {
              min-height: 300px;
              height: 50vh;
          }

          .results-panel {
              max-height: none;
          }
      }

      /* --- Styles for the new "ImageSpec Settings" section --- */

/* 1. Main container for each setting row (e.g., "Lock-in Blank: [icon] [checkbox]") */
/* This creates the perfect alignment between the label on the left and the controls on the right. */
.setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0; /* Adds a little vertical breathing room */
}

/* 2. Inner container for the controls (the icon and the checkbox) */
/* This ensures the icon and checkbox are perfectly aligned with each other. */
.setting-control {
    display: flex;
    align-items: center;
    gap: 12px; /* Provides consistent spacing between the icon and the checkbox */
}

/* 3. Styling for the clickable info icon */
.info-icon-settings {
    color: var(--text-color-muted); /* Matches the muted text color of the app */
    font-size: 1.2em; /* Makes the icon slightly larger and easier to click */
    cursor: pointer;
    transition: color 0.2s ease-in-out; /* Smooth transition for hover effect */
}

.info-icon-settings:hover {
    color: var(--secondary-color); /* Matches the app's highlight color on hover */
}

/* 4. Styling for the custom checkbox */
/* This uses a modern CSS property to style the native checkbox to match the dark theme. */
.styled-checkbox {
    /* This is the key property. It colors the checkmark and highlight with our app's primary purple. */
    accent-color: var(--primary-color);

    /* Appearance and Sizing */
    -webkit-appearance: none;
    appearance: none;
    margin: 0;
    width: 18px;
    height: 18px;
    cursor: pointer;

    /* Styling for the UNCHECKED state */
    background-color: var(--bg-color); /* Matches the app's darkest background */
    border: 1px solid var(--border-color); /* Matches other borders */
    border-radius: 4px; /* Slightly rounded corners */

    /* Positioning and layout */
    position: relative;
    display: grid;
    place-content: center;
}

/* Styling for the CHECKMARK itself (a pseudo-element) */
.styled-checkbox::before {
    content: '';
    width: 10px;
    height: 10px;
    transform: scale(0); /* Hidden by default */
    transition: 120ms transform ease-in-out;
    box-shadow: inset 1em 1em var(--primary-color);
    
    /* Creates the checkmark shape */
    transform-origin: bottom left;
    clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
}

/* Styling for the CHECKED state */
.styled-checkbox:checked::before {
    transform: scale(1); /* Makes the checkmark visible when checked */
}
    </style>
  </head>

  <body>
    <div class="app-container">
      <header class="app-header">Enscygen ImageSpec Pro</header>
      <aside class="panel controls-panel">
        <section class="collapsible open">
          <div class="collapsible-header">
            <h3 class="panel-title"><i class="bi bi-camera"></i> Source</h3>
            <i class="bi bi-chevron-up collapse-icon"></i>
          </div>
          <div class="collapsible-content">
            <div class="form-group">
              <div class="radio-group">
                <input
                  type="radio"
                  id="sourceUpload"
                  name="source"
                  value="upload"
                  checked
                />
                <label for="sourceUpload"
                  ><i class="bi bi-upload"></i> Upload</label
                >
                <input
                  type="radio"
                  id="sourceCamera"
                  name="source"
                  value="camera"
                />
                <label for="sourceCamera"
                  ><i class="bi bi-camera-video"></i> Camera</label
                >
              </div>
              <input
                type="file"
                id="imageLoader"
                accept="image/*"
                style="display: none;"
              />
              <button id="uploadButton" class="button-secondary">
                Select Image
              </button>
            </div>
          </div>
        </section>
        <section class="collapsible open">
          <div class="collapsible-header">
            <h3 class="panel-title">
              <i class="bi bi-plus-circle-dotted"></i> ROI Selection
            </h3>
            <i class="bi bi-chevron-up collapse-icon"></i>
          </div>
          <div class="collapsible-content">
            <div class="form-group">
              <label>ROI Type</label>
              <div class="radio-group">
                <input
                  type="radio"
                  id="roiTypeBlank"
                  name="roiType"
                  value="blank"
                />
                <label for="roiTypeBlank">Blank</label>
                <input
                  type="radio"
                  id="roiTypeSample"
                  name="roiType"
                  value="sample"
                  checked
                />
                <label for="roiTypeSample">Sample</label>
              </div>
            </div>
            <div class="form-group">
              <label for="roiShape">Shape</label>
              <select id="roiShape">
                <option value="square">Square</option>
                <option value="circle">Circle</option>
                <option value="pixel">Pixel</option>
              </select>
            </div>
            <div class="form-group">
              <label for="roiSize">Size (px)</label>
              <input type="number" id="roiSize" value="20" min="1" max="500" />
            </div>
            <div class="form-group">
              <label for="roiName">Name (Optional)</label>
              <input
                type="text"
                id="roiName"
                placeholder="Auto (e.g., Sample 1)"
              />
            </div>
            <small style="color:var(--text-color-muted); text-align:center;"
              >Click on the image to place an ROI.</small
            >
          </div>
        </section>
        <section class="collapsible open">
          <div class="collapsible-header">
            <h3 class="panel-title">
              <i class="bi bi-spectrometer"></i> Wavelengths (nm)
            </h3>
            <i class="bi bi-chevron-up collapse-icon"></i>
          </div>
          <div class="collapsible-content">
            <div class="form-group">
              <div class="input-row">
                <input
                  type="number"
                  id="wavelengthInput"
                  placeholder="e.g., 540"
                  min="380"
                  max="780"
                />
                <button id="addWavelengthBtn">Add</button>
              </div>
            </div>
            <ul id="wavelengthList"></ul>
          </div>
        </section>
      </aside>
      <main class="canvas-container">
        <video id="videoFeed" autoplay playsinline></video>
        <canvas id="mainCanvas"></canvas> <canvas id="roiCanvas"></canvas>
        <p id="canvas-placeholder" style="color:var(--text-color-muted);">
          Upload an image or start the camera
        </p>
      </main>
      <aside class="panel data-panel">
        <section class="collapsible open">
          <div class="collapsible-header">
            <h3 class="panel-title">
              <i class="bi bi-graph-up"></i> Live Absorbance
            </h3>
            <i class="bi bi-chevron-up collapse-icon"></i>
          </div>
          <div class="collapsible-content" style="justify-content: center;">
            <div id="liveAbsorbanceLabel"></div>
            <div id="liveAbsorbanceValue">-</div>
            <small
              style="color:var(--text-color-muted); text-align:center;"
              id="liveAbsorbanceInfo"
              >No Blank ROI set</small
            >
          </div>
        </section>
        <section class="collapsible open">
          <div class="collapsible-header">
            <h3 class="panel-title">
              <i class="bi bi-gear"></i> Measurement Mode
            </h3>
            <i class="bi bi-chevron-up collapse-icon"></i>
          </div>
          <div class="collapsible-content">
            <div class="form-group">
              <select id="measurementMode">
                <option value="static">Static Absorbance at Point</option>
                <option value="series">Series Wavelength Scan</option>
                <option value="time">Absorbance at Time Points</option>
              </select>
            </div>
            <div
              id="series-scan-options"
              class="form-group"
              style="display:none;"
            >
              <label>Wavelength Range (nm)</label>
              <div class="input-row">
                <input
                  type="number"
                  id="seriesStart"
                  placeholder="Start"
                  value="400"
                />
                <input
                  type="number"
                  id="seriesEnd"
                  placeholder="End"
                  value="700"
                />
              </div>
              <input
                type="number"
                id="seriesStep"
                placeholder="Step"
                value="10"
              />
            </div>
            <div
              id="time-series-options"
              class="form-group"
              style="display:none;"
            >
              <label>Time Points (seconds, comma-separated)</label>
              <input
                type="text"
                id="timePoints"
                placeholder="e.g. 0, 30, 60, 120"
                value="0, 5, 10"
              />
            </div>
            <button id="startMeasurementBtn">Start Measurement</button>
          </div>
        </section>

        
<section class="collapsible open">
    <div class="collapsible-header">
        <h3 class="panel-title"><i class="bi bi-toggles"></i> ImageSpec Settings</h3>
        <i class="bi bi-chevron-up collapse-icon"></i>
    </div>
    <div class="collapsible-content">
        <div class="setting-row">
    <label for="lockinBlankCheck">Lock-in Blank:</label>
    <div class="setting-control">
        <i class="bi bi-info-circle info-icon-settings" data-info="blank"></i>
        <input type="checkbox" id="lockinBlankCheck" class="styled-checkbox">
    </div>
</div>
<div class="setting-row">
    <label for="lockinSampleCheck">Lock-in Sample:</label>
    <div class="setting-control">
        <i class="bi bi-info-circle info-icon-settings" data-info="sample"></i>
        <input type="checkbox" id="lockinSampleCheck" class="styled-checkbox">
    </div>
</div>

    </div>
</section>


<div id="settingsInfoModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="settingsInfoTitle">Setting Information</h2>
            <button class="close-button">&times;</button>
        </div>
        <p id="settingsInfoContent" style="line-height: 1.6;"></p>
    </div>
</div>

      </aside>
      <footer class="panel results-panel">
        <section class="collapsible open">
          <div class="collapsible-header">
            <h3 class="panel-title">
              <i class="bi bi-table"></i> ROI Data
              <!-- Add this new button -->
              <button
                id="downloadCsvBtn"
                class="icon-button"
                title="Download as CSV"
                style="margin-left: auto;"
              >
                <i class="bi bi-download"></i>
              </button>
            </h3>
            <i class="bi bi-chevron-up collapse-icon"></i>
          </div>

          <div class="collapsible-content">
            <div style="overflow-x: auto; width: 100%;">
              <table id="resultsTable">
                <thead>
                  <tr>
                    <th></th>
                    <th>Name</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </section>
      </footer>
    </div>
    <div id="roiEditModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>Edit ROI</h2>
          <button class="close-button">&times;</button>
        </div>
        <div class="form-group">
          <label for="editRoiName">Name</label>
          <input type="text" id="editRoiName" />
        </div>
        <div class="form-group">
          <label for="editRoiShape">Shape</label>
          <select id="editRoiShape">
            <option value="square">Square</option>
            <option value="circle">Circle</option>
            <option value="pixel">Pixel</option>
          </select>
        </div>
        <div class="form-group">
          <label for="editRoiSize">Size</label>
          <input type="number" id="editRoiSize" min="1" />
        </div>
        <div class="form-group">
          <label for="editRoiColor">Border Color</label>
          <input
            type="color"
            id="editRoiColor"
            style="width:100%; height: 40px; padding: 0;"
          />
        </div>
        <button id="saveRoiChangesBtn" style="margin-top: 20px;">
          Save Changes
        </button>
      </div>
    </div>
    <div id="roiInfoModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>ROI Information</h2>
          <button class="close-button">&times;</button>
        </div>
        <div id="roiInfoContent"></div>
      </div>
    </div>
    <div id="chartModal" class="modal">
      <div class="modal-content" style="max-width: 800px;">
        <div class="modal-header">
          <h2 id="chartTitle">Measurement Chart</h2>
          <button class="close-button">&times;</button>
        </div>
        <canvas id="measurementChart"></canvas>
      </div>
    </div>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const imageLoader = document.getElementById("imageLoader");
        const uploadButton = document.getElementById("uploadButton");
        const mainCanvas = document.getElementById("mainCanvas");
        const roiCanvas = document.getElementById("roiCanvas");
        const videoFeed = document.getElementById("videoFeed");
        const canvasPlaceholder = document.getElementById("canvas-placeholder");
        const mainCtx = mainCanvas.getContext("2d", {
          willReadFrequently: true,
        });
        const roiCtx = roiCanvas.getContext("2d");
        const sourceRadios = document.querySelectorAll('input[name="source"]');
        const wavelengthInput = document.getElementById("wavelengthInput");
        const addWavelengthBtn = document.getElementById("addWavelengthBtn");
        const wavelengthList = document.getElementById("wavelengthList");
        const roiTypeRadios = document.querySelectorAll(
          'input[name="roiType"]'
        );
        const roiShapeSelect = document.getElementById("roiShape");
        const roiSizeInput = document.getElementById("roiSize");
        const roiNameInput = document.getElementById("roiName");
        const liveAbsorbanceValue = document.getElementById(
          "liveAbsorbanceValue"
        );
        const liveAbsorbanceLabel = document.getElementById(
          "liveAbsorbanceLabel"
        );
        const liveAbsorbanceInfo =
          document.getElementById("liveAbsorbanceInfo");
        const measurementModeSelect =
          document.getElementById("measurementMode");
        const seriesScanOptions = document.getElementById(
          "series-scan-options"
        );
        const timeSeriesOptions = document.getElementById(
          "time-series-options"
        );
        const startMeasurementBtn = document.getElementById(
          "startMeasurementBtn"
        );
        const resultsTableBody = document.querySelector("#resultsTable tbody");
        const resultsTableHead = document.querySelector(
          "#resultsTable thead tr"
        );
        const roiEditModal = document.getElementById("roiEditModal");
        const roiInfoModal = document.getElementById("roiInfoModal");
        const chartModal = document.getElementById("chartModal");
        const saveRoiChangesBtn = document.getElementById("saveRoiChangesBtn");
        const editRoiName = document.getElementById("editRoiName");
        const editRoiShape = document.getElementById("editRoiShape");
        const editRoiSize = document.getElementById("editRoiSize");
        const editRoiColor = document.getElementById("editRoiColor");
        const downloadCsvBtn = document.getElementById("downloadCsvBtn");
        
const lockinBlankCheck = document.getElementById('lockinBlankCheck');
const lockinSampleCheck = document.getElementById('lockinSampleCheck');
const settingsInfoModal = document.getElementById('settingsInfoModal');
const settingsInfoTitle = document.getElementById('settingsInfoTitle');
const settingsInfoContent = document.getElementById('settingsInfoContent');

        let currentlyEditingRoiId = null;
        let appState = {
          sourceType: "upload",
          rois: [],
          wavelengths: [540],
          blankRoiId: null,
          nextSampleId: 1,
          isDragging: false,
          draggedRoi: null,
          dragOffsetX: 0,
          dragOffsetY: 0,
          videoStream: null,
          measurementChart: null,
          isMeasuring: false,
          isBlankLocked: false,
isSampleLocked: false,
lockedBlankData: null, // Will hold the complete {avgColor, pixelCount, thumbnailDataUrl}
lockedSampleData: null, // Will hold the same for the locked sample
          liveAbsorbanceIndex: 0,
          liveAbsorbanceInterval: null,
          selectedRoiId: null,
        };
        
function createRoiSnapshot(roi) {
    if (!roi) return null;

    const avgColor = getRoiAverageColor(roi);
    if (!avgColor) return null;

    // Create the thumbnail image data
    let thumbnailDataUrl = '';
    try {
        const size = roi.shape === 'pixel' ? 5 : roi.size;
        const halfSize = Math.floor(size / 2);
        const thumbCanvas = document.createElement('canvas');
        thumbCanvas.width = size;
        thumbCanvas.height = size;
        const thumbCtx = thumbCanvas.getContext('2d');
        const imageData = mainCtx.getImageData(roi.x - halfSize, roi.y - halfSize, size, size);
        thumbCtx.putImageData(imageData, 0, 0);

        if (roi.shape === 'circle') {
            thumbCtx.globalCompositeOperation = 'destination-in';
            thumbCtx.beginPath();
            thumbCtx.arc(halfSize, halfSize, halfSize, 0, Math.PI * 2);
            thumbCtx.fill();
        }
        thumbnailDataUrl = thumbCanvas.toDataURL();
    } catch (e) {
        console.error("Could not create thumbnail snapshot:", e);
    }

    return {
        id: roi.id,
        name: roi.name,
        avgColor: avgColor,
        pixelCount: avgColor.count,
        thumbnailDataUrl: thumbnailDataUrl
    };
}

        
        function wavelengthToRgb(lambda) {
          let r, g, b;
          if (lambda >= 380 && lambda <= 439) {
            r = -(lambda - 440) / (440 - 380);
            g = 0.0;
            b = 1.0;
          } else if (lambda >= 440 && lambda <= 489) {
            r = 0.0;
            g = (lambda - 440) / (490 - 440);
            b = 1.0;
          } else if (lambda >= 490 && lambda <= 509) {
            r = 0.0;
            g = 1.0;
            b = -(lambda - 510) / (510 - 490);
          } else if (lambda >= 510 && lambda <= 579) {
            r = (lambda - 510) / (580 - 510);
            g = 1.0;
            b = 0.0;
          } else if (lambda >= 580 && lambda <= 644) {
            r = 1.0;
            g = -(lambda - 645) / (645 - 580);
            b = 0.0;
          } else if (lambda >= 645 && lambda <= 780) {
            r = 1.0;
            g = 0.0;
            b = 0.0;
          } else {
            r = 0.0;
            g = 0.0;
            b = 0.0;
          }
          let factor;
          if (lambda >= 380 && lambda <= 419) {
            factor = 0.3 + (0.7 * (lambda - 380)) / (420 - 380);
          } else if (lambda >= 420 && lambda <= 700) {
            factor = 1.0;
          } else if (lambda >= 701 && lambda <= 780) {
            factor = 0.3 + (0.7 * (780 - lambda)) / (780 - 700);
          } else {
            factor = 0.0;
          }
          const gamma = 0.8;
          const adjust = (color) =>
            Math.round(255 * Math.pow(color * factor, gamma));
          return { r: adjust(r), g: adjust(g), b: adjust(b) };
        }
        function getRoiAverageColor(roi) {
          if (!mainCanvas.width || !mainCanvas.height) return null;
          const size = roi.shape === "pixel" ? 1 : roi.size;
          const halfSize = size / 2;
          const startX = Math.round(roi.x - halfSize);
          const startY = Math.round(roi.y - halfSize);
          if (
            startX + size < 0 ||
            startX > mainCanvas.width ||
            startY + size < 0 ||
            startY > mainCanvas.height
          )
            return null;
          const imageData = mainCtx.getImageData(
            Math.max(0, startX),
            Math.max(0, startY),
            Math.min(size, mainCanvas.width - startX),
            Math.min(size, mainCanvas.height - startY)
          );
          const data = imageData.data;
          let r = 0,
            g = 0,
            b = 0,
            count = 0;
          for (let i = 0; i < data.length; i += 4) {
            const pixelX = Math.max(0, startX) + ((i / 4) % imageData.width);
            const pixelY =
              Math.max(0, startY) + Math.floor(i / 4 / imageData.width);
            let inShape = false;
            if (roi.shape === "square" || roi.shape === "pixel") {
              inShape = true;
            } else if (roi.shape === "circle") {
              const dx = pixelX - roi.x;
              const dy = pixelY - roi.y;
              if (dx * dx + dy * dy <= halfSize * halfSize) inShape = true;
            }
            if (inShape) {
              r += data[i];
              g += data[i + 1];
              b += data[i + 2];
              count++;
            }
          }
          if (count === 0) return { r: 0, g: 0, b: 0, count: 0 };
          return { r: r / count, g: g / count, b: b / count, count };
        }
        function getWavelengthChannelWeights(wl) {
          const bluePeak = 450,
            greenPeak = 540,
            redPeak = 620;
          const blueSpread = 60,
            greenSpread = 70,
            redSpread = 60;
          const gaussian = (x, peak, spread) =>
            Math.exp(-((x - peak) ** 2) / (2 * spread ** 2));
          let bWeight = gaussian(wl, bluePeak, blueSpread);
          let gWeight = gaussian(wl, greenPeak, greenSpread);
          let rWeight = gaussian(wl, redPeak, redSpread);
          const totalWeight = bWeight + gWeight + rWeight;
          if (totalWeight === 0) return { r: 0, g: 0, b: 0 };
          return {
            r: rWeight / totalWeight,
            g: gWeight / totalWeight,
            b: bWeight / totalWeight,
          };
        }
        function calculateAllAbsorbances() {
    // 1. Find the Blank ROI object to get its properties (like its name).
    const blankRoi = appState.rois.find(r => r.id === appState.blankRoiId);

    // 2. --- CORRECTED: Conditional Blank Color Logic ---
    // This now correctly looks inside the lockedBlankData object for the avgColor property.
    const blankColor = appState.isBlankLocked
        ? appState.lockedBlankData?.avgColor // If locked, use the avgColor from the stored snapshot.
        : (blankRoi ? getRoiAverageColor(blankRoi) : null); // If not locked, perform a live measurement.

    // 3. Validate the Blank
    // The calculation cannot proceed if there is no Blank ROI placed OR if there is no valid color data.
    if (!blankRoi || !blankColor) {
        liveAbsorbanceInfo.textContent = "No Blank ROI set";
        // Clear old absorbance data from all samples since the calibration is invalid.
        appState.rois.filter(r => r.type === 'sample').forEach(sampleRoi => {
            sampleRoi.absorbance = {};
        });
        // Update the UI to reflect the missing calibration.
        updateResultsTable();
        updateLiveAbsorbanceDisplay();
        return; // Stop the function here.
    }

    // 4. If validation passes, proceed with calculations.
    liveAbsorbanceInfo.textContent = `Blank: ${blankRoi.name}`;

    // Loop through every ROI in the list.
    appState.rois.forEach(roi => {
        // We only calculate absorbance for ROIs marked as 'sample'.
        if (roi.type === 'sample') {
            const sampleColor = getRoiAverageColor(roi);
            if (!sampleColor) {
                roi.absorbance = {}; // Clear data if sample color can't be read.
                return;
            }

            // For each sample, loop through every wavelength the user has added.
            appState.wavelengths.forEach(wl => {
                const weights = getWavelengthChannelWeights(wl);
                const blankIntensity = weights.r * blankColor.r + weights.g * blankColor.g + weights.b * blankColor.b;
                const sampleIntensity = weights.r * sampleColor.r + weights.g * sampleColor.g + weights.b * sampleColor.b;

                if (blankIntensity > 0 && sampleIntensity > 0) {
                    roi.absorbance[wl] = -Math.log10(sampleIntensity / blankIntensity).toFixed(3);
                } else {
                    roi.absorbance[wl] = 'inf'; // Set to 'inf' for total absorption.
                }
            });
        }
    });

    // 5. After all calculations are done, update the entire UI.
    updateResultsTable();
    updateLiveAbsorbanceDisplay();
}
        function updateLiveAbsorbanceDisplay() {
          let targetRoi = null;

          // Priority 1: Find the user-selected ROI
          if (appState.selectedRoiId) {
            targetRoi = appState.rois.find(
              (r) => r.id === appState.selectedRoiId
            );
          }

          // Priority 2: If no selection, find the last added sample ROI
          if (!targetRoi) {
            const samples = appState.rois.filter((r) => r.type === "sample");
            if (samples.length > 0) {
              targetRoi = samples[samples.length - 1];
            }
          }

          const blankRoi = appState.rois.find(
            (r) => r.id === appState.blankRoiId
          );

          // Now, update the display based on the targetRoi we found
          if (targetRoi && blankRoi && appState.wavelengths.length > 0) {
            if (appState.liveAbsorbanceIndex >= appState.wavelengths.length) {
              appState.liveAbsorbanceIndex = 0;
            }

            const wl = appState.wavelengths[appState.liveAbsorbanceIndex];
            const absorbance = targetRoi.absorbance[wl];
            const rgb = wavelengthToRgb(wl);

            // Update text content and apply the matching color
            liveAbsorbanceLabel.textContent = `${targetRoi.name} @ ${wl} nm`;
            liveAbsorbanceValue.textContent = absorbance || "-";
            liveAbsorbanceValue.style.color = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
            liveAbsorbanceInfo.textContent = `Blank: ${blankRoi.name}`;
          } else {
            // Default state if no valid sample/blank/wavelength
            liveAbsorbanceLabel.textContent = "";
            liveAbsorbanceValue.textContent = "-";
            liveAbsorbanceValue.style.color = "var(--secondary-color)"; // Reset to default color

            if (!blankRoi) {
              liveAbsorbanceInfo.textContent = "No Blank ROI set";
            } else if (!targetRoi) {
              liveAbsorbanceInfo.textContent = "No Sample ROI set";
            } else {
              liveAbsorbanceInfo.textContent = "No Wavelengths added";
            }
          }
        }

        document.querySelectorAll(".collapsible-header").forEach((header) => {
          header.addEventListener("click", () => {
            header.closest(".collapsible").classList.toggle("open");
          });
        });
        function drawROIs() {
    // 1. Clear the canvas for a fresh drawing
    roiCtx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);

    // 2. Determine the current state before looping (this is more efficient)
    // Check if at least one sample ROI exists on the canvas
    const hasSample = appState.rois.some(r => r.type === 'sample');
    // Check if at least one sample exists that ISN'T the locked one
    const nonLockedSamplesExist = appState.rois.some(r => r.type === 'sample' && r.id !== appState.lockedSampleRoiId);

    // 3. Loop through all ROIs and decide whether to draw them
    appState.rois.forEach(roi => {

        // --- NEW: Conditional Hiding Logic ---

        // Condition A: Hide the Blank ROI if "Lock-in Blank" is active and a sample has been placed.
        if (roi.type === 'blank' && appState.isBlankLocked && hasSample) {
            return; // Skip the rest of the function for this ROI
        }

        // Condition B: Hide the "locked" Sample ROI if "Lock-in Sample" is active and a different sample has been placed.
        if (roi.id === appState.lockedSampleRoiId && appState.isSampleLocked && nonLockedSamplesExist) {
            return; // Skip the rest of the function for this ROI
        }

        // --- END: Conditional Hiding Logic ---


        // 4. If the ROI was not hidden, proceed with the original drawing logic
        const size = roi.shape === 'pixel' ? 5 : roi.size;
        const halfSize = size / 2;
        roiCtx.strokeStyle = roi.color;
        roiCtx.lineWidth = 2;
        roiCtx.fillStyle = `${roi.color}33`; // Semi-transparent fill
        roiCtx.font = "12px Arial";
        roiCtx.textAlign = "center";

        // Draw the shape (circle or square/pixel)
        roiCtx.beginPath();
        if (roi.shape === 'circle') {
            roiCtx.arc(roi.x, roi.y, halfSize, 0, Math.PI * 2);
        } else {
            roiCtx.rect(roi.x - halfSize, roi.y - halfSize, size, size);
        }
        roiCtx.stroke();
        roiCtx.fill();

        // Draw the name label above the ROI
        roiCtx.fillStyle = roi.color;
        roiCtx.fillText(roi.name, roi.x, roi.y - halfSize - 5);

        // Draw the manual lock icon if the user has locked it from the table
        if (roi.locked) {
            roiCtx.font = "15px Arial";
            roiCtx.fillStyle = roi.color;
            roiCtx.fillText('🔒', roi.x, roi.y + halfSize + 15);
        }
    });
}
        function updateWavelengthList() {
          wavelengthList.innerHTML = "";
          appState.wavelengths.forEach((wl) => {
            const rgb = wavelengthToRgb(wl);
            const li = document.createElement("li");
            li.style.backgroundColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
            const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            li.style.color = brightness > 128 ? "#000" : "#fff";
            li.innerHTML = `${wl} nm <button data-wl="${wl}" class="delete-wl">&times;</button>`;
            wavelengthList.appendChild(li);
          });
          updateResultsTableHeader();
        }
        function updateResultsTableHeader() {
          let headers = `<th></th><th>Name</th>`;
          headers += appState.wavelengths
            .map((wl) => `<th>${wl} nm</th>`)
            .join("");
          headers += `<th>Actions</th>`;
          resultsTableHead.innerHTML = headers;
        }
        function updateResultsTable() {
    // 1. Clear the existing table content to prepare for a fresh render.
    resultsTableBody.innerHTML = '';

    // 2. Loop through every ROI currently in the application state.
    appState.rois.forEach(roi => {
        const tr = document.createElement('tr');
        let thumbCellHtml = ''; // This variable will hold the HTML for the first cell (the thumbnail).

        // --- NEW: Conditional Thumbnail Logic ---
        // This block decides WHICH thumbnail to show: a live one or a stored snapshot.

        // Case A: Is the current ROI the "Blank" AND is the lock-in feature active?
        if (appState.isBlankLocked && roi.type === 'blank' && appState.lockedBlankData) {
            // If yes, use the stored thumbnail from the snapshot.
            // This ensures the original blank's image is shown even after uploading a new photo.
            thumbCellHtml = `<img src="${appState.lockedBlankData.thumbnailDataUrl}" class="roi-thumbnail" style="border-radius: ${roi.shape === 'circle' ? '50%' : '4px'};" title="Locked Blank Snapshot">`;

        // Case B: Is the current ROI the locked "Sample" AND is the feature active?
        } else if (appState.isSampleLocked && roi.id === appState.lockedSampleData?.id && appState.lockedSampleData) {
            // If yes, use the stored thumbnail from the sample's snapshot.
            thumbCellHtml = `<img src="${appState.lockedSampleData.thumbnailDataUrl}" class="roi-thumbnail" style="border-radius: ${roi.shape === 'circle' ? '50%' : '4px'};" title="Locked Sample Snapshot">`;

        // Case C: For all other ROIs (any unlocked or live ROI).
        } else {
            // Revert to the original behavior: generate the thumbnail live from the current canvas.
            const avgColor = getRoiAverageColor(roi) || { r: 0, g: 0, b: 0 };
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = 24;
            thumbCanvas.height = 24;
            const thumbCtx = thumbCanvas.getContext('2d');
            thumbCtx.fillStyle = `rgb(${avgColor.r.toFixed(0)}, ${avgColor.g.toFixed(0)}, ${avgColor.b.toFixed(0)})`;
            thumbCtx.fillRect(0, 0, 24, 24);
            thumbCellHtml = `<img src="${thumbCanvas.toDataURL()}" class="roi-thumbnail" title="Live ROI">`;
        }

        // --- END: Conditional Thumbnail Logic ---


        // 3. Assemble the rest of the table row.
        // Get the absorbance values for each wavelength.
        const absorbanceCells = appState.wavelengths.map(wl => `<td>${roi.absorbance ? (roi.absorbance[wl] || '-') : '-'}</td>`).join('');

        // Build the complete HTML string for the row, including the correct thumbnail and all action buttons.
        tr.innerHTML = `
            <td>${thumbCellHtml}</td>
            <td>${roi.name}</td>
            ${absorbanceCells}
            <td>
                <button class="icon-button lock-roi-btn" data-id="${roi.id}" title="Toggle Lock">${roi.locked ? '<i class="bi bi-lock-fill"></i>' : '<i class="bi bi-unlock-fill"></i>'}</button>
                <button class="icon-button edit-roi-btn" data-id="${roi.id}" title="Edit"><i class="bi bi-pencil"></i></button>
                <button class="icon-button info-roi-btn" data-id="${roi.id}" title="Info"><i class="bi bi-info-circle"></i></button>
                <button class="icon-button chart-roi-btn" data-id="${roi.id}" title="Chart" style="display: ${measurementModeSelect.value === 'series' ? 'inline-block' : 'none'};"><i class="bi bi-bar-chart"></i></button>
                <button class="icon-button delete-roi-btn" data-id="${roi.id}" title="Delete"><i class="bi bi-trash"></i></button>
            </td>`;

        // 4. Append the fully constructed row to the table body.
        resultsTableBody.appendChild(tr);
    });
}
        function handleImageUpload(e) {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
              setCanvasSize(img.width, img.height);
              mainCtx.drawImage(img, 0, 0);
              canvasPlaceholder.style.display = "none";

// --- ADD THIS LOGIC ---
        // Clear only sample ROIs if blank is locked
        if (appState.isBlankLocked) {
            appState.rois = appState.rois.filter(r => r.type === 'blank');
        } else {
            // Original behavior: clear everything
            appState.rois = [];
            appState.blankRoiId = null;
            appState.lockedBlankColor = null;
        }
        // --- END LOGIC ---
            
              calculateAllAbsorbances();
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
        }
        async function startCamera() {
          try {
            if (appState.videoStream) {
              appState.videoStream.getTracks().forEach((track) => track.stop());
            }
            appState.videoStream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: "environment" },
            });
            videoFeed.srcObject = appState.videoStream;
            videoFeed.onloadedmetadata = () => {
              setCanvasSize(videoFeed.videoWidth, videoFeed.videoHeight);
              canvasPlaceholder.style.display = "none";
              requestAnimationFrame(drawVideoFrame);
            };
          } catch (err) {
            console.error("Error accessing camera:", err);
            alert("Could not access camera. Please check permissions.");
          }
        }
        function stopCamera() {
          if (appState.videoStream) {
            appState.videoStream.getTracks().forEach((track) => track.stop());
            appState.videoStream = null;
          }
        }
        function drawVideoFrame() {
          if (
            appState.sourceType === "camera" &&
            !videoFeed.paused &&
            !videoFeed.ended &&
            !appState.isMeasuring
          ) {
            mainCtx.drawImage(
              videoFeed,
              0,
              0,
              mainCanvas.width,
              mainCanvas.height
            );
            calculateAllAbsorbances();
            requestAnimationFrame(drawVideoFrame);
          }
        }
        function setCanvasSize(width, height) {
          mainCanvas.width = roiCanvas.width = width;
          mainCanvas.height = roiCanvas.height = height;
          drawROIs();
        }
        uploadButton.addEventListener("click", () => imageLoader.click());
        imageLoader.addEventListener("change", handleImageUpload);
        sourceRadios.forEach((radio) => {
          radio.addEventListener("change", (e) => {
            appState.sourceType = e.target.value;
            if (appState.sourceType === "camera") {
              startCamera();
              uploadButton.style.display = "none";
              imageLoader.style.display = "none";
            } else {
              stopCamera();
              uploadButton.style.display = "block";
              imageLoader.style.display = "block";
            }
          });
        });
        addWavelengthBtn.addEventListener("click", () => {
          const wl = parseInt(wavelengthInput.value);
          if (wl >= 380 && wl <= 780 && !appState.wavelengths.includes(wl)) {
            appState.wavelengths.push(wl);
            appState.wavelengths.sort((a, b) => a - b);
            wavelengthInput.value = "";
            updateWavelengthList();
            calculateAllAbsorbances();
          }
        });
        wavelengthList.addEventListener("click", (e) => {
          if (e.target.classList.contains("delete-wl")) {
            const wlToRemove = parseInt(e.target.dataset.wl);
            appState.wavelengths = appState.wavelengths.filter(
              (wl) => wl !== wlToRemove
            );
            updateWavelengthList();
            calculateAllAbsorbances();
          }
        });
        roiCanvas.addEventListener("mousedown", (e) => {
          const rect = roiCanvas.getBoundingClientRect();
          const scaleX = roiCanvas.width / rect.width;
          const scaleY = roiCanvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;
          let clickedOnRoi = null;
          for (let i = appState.rois.length - 1; i >= 0; i--) {
            const roi = appState.rois[i];
            const dist = Math.sqrt(
              Math.pow(x - roi.x, 2) + Math.pow(y - roi.y, 2)
            );
            if (dist < roi.size / 2) {
              clickedOnRoi = roi;
              break;
            }
          }
          if (clickedOnRoi && !clickedOnRoi.locked) {
            appState.isDragging = true;
            appState.draggedRoi = clickedOnRoi;
            appState.dragOffsetX = x - clickedOnRoi.x;
            appState.dragOffsetY = y - clickedOnRoi.y;
          } else if (!clickedOnRoi && mainCanvas.width > 0) {
            addRoi(x, y);
          }
        });
        roiCanvas.addEventListener("mousemove", (e) => {
          if (appState.isDragging && appState.draggedRoi) {
            const rect = roiCanvas.getBoundingClientRect();
            const scaleX = roiCanvas.width / rect.width;
            const scaleY = roiCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            appState.draggedRoi.x = x - appState.dragOffsetX;
            appState.draggedRoi.y = y - appState.dragOffsetY;
            appState.draggedRoi.x = Math.max(
              0,
              Math.min(mainCanvas.width, appState.draggedRoi.x)
            );
            appState.draggedRoi.y = Math.max(
              0,
              Math.min(mainCanvas.height, appState.draggedRoi.y)
            );
            drawROIs();
            calculateAllAbsorbances();
          }
        });
        window.addEventListener("mouseup", () => {
          appState.isDragging = false;
          appState.draggedRoi = null;
        });
        resultsTableBody.addEventListener("click", (e) => {
          // --- New Row Selection & Highlighting Logic ---
          const row = e.target.closest("tr");
          if (!row) return; // Exit if the click was not inside a row

          // Find the ROI ID associated with the clicked row.
          // We get it from a button within the row as a reliable source.
          const buttonInRow = row.querySelector("td:last-child button");
          if (buttonInRow) {
            const id = buttonInRow.dataset.id;
            const roi = appState.rois.find((r) => r.id === id);

            // Check if the clicked ROI is a sample. We only want to select samples for live view.
            if (roi && roi.type === "sample") {
              // If the user clicks the *same* row again, deselect it. Otherwise, select the new one.
              if (appState.selectedRoiId === id) {
                appState.selectedRoiId = null;
                row.style.backgroundColor = ""; // Remove highlight
              } else {
                appState.selectedRoiId = id;
                // Remove highlighting from all other rows first
                document
                  .querySelectorAll("#resultsTable tbody tr")
                  .forEach((tr) => (tr.style.backgroundColor = ""));
                // Apply highlight to the newly selected row
                row.style.backgroundColor = "rgba(187, 134, 252, 0.2)";
              }
            }
            // Always update the display after a click to reflect the new selection or deselection
            updateLiveAbsorbanceDisplay();
          }

          // --- Original Button-Specific Logic ---
          // Check if the actual click target was a button
          const button = e.target.closest("button");
          if (!button) return; // If not, we're done (the click was just for selection)

          const id = button.dataset.id;
          const roi = appState.rois.find((r) => r.id === id);

          if (button.classList.contains("lock-roi-btn")) {
            if (roi) {
              roi.locked = !roi.locked;
              drawROIs();
              updateResultsTable(); // Redraw table to update the icon
            }
          } else if (button.classList.contains("edit-roi-btn")) {
            openEditModal(id);
          } else if (button.classList.contains("info-roi-btn")) {
            openInfoModal(id);
          } else if (button.classList.contains("chart-roi-btn")) {
            if (roi && roi.seriesData) {
              showChart(
                roi.seriesData,
                "Wavelength (nm)",
                "Absorbance",
                `${roi.name} - Wavelength Scan`
              );
            }
          } else if (button.classList.contains("delete-roi-btn")) {
            appState.rois = appState.rois.filter((roi) => roi.id !== id);
            if (appState.blankRoiId === id) appState.blankRoiId = null;
            // If the deleted ROI was the selected one, clear the selection
            if (appState.selectedRoiId === id) appState.selectedRoiId = null;
            drawROIs();
            calculateAllAbsorbances(); // This will also call updateResultsTable
          }
        });

        downloadCsvBtn.addEventListener("click", downloadDataAsCSV);

        document.addEventListener('click', (e) => {
    if (e.target.classList.contains('info-icon-settings')) {
        const infoType = e.target.dataset.info;
        if (infoType === 'blank') {
            settingsInfoTitle.textContent = 'Lock-in Blank Explained';
            settingsInfoContent.textContent = 'When checked, the app "locks in" the color value of your Blank ROI. This allows you to change the image (e.g., upload a new one or swap samples in the live camera) without losing your calibration. Once a Sample ROI is placed, the Blank ROI will disappear from the view to reduce clutter, as its value is already stored in memory.';
        } else if (infoType === 'sample') {
            settingsInfoTitle.textContent = 'Lock-in Sample Explained';
            settingsInfoContent.textContent = 'When checked, the app locks the first Sample ROI you place. This is useful for comparative analysis. The locked sample ROI will disappear from the view when you place a second sample, allowing you to use the full frame to measure a new sample against the original locked one.';
        }
        settingsInfoModal.style.display = 'flex';
    }
});

settingsInfoModal.querySelector('.close-button').addEventListener('click', () => settingsInfoModal.style.display = 'none');

        lockinBlankCheck.addEventListener('change', (e) => {
    appState.isBlankLocked = e.target.checked;
    if (!appState.isBlankLocked) {
        appState.lockedBlankData = null; // Clear the snapshot
    } else {
        const blankRoi = appState.rois.find(r => r.id === appState.blankRoiId);
        if (blankRoi) {
            appState.lockedBlankData = createRoiSnapshot(blankRoi); // Create the snapshot
        }
    }
    drawROIs();
});

        lockinSampleCheck.addEventListener('change', (e) => {
    // 1. Update the state based on whether the box is checked or not.
    appState.isSampleLocked = e.target.checked;

    // 2. --- NEW and IMPROVED Logic ---
    if (appState.isSampleLocked) {
        // If the user just CHECKED the box, we need to find a sample to lock.
        // The most intuitive choice is the most recently added sample.

        // Find all ROIs that are samples.
        const samples = appState.rois.filter(r => r.type === 'sample');

        // If at least one sample exists...
        if (samples.length > 0) {
            // Get the last one from the array.
            const lastSample = samples[samples.length - 1];

            // ...and immediately create a data snapshot of it.
            appState.lockedSampleData = createRoiSnapshot(lastSample);
            appState.lockedSampleRoiId = lastSample.id;
        }
    } else {
        // --- Original Logic ---
        // If the user UNCHECKED the box, clear all locked sample data.
        // This ensures the system is reset cleanly.
        appState.lockedSampleData = null;
        appState.lockedSampleRoiId = null;
    }

    // 3. Refresh the UI.
    // This is important to potentially hide the newly locked sample if other samples exist.
    drawROIs();
});



        measurementModeSelect.addEventListener("change", (e) => {
          seriesScanOptions.style.display =
            e.target.value === "series" ? "block" : "none";
          timeSeriesOptions.style.display =
            e.target.value === "time" ? "block" : "none";
          document.querySelectorAll(".chart-roi-btn").forEach((btn) => {
            btn.style.display =
              e.target.value === "series" ? "inline-block" : "none";
          });
        });
        startMeasurementBtn.addEventListener("click", handleStartMeasurement);
        
        function addRoi(x, y) {
    // 1. Get all the properties for the new ROI from the UI controls.
    const type = document.querySelector('input[name="roiType"]:checked').value;
    const id = 'roi-' + Date.now();
    const name = roiNameInput.value || (type === 'blank' ? 'Blank' : `Sample ${appState.nextSampleId++}`);

    const newRoi = {
        id: id,
        name: name,
        type: type,
        shape: roiShapeSelect.value,
        size: parseInt(roiSizeInput.value),
        x: x,
        y: y,
        color: type === 'blank' ? '#03dac6' : '#bb86fc',
        absorbance: {},
        locked: false
    };

    // 2. Handle logic specific to placing a "Blank" ROI.
    if (type === 'blank') {
        // Ensure only one blank exists by removing any previous ones.
        appState.rois = appState.rois.filter(r => r.type !== 'blank');
        appState.blankRoiId = id;

        // --- "Lock-in Blank" Logic ---
        // If the lock setting is active, create a complete snapshot of the blank's data
        // at this exact moment and store it.
        if (appState.isBlankLocked) {
            appState.lockedBlankData = createRoiSnapshot(newRoi);
        }
    }

    // 3. Handle logic specific to placing a "Sample" ROI.
    if (type === 'sample') {
        // --- "Lock-in Sample" Logic ---
        // If the lock setting is active AND no sample has been locked yet,
        // this new ROI becomes the locked one.
        if (appState.isSampleLocked && !appState.lockedSampleData) {
            // Create a complete data snapshot of this sample and store it.
            appState.lockedSampleData = createRoiSnapshot(newRoi);
            // Also store its ID for faster lookups in other functions (like drawROIs).
            appState.lockedSampleRoiId = newRoi.id;
        }
    }

    // 4. Add the newly created ROI to the main array.
    appState.rois.push(newRoi);
    roiNameInput.value = ''; // Clear the input field for the next ROI.

    // 5. Trigger a full UI and data refresh.
    // These functions will now use the new state (locked data, etc.) to render correctly.
    drawROIs();
    calculateAllAbsorbances();
}
        function openEditModal(id) {
          const roi = appState.rois.find((r) => r.id === id);
          if (roi) {
            currentlyEditingRoiId = id;
            editRoiName.value = roi.name;
            editRoiShape.value = roi.shape;
            editRoiSize.value = roi.size;
            editRoiColor.value = roi.color;
            roiEditModal.style.display = "flex";
          }
        }
        saveRoiChangesBtn.addEventListener("click", () => {
          const roi = appState.rois.find((r) => r.id === currentlyEditingRoiId);
          if (roi) {
            roi.name = editRoiName.value;
            roi.shape = editRoiShape.value;
            roi.size = parseInt(editRoiSize.value);
            roi.color = editRoiColor.value;
            if (roi.type === "blank") {
              roi.color = "#03dac6";
            }
            drawROIs();
            calculateAllAbsorbances();
            closeAllModals();
          }
        });
        function openInfoModal(id) {
    const roi = appState.rois.find(r => r.id === id);
    if (!roi) return;

    let infoData;

    // Check if the ROI is a locked one and use its snapshot
    if (appState.isBlankLocked && roi.type === 'blank' && appState.lockedBlankData) {
        infoData = appState.lockedBlankData;
    } else if (appState.isSampleLocked && roi.id === appState.lockedSampleData?.id && appState.lockedSampleData) {
        infoData = appState.lockedSampleData;
    } else {
        // Original behavior: create a snapshot on-the-fly for a live ROI
        infoData = createRoiSnapshot(roi);
    }

    if (!infoData) {
        document.getElementById('roiInfoContent').innerHTML = `<p>Could not retrieve data for this ROI.</p>`;
        roiInfoModal.style.display = 'flex';
        return;
    }

    const previewImageHtml = `<div class="info-preview-container">
        <img src="${infoData.thumbnailDataUrl}" class="info-preview-image" title="Actual ROI Pixels" style="border-radius: ${roi.shape === 'circle' ? '50%' : '4px'};">
        <p><strong>Average Color:</strong> <span style="display:inline-block; width: 16px; height: 16px; background-color: rgb(${infoData.avgColor.r.toFixed(0)}, ${infoData.avgColor.g.toFixed(0)}, ${infoData.avgColor.b.toFixed(0)}); border: 1px solid #fff; vertical-align: middle;"></span></p>
    </div>`;

    const content = document.getElementById('roiInfoContent');
    content.innerHTML = `<p><strong>Name:</strong> ${infoData.name}</p>
                       <p><strong>Pixels in ROI:</strong> ${infoData.pixelCount}</p>
                       <p><strong>Avg RGB:</strong> R:${infoData.avgColor.r.toFixed(1)}, G:${infoData.avgColor.g.toFixed(1)}, B:${infoData.avgColor.b.toFixed(1)}</p>
                       ${previewImageHtml}`;

    roiInfoModal.style.display = 'flex';
}

        function closeAllModals() {
          document
            .querySelectorAll(".modal")
            .forEach((modal) => (modal.style.display = "none"));
          currentlyEditingRoiId = null;
        }
        document
          .querySelectorAll(".modal .close-button")
          .forEach((btn) => btn.addEventListener("click", closeAllModals));
        window.addEventListener("click", (e) => {
          if (e.target.classList.contains("modal")) {
            closeAllModals();
          }
        });
        async function handleStartMeasurement() {
          if (appState.isMeasuring) return;
          appState.isMeasuring = true;
          startMeasurementBtn.disabled = true;
          const mode = measurementModeSelect.value;
          try {
            if (mode === "series") {
              startMeasurementBtn.textContent = "Scanning...";
              await runSeriesScan();
            } else if (mode === "time") {
              await runTimeSeries();
            }
          } catch (e) {
            console.error("Measurement failed: ", e);
            alert("An error occurred during measurement.");
          } finally {
            appState.isMeasuring = false;
            startMeasurementBtn.textContent = "Start Measurement";
            startMeasurementBtn.disabled = false;
          }
        }
        function runSeriesScan() {
          return new Promise((resolve) => {
            const sampleRoi = appState.rois.find((r) => r.type === "sample");
            if (!sampleRoi) {
              alert("Please add at least one Sample ROI.");
              return resolve();
            }
            const blankRoi = appState.rois.find(
              (r) => r.id === appState.blankRoiId
            );
            if (!blankRoi) {
              alert("Please set a Blank ROI.");
              return resolve();
            }
            const start = parseInt(
              document.getElementById("seriesStart").value
            );
            const end = parseInt(document.getElementById("seriesEnd").value);
            const step = parseInt(document.getElementById("seriesStep").value);
            const blankColor = getRoiAverageColor(blankRoi);
            const sampleColor = getRoiAverageColor(sampleRoi);
            const seriesData = {
              labels: [],
              datasets: [
                {
                  label: "Absorbance",
                  data: [],
                  borderColor: "#03dac6",
                  backgroundColor: "#03dac633",
                  tension: 0.1,
                  fill: true,
                },
              ],
            };
            for (let wl = start; wl <= end; wl += step) {
              const weights = getWavelengthChannelWeights(wl);
              const blankIntensity =
                weights.r * blankColor.r +
                weights.g * blankColor.g +
                weights.b * blankColor.b;
              const sampleIntensity =
                weights.r * sampleColor.r +
                weights.g * sampleColor.g +
                weights.b * sampleColor.b;
              let absorbance = 0;
              if (blankIntensity > 0 && sampleIntensity > 0) {
                absorbance = -Math.log10(sampleIntensity / blankIntensity);
              }
              seriesData.labels.push(wl);
              seriesData.datasets[0].data.push(absorbance);
            }
            sampleRoi.seriesData = seriesData;
            showChart(
              seriesData,
              "Wavelength (nm)",
              "Absorbance",
              `${sampleRoi.name} - Wavelength Scan`
            );
            resolve();
          });
        }
        function runTimeSeries() {
          return new Promise((resolve) => {
            if (appState.sourceType !== "camera") {
              alert("Time series measurement requires the live camera source.");
              return resolve();
            }
            const sampleRoi = appState.rois.find((r) => r.type === "sample");
            if (!sampleRoi || !appState.blankRoiId) {
              alert("Please set one Blank and at least one Sample ROI.");
              return resolve();
            }
            const timePointsInput = document.getElementById("timePoints").value;
            const timePoints = timePointsInput
              .split(",")
              .map((t) => parseFloat(t.trim()))
              .filter((t) => !isNaN(t) && t >= 0)
              .sort((a, b) => a - b);
            if (timePoints.length === 0) {
              alert("Please enter valid, comma-separated time points.");
              return resolve();
            }
            const timeData = { labels: [], datasets: [] };
            appState.wavelengths.forEach((wl) => {
              const rgb = wavelengthToRgb(wl);
              timeData.datasets.push({
                label: `${wl} nm`,
                data: [],
                borderColor: `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`,
                backgroundColor: `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)`,
                tension: 0.1,
                pointRadius: 4,
                fill: true,
              });
            });
            showChart(
              timeData,
              "Time (s)",
              "Absorbance",
              "Time Series Measurement"
            );
            let currentIndex = 0;
            function takeMeasurementAtNextPoint() {
              if (currentIndex >= timePoints.length) {
                startMeasurementBtn.textContent = "Start Measurement";
                resolve();
                return;
              }
              const targetTime = timePoints[currentIndex];
              const previousTime =
                currentIndex > 0 ? timePoints[currentIndex - 1] : 0;
              const delay = (targetTime - previousTime) * 1000;
              startMeasurementBtn.textContent = `Waiting for ${targetTime}s...`;
              setTimeout(() => {
                startMeasurementBtn.textContent = `Measuring at ${targetTime}s...`;
                mainCtx.drawImage(
                  videoFeed,
                  0,
                  0,
                  mainCanvas.width,
                  mainCanvas.height
                );
                calculateAllAbsorbances();
                timeData.labels.push(targetTime);
                appState.wavelengths.forEach((wl, index) => {
                  while (timeData.datasets[index].data.length < currentIndex) {
                    timeData.datasets[index].data.push(null);
                  }
                  timeData.datasets[index].data.push(
                    sampleRoi.absorbance[wl] || 0
                  );
                });
                appState.measurementChart.update();
                currentIndex++;
                takeMeasurementAtNextPoint();
              }, delay);
            }
            takeMeasurementAtNextPoint();
          });
        }
        function showChart(data, xLabel, yLabel, titleText) {
          const chartCanvas = document.getElementById("measurementChart");
          if (appState.measurementChart) {
            appState.measurementChart.destroy();
          }
          document.getElementById("chartTitle").textContent = titleText;
          appState.measurementChart = new Chart(chartCanvas, {
            type: "line",
            data: data,
            options: {
              responsive: true,
              scales: {
                x: {
                  title: { display: true, text: xLabel, color: "#fff" },
                  ticks: { color: "#aaa" },
                  grid: { color: "#444" },
                },
                y: {
                  title: { display: true, text: yLabel, color: "#fff" },
                  ticks: { color: "#aaa" },
                  grid: { color: "#444" },
                },
              },
              plugins: { legend: { labels: { color: "#fff" } } },
            },
          });
          chartModal.style.display = "flex";
        }

        function downloadDataAsCSV() {
          // 1. Define CSV Headers
          const headers = [
            "Name",
            ...appState.wavelengths.map((wl) => `${wl} nm`),
          ];

          // 2. Map ROI data to CSV rows
          const rows = appState.rois.map((roi) => {
            // Enclose the name in double quotes to handle commas within names
            const name = `"${roi.name}"`;

            // Get the absorbance value for each wavelength in the correct order
            const values = appState.wavelengths.map((wl) => {
              return roi.absorbance ? roi.absorbance[wl] || "" : "";
            });

            // Combine the name and values into a single row string
            return [name, ...values].join(",");
          });

          // 3. Combine headers and rows into a single CSV string
          const csvContent = [headers.join(","), ...rows].join("\n");

          // 4. Create a Blob and trigger the download
          const blob = new Blob([csvContent], {
            type: "text/csv;charset=utf-8;",
          });
          const link = document.createElement("a");
          if (link.download !== undefined) {
            // Check for browser support
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "ImageSpec_ROI_Data.csv");
            link.style.visibility = "hidden";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          }
        }

        function init() {
          updateWavelengthList();
          calculateAllAbsorbances();
          if (appState.liveAbsorbanceInterval)
            clearInterval(appState.liveAbsorbanceInterval);
          appState.liveAbsorbanceInterval = setInterval(() => {
            if (appState.wavelengths.length > 0) {
              appState.liveAbsorbanceIndex =
                (appState.liveAbsorbanceIndex + 1) %
                appState.wavelengths.length;
            }
            liveAbsorbanceValue.style.opacity = 0;
            setTimeout(() => {
              updateLiveAbsorbanceDisplay();
              liveAbsorbanceValue.style.opacity = 1;
            }, 300);
          }, 2500);
          console.log("Spectrophotometer Initialized");
        }
        init();
      });
    </script>
  </body>
</html>
